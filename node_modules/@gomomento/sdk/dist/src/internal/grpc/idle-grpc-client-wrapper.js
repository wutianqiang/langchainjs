"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.IdleGrpcClientWrapper = void 0;
/**
 * This wrapper allows us to ensure that a grpc client is not re-used if it has been idle
 * for longer than a specified period of time.  This is important in some environments,
 * such as AWS Lambda, where the runtime may be paused indefinitely between invocations.
 * In such cases we have observed that while the runtime is suspended, the connection
 * may have been closed by the server. (e.g., AWS NLB has an idle timeout of 350s:
 * https://docs.aws.amazon.com/elasticloadbalancing/latest/network/network-load-balancers.html#connection-idle-timeout )
 * When the runtime resumes, it does not recognize that the connection has been closed,
 * and it may continue to attempt to send bytes to it, resulting in client-side timeouts
 * (DEADLINE_EXCEEDED).  Forcefully refreshing the client if it has been idle for too
 * long will prevent this.
 *
 * NOTE: We can't rely on keepalive pings in this scenario, because the lambda runtime
 * may be suspended in such a way that background tasks such as the keepalive pings
 * will not be able to execute.
 */
class IdleGrpcClientWrapper {
    constructor(props) {
        this.logger = props.configuration.getLoggerFactory().getLogger(this);
        this.clientFactoryFn = props.clientFactoryFn;
        this.client = this.clientFactoryFn();
        this.maxIdleMillis = props.configuration
            .getTransportStrategy()
            .getMaxIdleMillis();
        this.lastAccessTime = Date.now();
    }
    getClient() {
        this.logger.trace(`Checking to see if client has been idle for more than ${this.maxIdleMillis} ms`);
        if (Date.now() - this.lastAccessTime > this.maxIdleMillis) {
            this.logger.info(`Client has been idle for more than ${this.maxIdleMillis} ms; reconnecting.`);
            this.client.close();
            this.client = this.clientFactoryFn();
        }
        this.lastAccessTime = Date.now();
        return this.client;
    }
}
exports.IdleGrpcClientWrapper = IdleGrpcClientWrapper;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaWRsZS1ncnBjLWNsaWVudC13cmFwcGVyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vc3JjL2ludGVybmFsL2dycGMvaWRsZS1ncnBjLWNsaWVudC13cmFwcGVyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQVNBOzs7Ozs7Ozs7Ozs7Ozs7R0FlRztBQUNILE1BQWEscUJBQXFCO0lBV2hDLFlBQVksS0FBb0M7UUFDOUMsSUFBSSxDQUFDLE1BQU0sR0FBRyxLQUFLLENBQUMsYUFBYSxDQUFDLGdCQUFnQixFQUFFLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQ3JFLElBQUksQ0FBQyxlQUFlLEdBQUcsS0FBSyxDQUFDLGVBQWUsQ0FBQztRQUM3QyxJQUFJLENBQUMsTUFBTSxHQUFHLElBQUksQ0FBQyxlQUFlLEVBQUUsQ0FBQztRQUNyQyxJQUFJLENBQUMsYUFBYSxHQUFHLEtBQUssQ0FBQyxhQUFhO2FBQ3JDLG9CQUFvQixFQUFFO2FBQ3RCLGdCQUFnQixFQUFFLENBQUM7UUFDdEIsSUFBSSxDQUFDLGNBQWMsR0FBRyxJQUFJLENBQUMsR0FBRyxFQUFFLENBQUM7SUFDbkMsQ0FBQztJQUVELFNBQVM7UUFDUCxJQUFJLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FDZix5REFBeUQsSUFBSSxDQUFDLGFBQWEsS0FBSyxDQUNqRixDQUFDO1FBQ0YsSUFBSSxJQUFJLENBQUMsR0FBRyxFQUFFLEdBQUcsSUFBSSxDQUFDLGNBQWMsR0FBRyxJQUFJLENBQUMsYUFBYSxFQUFFO1lBQ3pELElBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUNkLHNDQUFzQyxJQUFJLENBQUMsYUFBYSxvQkFBb0IsQ0FDN0UsQ0FBQztZQUNGLElBQUksQ0FBQyxNQUFNLENBQUMsS0FBSyxFQUFFLENBQUM7WUFDcEIsSUFBSSxDQUFDLE1BQU0sR0FBRyxJQUFJLENBQUMsZUFBZSxFQUFFLENBQUM7U0FDdEM7UUFDRCxJQUFJLENBQUMsY0FBYyxHQUFHLElBQUksQ0FBQyxHQUFHLEVBQUUsQ0FBQztRQUNqQyxPQUFPLElBQUksQ0FBQyxNQUFNLENBQUM7SUFDckIsQ0FBQztDQUNGO0FBbkNELHNEQW1DQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7Q2xvc2VhYmxlR3JwY0NsaWVudCwgR3JwY0NsaWVudFdyYXBwZXJ9IGZyb20gJy4vZ3JwYy1jbGllbnQtd3JhcHBlcic7XG5pbXBvcnQge0NvbmZpZ3VyYXRpb259IGZyb20gJy4uLy4uL2NvbmZpZy9jb25maWd1cmF0aW9uJztcbmltcG9ydCB7TW9tZW50b0xvZ2dlcn0gZnJvbSAnLi4vLi4vJztcblxuZXhwb3J0IGludGVyZmFjZSBJZGxlR3JwY0NsaWVudFdyYXBwZXJQcm9wczxUIGV4dGVuZHMgQ2xvc2VhYmxlR3JwY0NsaWVudD4ge1xuICBjbGllbnRGYWN0b3J5Rm46ICgpID0+IFQ7XG4gIGNvbmZpZ3VyYXRpb246IENvbmZpZ3VyYXRpb247XG59XG5cbi8qKlxuICogVGhpcyB3cmFwcGVyIGFsbG93cyB1cyB0byBlbnN1cmUgdGhhdCBhIGdycGMgY2xpZW50IGlzIG5vdCByZS11c2VkIGlmIGl0IGhhcyBiZWVuIGlkbGVcbiAqIGZvciBsb25nZXIgdGhhbiBhIHNwZWNpZmllZCBwZXJpb2Qgb2YgdGltZS4gIFRoaXMgaXMgaW1wb3J0YW50IGluIHNvbWUgZW52aXJvbm1lbnRzLFxuICogc3VjaCBhcyBBV1MgTGFtYmRhLCB3aGVyZSB0aGUgcnVudGltZSBtYXkgYmUgcGF1c2VkIGluZGVmaW5pdGVseSBiZXR3ZWVuIGludm9jYXRpb25zLlxuICogSW4gc3VjaCBjYXNlcyB3ZSBoYXZlIG9ic2VydmVkIHRoYXQgd2hpbGUgdGhlIHJ1bnRpbWUgaXMgc3VzcGVuZGVkLCB0aGUgY29ubmVjdGlvblxuICogbWF5IGhhdmUgYmVlbiBjbG9zZWQgYnkgdGhlIHNlcnZlci4gKGUuZy4sIEFXUyBOTEIgaGFzIGFuIGlkbGUgdGltZW91dCBvZiAzNTBzOlxuICogaHR0cHM6Ly9kb2NzLmF3cy5hbWF6b24uY29tL2VsYXN0aWNsb2FkYmFsYW5jaW5nL2xhdGVzdC9uZXR3b3JrL25ldHdvcmstbG9hZC1iYWxhbmNlcnMuaHRtbCNjb25uZWN0aW9uLWlkbGUtdGltZW91dCApXG4gKiBXaGVuIHRoZSBydW50aW1lIHJlc3VtZXMsIGl0IGRvZXMgbm90IHJlY29nbml6ZSB0aGF0IHRoZSBjb25uZWN0aW9uIGhhcyBiZWVuIGNsb3NlZCxcbiAqIGFuZCBpdCBtYXkgY29udGludWUgdG8gYXR0ZW1wdCB0byBzZW5kIGJ5dGVzIHRvIGl0LCByZXN1bHRpbmcgaW4gY2xpZW50LXNpZGUgdGltZW91dHNcbiAqIChERUFETElORV9FWENFRURFRCkuICBGb3JjZWZ1bGx5IHJlZnJlc2hpbmcgdGhlIGNsaWVudCBpZiBpdCBoYXMgYmVlbiBpZGxlIGZvciB0b29cbiAqIGxvbmcgd2lsbCBwcmV2ZW50IHRoaXMuXG4gKlxuICogTk9URTogV2UgY2FuJ3QgcmVseSBvbiBrZWVwYWxpdmUgcGluZ3MgaW4gdGhpcyBzY2VuYXJpbywgYmVjYXVzZSB0aGUgbGFtYmRhIHJ1bnRpbWVcbiAqIG1heSBiZSBzdXNwZW5kZWQgaW4gc3VjaCBhIHdheSB0aGF0IGJhY2tncm91bmQgdGFza3Mgc3VjaCBhcyB0aGUga2VlcGFsaXZlIHBpbmdzXG4gKiB3aWxsIG5vdCBiZSBhYmxlIHRvIGV4ZWN1dGUuXG4gKi9cbmV4cG9ydCBjbGFzcyBJZGxlR3JwY0NsaWVudFdyYXBwZXI8VCBleHRlbmRzIENsb3NlYWJsZUdycGNDbGllbnQ+XG4gIGltcGxlbWVudHMgR3JwY0NsaWVudFdyYXBwZXI8VD5cbntcbiAgcHJpdmF0ZSByZWFkb25seSBsb2dnZXI6IE1vbWVudG9Mb2dnZXI7XG5cbiAgcHJpdmF0ZSBjbGllbnQ6IFQ7XG4gIHByaXZhdGUgcmVhZG9ubHkgY2xpZW50RmFjdG9yeUZuOiAoKSA9PiBUO1xuXG4gIHByaXZhdGUgcmVhZG9ubHkgbWF4SWRsZU1pbGxpczogbnVtYmVyO1xuICBwcml2YXRlIGxhc3RBY2Nlc3NUaW1lOiBudW1iZXI7XG5cbiAgY29uc3RydWN0b3IocHJvcHM6IElkbGVHcnBjQ2xpZW50V3JhcHBlclByb3BzPFQ+KSB7XG4gICAgdGhpcy5sb2dnZXIgPSBwcm9wcy5jb25maWd1cmF0aW9uLmdldExvZ2dlckZhY3RvcnkoKS5nZXRMb2dnZXIodGhpcyk7XG4gICAgdGhpcy5jbGllbnRGYWN0b3J5Rm4gPSBwcm9wcy5jbGllbnRGYWN0b3J5Rm47XG4gICAgdGhpcy5jbGllbnQgPSB0aGlzLmNsaWVudEZhY3RvcnlGbigpO1xuICAgIHRoaXMubWF4SWRsZU1pbGxpcyA9IHByb3BzLmNvbmZpZ3VyYXRpb25cbiAgICAgIC5nZXRUcmFuc3BvcnRTdHJhdGVneSgpXG4gICAgICAuZ2V0TWF4SWRsZU1pbGxpcygpO1xuICAgIHRoaXMubGFzdEFjY2Vzc1RpbWUgPSBEYXRlLm5vdygpO1xuICB9XG5cbiAgZ2V0Q2xpZW50KCk6IFQge1xuICAgIHRoaXMubG9nZ2VyLnRyYWNlKFxuICAgICAgYENoZWNraW5nIHRvIHNlZSBpZiBjbGllbnQgaGFzIGJlZW4gaWRsZSBmb3IgbW9yZSB0aGFuICR7dGhpcy5tYXhJZGxlTWlsbGlzfSBtc2BcbiAgICApO1xuICAgIGlmIChEYXRlLm5vdygpIC0gdGhpcy5sYXN0QWNjZXNzVGltZSA+IHRoaXMubWF4SWRsZU1pbGxpcykge1xuICAgICAgdGhpcy5sb2dnZXIuaW5mbyhcbiAgICAgICAgYENsaWVudCBoYXMgYmVlbiBpZGxlIGZvciBtb3JlIHRoYW4gJHt0aGlzLm1heElkbGVNaWxsaXN9IG1zOyByZWNvbm5lY3RpbmcuYFxuICAgICAgKTtcbiAgICAgIHRoaXMuY2xpZW50LmNsb3NlKCk7XG4gICAgICB0aGlzLmNsaWVudCA9IHRoaXMuY2xpZW50RmFjdG9yeUZuKCk7XG4gICAgfVxuICAgIHRoaXMubGFzdEFjY2Vzc1RpbWUgPSBEYXRlLm5vdygpO1xuICAgIHJldHVybiB0aGlzLmNsaWVudDtcbiAgfVxufVxuIl19