import { GrpcConfiguration, GrpcConfigurationProps } from './grpc-configuration';
export interface TransportStrategy {
    /**
     * Configures the low-level gRPC settings for the Momento client's communication
     * with the Momento server.
     * @returns {GrpcConfiguration}
     */
    getGrpcConfig(): GrpcConfiguration;
    /**
     * Copy constructor for overriding the gRPC configuration
     * @param {GrpcConfiguration} grpcConfig
     * @returns {TransportStrategy} a new TransportStrategy with the specified gRPC config.
     */
    withGrpcConfig(grpcConfig: GrpcConfiguration): TransportStrategy;
    /**
     * Copy constructor to update the client-side timeout
     * @param {number} clientTimeoutMillis
     * @returns {TransportStrategy} a new TransportStrategy with the specified client timeout
     */
    withClientTimeoutMillis(clientTimeoutMillis: number): TransportStrategy;
    /**
     * The maximum duration for which a connection may remain idle before being replaced.  This
     * setting can be used to force re-connection of a client if it has been idle for too long.
     * In environments such as AWS lambda, if the lambda is suspended for too long the connection
     * may be closed by the load balancer, resulting in an error on the subsequent request.  If
     * this setting is set to a duration less than the load balancer timeout, we can ensure that
     * the connection will be refreshed to avoid errors.
     * @returns {number}
     */
    getMaxIdleMillis(): number;
    /**
     * Copy constructor to update the max idle connection timeout.  (See {getMaxIdleMillis}.)
     * @param {number} maxIdleMillis
     * @returns {TransportStrategy} a new TransportStrategy with the specified max idle connection timeout.
     */
    withMaxIdleMillis(maxIdleMillis: number): TransportStrategy;
}
export interface TransportStrategyProps {
    /**
     * low-level gRPC settings for communication with the Momento server
     */
    grpcConfiguration: GrpcConfiguration;
    /**
     * The maximum duration for which a connection may remain idle before being replaced.  This
     * setting can be used to force re-connection of a client if it has been idle for too long.
     * In environments such as AWS lambda, if the lambda is suspended for too long the connection
     * may be closed by the load balancer, resulting in an error on the subsequent request.  If
     * this setting is set to a duration less than the load balancer timeout, we can ensure that
     * the connection will be refreshed to avoid errors.
     * @returns {number}
     */
    maxIdleMillis: number;
}
export declare class StaticGrpcConfiguration implements GrpcConfiguration {
    private readonly deadlineMillis;
    private readonly maxSessionMemoryMb;
    constructor(props: GrpcConfigurationProps);
    getDeadlineMillis(): number;
    getMaxSessionMemoryMb(): number;
    withDeadlineMillis(deadlineMillis: number): StaticGrpcConfiguration;
    withMaxSessionMemoryMb(maxSessionMemoryMb: number): StaticGrpcConfiguration;
}
export declare class StaticTransportStrategy implements TransportStrategy {
    private readonly grpcConfig;
    private readonly maxIdleMillis;
    constructor(props: TransportStrategyProps);
    getGrpcConfig(): GrpcConfiguration;
    withGrpcConfig(grpcConfig: GrpcConfiguration): StaticTransportStrategy;
    getMaxIdleMillis(): number;
    withMaxIdleMillis(maxIdleMillis: number): TransportStrategy;
    withClientTimeoutMillis(clientTimeout: number): StaticTransportStrategy;
}
