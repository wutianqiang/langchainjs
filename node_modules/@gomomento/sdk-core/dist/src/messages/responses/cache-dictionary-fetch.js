"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Error = exports.Miss = exports.Hit = exports.Response = void 0;
const response_base_1 = require("./response-base");
const TEXT_DECODER = new TextDecoder();
/**
 * Parent response type for a dictionary fetch request.  The
 * response object is resolved to a type-safe object of one of
 * the following subtypes:
 *
 * - {Hit}
 * - {Miss}
 * - {Error}
 *
 * `instanceof` type guards can be used to operate on the appropriate subtype.
 * @example
 * For example:
 * ```
 * if (response instanceof CacheDictionaryFetch.Error) {
 *   // Handle error as appropriate.  The compiler will smart-cast `response` to type
 *   // `CacheDictionaryFetch.Error` in this block, so you will have access to the properties
 *   // of the Error class; e.g. `response.errorCode()`.
 * }
 * ```
 */
class Response extends response_base_1.ResponseBase {
}
exports.Response = Response;
class _Hit extends Response {
    constructor(items) {
        super();
        this._displayListSizeLimit = 5;
        this.items = items;
    }
    /**
     * Returns the data as a Map whose keys and values are utf-8 strings, decoded from the underlying byte arrays.
     * This is a convenience alias for {valueMapStringString}.
     * @returns {Map<string, string>}
     */
    valueMap() {
        return this.valueMapStringString();
    }
    /**
     * Returns the data as a Map whose keys and values are byte arrays.
     * @returns {Map<Uint8Array, Uint8Array>}
     */
    valueMapUint8ArrayUint8Array() {
        return this.items.reduce((acc, item) => {
            acc.set(item.field, item.value);
            return acc;
        }, new Map());
    }
    /**
     * Returns the data as a Map whose keys and values are utf-8 strings, decoded from the underlying byte arrays.
     * @returns {Map<string, string>}
     */
    valueMapStringString() {
        return this.items.reduce((acc, item) => {
            acc.set(TEXT_DECODER.decode(item.field), TEXT_DECODER.decode(item.value));
            return acc;
        }, new Map());
    }
    /**
     * Returns the data as a Map whose keys are utf-8 strings, decoded from the underlying byte array, and whose values
     * are byte arrays.
     * @returns {Map<string, Uint8Array>}
     */
    valueMapStringUint8Array() {
        return this.items.reduce((acc, item) => {
            acc.set(TEXT_DECODER.decode(item.field), item.value);
            return acc;
        }, new Map());
    }
    /**
     * Returns the data as a Record whose keys and values are utf-8 strings, decoded from the underlying byte arrays.
     * This can be used in most places where an Object is desired.  This is a convenience alias for
     * {valueRecordStringString}.
     * @returns {Record<string, string>}
     */
    valueRecord() {
        return this.valueRecordStringString();
    }
    /**
     * Returns the data as a Record whose keys and values are utf-8 strings, decoded from the underlying byte arrays.
     * This can be used in most places where an Object is desired.
     * @returns {Record<string, string>}
     */
    valueRecordStringString() {
        return this.items.reduce((acc, item) => {
            acc[TEXT_DECODER.decode(item.field)] = TEXT_DECODER.decode(item.value);
            return acc;
        }, {});
    }
    /**
     * Returns the data as a Record whose keys are utf-8 strings, decoded from the underlying byte array, and whose
     * values are byte arrays.  This can be used in most places where an Object is desired.
     * @returns {Record<string, Uint8Array>}
     */
    valueRecordStringUint8Array() {
        return this.items.reduce((acc, item) => {
            acc[TEXT_DECODER.decode(item.field)] = item.value;
            return acc;
        }, {});
    }
    truncateValueStrings() {
        const keyValueIterable = this.valueMapStringString().entries();
        const keyValueArray = Array.from(keyValueIterable);
        if (keyValueArray.length <= this._displayListSizeLimit) {
            const pairs = [];
            keyValueArray.forEach(pair => {
                pairs.push(`${pair[0]}: ${pair[1]}`);
            });
            return pairs.join(',');
        }
        else {
            const slicedArray = keyValueArray.slice(0, this._displayListSizeLimit);
            const pairs = [];
            slicedArray.forEach(pair => {
                pairs.push(`${pair[0]}: ${pair[1]}`);
            });
            return pairs.join(',');
        }
    }
    toString() {
        return `${super.toString()}: valueDictionaryStringString: ${this.truncateValueStrings()}`;
    }
}
/**
 * Indicates that the requested data was successfully retrieved from the cache.  Provides
 * `value*` accessors to retrieve the data in the appropriate format.
 */
class Hit extends (0, response_base_1.ResponseHit)(_Hit) {
}
exports.Hit = Hit;
class _Miss extends Response {
}
/**
 * Indicates that the requested data was not available in the cache.
 */
class Miss extends (0, response_base_1.ResponseMiss)(_Miss) {
}
exports.Miss = Miss;
class _Error extends Response {
    constructor(_innerException) {
        super();
        this._innerException = _innerException;
    }
}
/**
 * Indicates that an error occurred during the dictionary fetch request.
 *
 * This response object includes the following fields that you can use to determine
 * how you would like to handle the error:
 *
 * - `errorCode()` - a unique Momento error code indicating the type of error that occurred.
 * - `message()` - a human-readable description of the error
 * - `innerException()` - the original error that caused the failure; can be re-thrown.
 */
class Error extends (0, response_base_1.ResponseError)(_Error) {
}
exports.Error = Error;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2FjaGUtZGljdGlvbmFyeS1mZXRjaC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9tZXNzYWdlcy9yZXNwb25zZXMvY2FjaGUtZGljdGlvbmFyeS1mZXRjaC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFBQSxtREFLeUI7QUFJekIsTUFBTSxZQUFZLEdBQUcsSUFBSSxXQUFXLEVBQUUsQ0FBQztBQUV2Qzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQW1CRztBQUNILE1BQXNCLFFBQVMsU0FBUSw0QkFBWTtDQUFHO0FBQXRELDRCQUFzRDtBQUV0RCxNQUFNLElBQUssU0FBUSxRQUFRO0lBSXpCLFlBQVksS0FBa0M7UUFDNUMsS0FBSyxFQUFFLENBQUM7UUFITywwQkFBcUIsR0FBRyxDQUFDLENBQUM7UUFJekMsSUFBSSxDQUFDLEtBQUssR0FBRyxLQUFLLENBQUM7SUFDckIsQ0FBQztJQUVEOzs7O09BSUc7SUFDSSxRQUFRO1FBQ2IsT0FBTyxJQUFJLENBQUMsb0JBQW9CLEVBQUUsQ0FBQztJQUNyQyxDQUFDO0lBRUQ7OztPQUdHO0lBQ0ksNEJBQTRCO1FBQ2pDLE9BQU8sSUFBSSxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsQ0FBQyxHQUFHLEVBQUUsSUFBSSxFQUFFLEVBQUU7WUFDckMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsS0FBSyxFQUFFLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztZQUNoQyxPQUFPLEdBQUcsQ0FBQztRQUNiLENBQUMsRUFBRSxJQUFJLEdBQUcsRUFBMEIsQ0FBQyxDQUFDO0lBQ3hDLENBQUM7SUFFRDs7O09BR0c7SUFDSSxvQkFBb0I7UUFDekIsT0FBTyxJQUFJLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxDQUFDLEdBQUcsRUFBRSxJQUFJLEVBQUUsRUFBRTtZQUNyQyxHQUFHLENBQUMsR0FBRyxDQUFDLFlBQVksQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FB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b0IsRUFBRSxFQUFFLENBQUM7SUFDNUYsQ0FBQztDQUNGO0FBRUQ7OztHQUdHO0FBQ0gsTUFBYSxHQUFJLFNBQVEsSUFBQSwyQkFBVyxFQUFDLElBQUksQ0FBQztDQUFHO0FBQTdDLGtCQUE2QztBQUU3QyxNQUFNLEtBQU0sU0FBUSxRQUFRO0NBQUc7QUFFL0I7O0dBRUc7QUFDSCxNQUFhLElBQUssU0FBUSxJQUFBLDRCQUFZLEVBQUMsS0FBSyxDQUFDO0NBQUc7QUFBaEQsb0JBQWdEO0FBRWhELE1BQU0sTUFBTyxTQUFRLFFBQVE7SUFDM0IsWUFBc0IsZUFBeUI7UUFDN0MsS0FBSyxFQUFFLENBQUM7UUFEWSxvQkFBZSxHQUFmLGVBQWUsQ0FBVTtJQUUvQyxDQUFDO0NBQ0Y7QUFFRDs7Ozs7Ozs7O0dBU0c7QUFDSCxNQUFhLEtBQU0sU0FBUSxJQUFBLDZCQUFhLEVBQUMsTUFBTSxDQUFDO0NBQUc7QUFBbkQsc0JBQW1EIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgUmVzcG9uc2VCYXNlLFxuICBSZXNwb25zZUhpdCxcbiAgUmVzcG9uc2VNaXNzLFxuICBSZXNwb25zZUVycm9yLFxufSBmcm9tICcuL3Jlc3BvbnNlLWJhc2UnO1xuaW1wb3J0IHtTZGtFcnJvcn0gZnJvbSAnLi4vLi4vZXJyb3JzJztcbmltcG9ydCB7X0RpY3Rpb25hcnlGaWVsZFZhbHVlUGFpcn0gZnJvbSAnLi9ncnBjLXJlc3BvbnNlLXR5cGVzJztcblxuY29uc3QgVEVYVF9ERUNPREVSID0gbmV3IFRleHREZWNvZGVyKCk7XG5cbi8qKlxuICogUGFyZW50IHJlc3BvbnNlIHR5cGUgZm9yIGEgZGljdGlvbmFyeSBmZXRjaCByZXF1ZXN0LiAgVGhlXG4gKiByZXNwb25zZSBvYmplY3QgaXMgcmVzb2x2ZWQgdG8gYSB0eXBlLXNhZmUgb2JqZWN0IG9mIG9uZSBvZlxuICogdGhlIGZvbGxvd2luZyBzdWJ0eXBlczpcbiAqXG4gKiAtIHtIaXR9XG4gKiAtIHtNaXNzfVxuICogLSB7RXJyb3J9XG4gKlxuICogYGluc3RhbmNlb2ZgIHR5cGUgZ3VhcmRzIGNhbiBiZSB1c2VkIHRvIG9wZXJhdGUgb24gdGhlIGFwcHJvcHJpYXRlIHN1YnR5cGUuXG4gKiBAZXhhbXBsZVxuICogRm9yIGV4YW1wbGU6XG4gKiBgYGBcbiAqIGlmIChyZXNwb25zZSBpbnN0YW5jZW9mIENhY2hlRGljdGlvbmFyeUZldGNoLkVycm9yKSB7XG4gKiAgIC8vIEhhbmRsZSBlcnJvciBhcyBhcHByb3ByaWF0ZS4gIFRoZSBjb21waWxlciB3aWxsIHNtYXJ0LWNhc3QgYHJlc3BvbnNlYCB0byB0eXBlXG4gKiAgIC8vIGBDYWNoZURpY3Rpb25hcnlGZXRjaC5FcnJvcmAgaW4gdGhpcyBibG9jaywgc28geW91IHdpbGwgaGF2ZSBhY2Nlc3MgdG8gdGhlIHByb3BlcnRpZXNcbiAqICAgLy8gb2YgdGhlIEVycm9yIGNsYXNzOyBlLmcuIGByZXNwb25zZS5lcnJvckNvZGUoKWAuXG4gKiB9XG4gKiBgYGBcbiAqL1xuZXhwb3J0IGFic3RyYWN0IGNsYXNzIFJlc3BvbnNlIGV4dGVuZHMgUmVzcG9uc2VCYXNlIHt9XG5cbmNsYXNzIF9IaXQgZXh0ZW5kcyBSZXNwb25zZSB7XG4gIHByaXZhdGUgcmVhZG9ubHkgaXRlbXM6IF9EaWN0aW9uYXJ5RmllbGRWYWx1ZVBhaXJbXTtcbiAgcHJpdmF0ZSByZWFkb25seSBfZGlzcGxheUxpc3RTaXplTGltaXQgPSA1O1xuXG4gIGNvbnN0cnVjdG9yKGl0ZW1zOiBfRGljdGlvbmFyeUZpZWxkVmFsdWVQYWlyW10pIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuaXRlbXMgPSBpdGVtcztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBkYXRhIGFzIGEgTWFwIHdob3NlIGtleXMgYW5kIHZhbHVlcyBhcmUgdXRmLTggc3RyaW5ncywgZGVjb2RlZCBmcm9tIHRoZSB1bmRlcmx5aW5nIGJ5dGUgYXJyYXlzLlxuICAgKiBUaGlzIGlzIGEgY29udmVuaWVuY2UgYWxpYXMgZm9yIHt2YWx1ZU1hcFN0cmluZ1N0cmluZ30uXG4gICAqIEByZXR1cm5zIHtNYXA8c3RyaW5nLCBzdHJpbmc+fVxuICAgKi9cbiAgcHVibGljIHZhbHVlTWFwKCk6IE1hcDxzdHJpbmcsIHN0cmluZz4ge1xuICAgIHJldHVybiB0aGlzLnZhbHVlTWFwU3RyaW5nU3RyaW5nKCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZGF0YSBhcyBhIE1hcCB3aG9zZSBrZXlzIGFuZCB2YWx1ZXMgYXJlIGJ5dGUgYXJyYXlzLlxuICAgKiBAcmV0dXJucyB7TWFwPFVpbnQ4QXJyYXksIFVpbnQ4QXJyYXk+fVxuICAgKi9cbiAgcHVibGljIHZhbHVlTWFwVWludDhBcnJheVVpbnQ4QXJyYXkoKTogTWFwPFVpbnQ4QXJyYXksIFVpbnQ4QXJyYXk+IHtcbiAgICByZXR1cm4gdGhpcy5pdGVtcy5yZWR1Y2UoKGFjYywgaXRlbSkgPT4ge1xuICAgICAgYWNjLnNldChpdGVtLmZpZWxkLCBpdGVtLnZhbHVlKTtcbiAgICAgIHJldHVybiBhY2M7XG4gICAgfSwgbmV3IE1hcDxVaW50OEFycmF5LCBVaW50OEFycmF5PigpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBkYXRhIGFzIGEgTWFwIHdob3NlIGtleXMgYW5kIHZhbHVlcyBhcmUgdXRmLTggc3RyaW5ncywgZGVjb2RlZCBmcm9tIHRoZSB1bmRlcmx5aW5nIGJ5dGUgYXJyYXlzLlxuICAgKiBAcmV0dXJucyB7TWFwPHN0cmluZywgc3RyaW5nPn1cbiAgICovXG4gIHB1YmxpYyB2YWx1ZU1hcFN0cmluZ1N0cmluZygpOiBNYXA8c3RyaW5nLCBzdHJpbmc+IHtcbiAgICByZXR1cm4gdGhpcy5pdGVtcy5yZWR1Y2UoKGFjYywgaXRlbSkgPT4ge1xuICAgICAgYWNjLnNldChURVhUX0RFQ09ERVIuZGVjb2RlKGl0ZW0uZmllbGQpLCBURVhUX0RFQ09ERVIuZGVjb2RlKGl0ZW0udmFsdWUpKTtcbiAgICAgIHJldHVybiBhY2M7XG4gICAgfSwgbmV3IE1hcDxzdHJpbmcsIHN0cmluZz4oKSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZGF0YSBhcyBhIE1hcCB3aG9zZSBrZXlzIGFyZSB1dGYtOCBzdHJpbmdzLCBkZWNvZGVkIGZyb20gdGhlIHVuZGVybHlpbmcgYnl0ZSBhcnJheSwgYW5kIHdob3NlIHZhbHVlc1xuICAgKiBhcmUgYnl0ZSBhcnJheXMuXG4gICAqIEByZXR1cm5zIHtNYXA8c3RyaW5nLCBVaW50OEFycmF5Pn1cbiAgICovXG4gIHB1YmxpYyB2YWx1ZU1hcFN0cmluZ1VpbnQ4QXJyYXkoKTogTWFwPHN0cmluZywgVWludDhBcnJheT4ge1xuICAgIHJldHVybiB0aGlzLml0ZW1zLnJlZHVjZSgoYWNjLCBpdGVtKSA9PiB7XG4gICAgICBhY2Muc2V0KFRFWFRfREVDT0RFUi5kZWNvZGUoaXRlbS5maWVsZCksIGl0ZW0udmFsdWUpO1xuICAgICAgcmV0dXJuIGFjYztcbiAgICB9LCBuZXcgTWFwPHN0cmluZywgVWludDhBcnJheT4oKSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZGF0YSBhcyBhIFJlY29yZCB3aG9zZSBrZXlzIGFuZCB2YWx1ZXMgYXJlIHV0Zi04IHN0cmluZ3MsIGRlY29kZWQgZnJvbSB0aGUgdW5kZXJseWluZyBieXRlIGFycmF5cy5cbiAgICogVGhpcyBjYW4gYmUgdXNlZCBpbiBtb3N0IHBsYWNlcyB3aGVyZSBhbiBPYmplY3QgaXMgZGVzaXJlZC4gIFRoaXMgaXMgYSBjb252ZW5pZW5jZSBhbGlhcyBmb3JcbiAgICoge3ZhbHVlUmVjb3JkU3RyaW5nU3RyaW5nfS5cbiAgICogQHJldHVybnMge1JlY29yZDxzdHJpbmcsIHN0cmluZz59XG4gICAqL1xuICBwdWJsaWMgdmFsdWVSZWNvcmQoKTogUmVjb3JkPHN0cmluZywgc3RyaW5nPiB7XG4gICAgcmV0dXJuIHRoaXMudmFsdWVSZWNvcmRTdHJpbmdTdHJpbmcoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBkYXRhIGFzIGEgUmVjb3JkIHdob3NlIGtleXMgYW5kIHZhbHVlcyBhcmUgdXRmLTggc3RyaW5ncywgZGVjb2RlZCBmcm9tIHRoZSB1bmRlcmx5aW5nIGJ5dGUgYXJyYXlzLlxuICAgKiBUaGlzIGNhbiBiZSB1c2VkIGluIG1vc3QgcGxhY2VzIHdoZXJlIGFuIE9iamVjdCBpcyBkZXNpcmVkLlxuICAgKiBAcmV0dXJucyB7UmVjb3JkPHN0cmluZywgc3RyaW5nPn1cbiAgICovXG4gIHB1YmxpYyB2YWx1ZVJlY29yZFN0cmluZ1N0cmluZygpOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+IHtcbiAgICByZXR1cm4gdGhpcy5pdGVtcy5yZWR1Y2U8UmVjb3JkPHN0cmluZywgc3RyaW5nPj4oKGFjYywgaXRlbSkgPT4ge1xuICAgICAgYWNjW1RFWFRfREVDT0RFUi5kZWNvZGUoaXRlbS5maWVsZCldID0gVEVYVF9ERUNPREVSLmRlY29kZShpdGVtLnZhbHVlKTtcbiAgICAgIHJldHVybiBhY2M7XG4gICAgfSwge30pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGRhdGEgYXMgYSBSZWNvcmQgd2hvc2Uga2V5cyBhcmUgdXRmLTggc3RyaW5ncywgZGVjb2RlZCBmcm9tIHRoZSB1bmRlcmx5aW5nIGJ5dGUgYXJyYXksIGFuZCB3aG9zZVxuICAgKiB2YWx1ZXMgYXJlIGJ5dGUgYXJyYXlzLiAgVGhpcyBjYW4gYmUgdXNlZCBpbiBtb3N0IHBsYWNlcyB3aGVyZSBhbiBPYmplY3QgaXMgZGVzaXJlZC5cbiAgICogQHJldHVybnMge1JlY29yZDxzdHJpbmcsIFVpbnQ4QXJyYXk+fVxuICAgKi9cbiAgcHVibGljIHZhbHVlUmVjb3JkU3RyaW5nVWludDhBcnJheSgpOiBSZWNvcmQ8c3RyaW5nLCBVaW50OEFycmF5PiB7XG4gICAgcmV0dXJuIHRoaXMuaXRlbXMucmVkdWNlPFJlY29yZDxzdHJpbmcsIFVpbnQ4QXJyYXk+PigoYWNjLCBpdGVtKSA9PiB7XG4gICAgICBhY2NbVEVYVF9ERUNPREVSLmRlY29kZShpdGVtLmZpZWxkKV0gPSBpdGVtLnZhbHVlO1xuICAgICAgcmV0dXJuIGFjYztcbiAgICB9LCB7fSk7XG4gIH1cblxuICBwcml2YXRlIHRydW5jYXRlVmFsdWVTdHJpbmdzKCk6IHN0cmluZyB7XG4gICAgY29uc3Qga2V5VmFsdWVJdGVyYWJsZSA9IHRoaXMudmFsdWVNYXBTdHJpbmdTdHJpbmcoKS5lbnRyaWVzKCk7XG4gICAgY29uc3Qga2V5VmFsdWVBcnJheSA9IEFycmF5LmZyb20oa2V5VmFsdWVJdGVyYWJsZSk7XG4gICAgaWYgKGtleVZhbHVlQXJyYXkubGVuZ3RoIDw9IHRoaXMuX2Rpc3BsYXlMaXN0U2l6ZUxpbWl0KSB7XG4gICAgICBjb25zdCBwYWlyczogc3RyaW5nW10gPSBbXTtcbiAgICAgIGtleVZhbHVlQXJyYXkuZm9yRWFjaChwYWlyID0+IHtcbiAgICAgICAgcGFpcnMucHVzaChgJHtwYWlyWzBdfTogJHtwYWlyWzFdfWApO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gcGFpcnMuam9pbignLCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBzbGljZWRBcnJheSA9IGtleVZhbHVlQXJyYXkuc2xpY2UoMCwgdGhpcy5fZGlzcGxheUxpc3RTaXplTGltaXQpO1xuICAgICAgY29uc3QgcGFpcnM6IHN0cmluZ1tdID0gW107XG4gICAgICBzbGljZWRBcnJheS5mb3JFYWNoKHBhaXIgPT4ge1xuICAgICAgICBwYWlycy5wdXNoKGAke3BhaXJbMF19OiAke3BhaXJbMV19YCk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBwYWlycy5qb2luKCcsJyk7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIG92ZXJyaWRlIHRvU3RyaW5nKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIGAke3N1cGVyLnRvU3RyaW5nKCl9OiB2YWx1ZURpY3Rpb25hcnlTdHJpbmdTdHJpbmc6ICR7dGhpcy50cnVuY2F0ZVZhbHVlU3RyaW5ncygpfWA7XG4gIH1cbn1cblxuLyoqXG4gKiBJbmRpY2F0ZXMgdGhhdCB0aGUgcmVxdWVzdGVkIGRhdGEgd2FzIHN1Y2Nlc3NmdWxseSByZXRyaWV2ZWQgZnJvbSB0aGUgY2FjaGUuICBQcm92aWRlc1xuICogYHZhbHVlKmAgYWNjZXNzb3JzIHRvIHJldHJpZXZlIHRoZSBkYXRhIGluIHRoZSBhcHByb3ByaWF0ZSBmb3JtYXQuXG4gKi9cbmV4cG9ydCBjbGFzcyBIaXQgZXh0ZW5kcyBSZXNwb25zZUhpdChfSGl0KSB7fVxuXG5jbGFzcyBfTWlzcyBleHRlbmRzIFJlc3BvbnNlIHt9XG5cbi8qKlxuICogSW5kaWNhdGVzIHRoYXQgdGhlIHJlcXVlc3RlZCBkYXRhIHdhcyBub3QgYXZhaWxhYmxlIGluIHRoZSBjYWNoZS5cbiAqL1xuZXhwb3J0IGNsYXNzIE1pc3MgZXh0ZW5kcyBSZXNwb25zZU1pc3MoX01pc3MpIHt9XG5cbmNsYXNzIF9FcnJvciBleHRlbmRzIFJlc3BvbnNlIHtcbiAgY29uc3RydWN0b3IocHJvdGVjdGVkIF9pbm5lckV4Y2VwdGlvbjogU2RrRXJyb3IpIHtcbiAgICBzdXBlcigpO1xuICB9XG59XG5cbi8qKlxuICogSW5kaWNhdGVzIHRoYXQgYW4gZXJyb3Igb2NjdXJyZWQgZHVyaW5nIHRoZSBkaWN0aW9uYXJ5IGZldGNoIHJlcXVlc3QuXG4gKlxuICogVGhpcyByZXNwb25zZSBvYmplY3QgaW5jbHVkZXMgdGhlIGZvbGxvd2luZyBmaWVsZHMgdGhhdCB5b3UgY2FuIHVzZSB0byBkZXRlcm1pbmVcbiAqIGhvdyB5b3Ugd291bGQgbGlrZSB0byBoYW5kbGUgdGhlIGVycm9yOlxuICpcbiAqIC0gYGVycm9yQ29kZSgpYCAtIGEgdW5pcXVlIE1vbWVudG8gZXJyb3IgY29kZSBpbmRpY2F0aW5nIHRoZSB0eXBlIG9mIGVycm9yIHRoYXQgb2NjdXJyZWQuXG4gKiAtIGBtZXNzYWdlKClgIC0gYSBodW1hbi1yZWFkYWJsZSBkZXNjcmlwdGlvbiBvZiB0aGUgZXJyb3JcbiAqIC0gYGlubmVyRXhjZXB0aW9uKClgIC0gdGhlIG9yaWdpbmFsIGVycm9yIHRoYXQgY2F1c2VkIHRoZSBmYWlsdXJlOyBjYW4gYmUgcmUtdGhyb3duLlxuICovXG5leHBvcnQgY2xhc3MgRXJyb3IgZXh0ZW5kcyBSZXNwb25zZUVycm9yKF9FcnJvcikge31cbiJdfQ==