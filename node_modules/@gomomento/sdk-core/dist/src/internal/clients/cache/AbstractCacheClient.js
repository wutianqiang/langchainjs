"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AbstractCacheClient = void 0;
const index_1 = require("../../../index");
class AbstractCacheClient {
    constructor(controlClient, dataClients, pingClient) {
        this.controlClient = controlClient;
        this.dataClients = dataClients;
        this.pingClient = pingClient;
        // We round-robin the requests through all of our clients.  Since javascript
        // is single-threaded, we don't have to worry about thread safety on this
        // index variable.
        this.nextDataClientIndex = 0;
    }
    /**
     * Ping the service to verify it is up and running
     */
    async ping() {
        var _a;
        return await ((_a = this.pingClient) === null || _a === void 0 ? void 0 : _a.ping());
    }
    /**
     * Creates a cache if it does not exist.
     *
     * @param {string} cacheName - The cache to be created.
     * @returns {Promise<CreateCache.Response>} -
     * {@link CreateCache.Success} on success.
     * {@link CreateCache.AlreadyExists} if the cache already exists.
     * {@link CreateCache.Error} on failure.
     */
    async createCache(cacheName) {
        return await this.controlClient.createCache(cacheName);
    }
    /**
     * Deletes a cache and all items stored in it.
     *
     * @param {string} cacheName - The cache to delete.
     * @returns {Promise<DeleteCache.Response>} -
     * {@link DeleteCache.Success} on success.
     * {@link DeleteCache.Error} on failure.
     */
    async deleteCache(cacheName) {
        return await this.controlClient.deleteCache(cacheName);
    }
    /**
     * Lists all caches.
     *
     * @returns {Promise<ListCaches.Response>} -
     * {@link ListCaches.Success} containing the list on success.
     * {@link ListCaches.Error} on failure.
     */
    async listCaches() {
        return await this.controlClient.listCaches();
    }
    /**
     * Gets the value stored for the given key.
     *
     * @param {string} cacheName - The cache to perform the lookup in.
     * @param {string | Uint8Array} key - The key to look up.
     * @returns {Promise<CacheGet.Response>} -
     * {@link CacheGet.Hit} containing the value if one is found.
     * {@link CacheGet.Miss} if the key does not exist.
     * {@link CacheGet.Error} on failure.
     */
    async get(cacheName, key) {
        return await this.getNextDataClient().get(cacheName, key);
    }
    /**
     * Associates the given key with the given value. If a value for the key is
     * already present it is replaced with the new value.
     *
     * @param {string} cacheName - The cache to store the value in.
     * @param {string | Uint8Array} key - The key to set.
     * @param {string | Uint8Array} value - The value to be stored.
     * @param {SetOptions} [options]
     * @param {number} [options.ttl] - The time to live for the item in the cache.
     * Uses the client's default TTL if this is not supplied.
     * @returns {Promise<CacheSet.Response>} -
     * {@link CacheSet.Success} on success.
     * {@link CacheSet.Error} on failure.
     */
    async set(cacheName, key, value, options) {
        const client = this.getNextDataClient();
        return await client.set(cacheName, key, value, options === null || options === void 0 ? void 0 : options.ttl);
    }
    /**
     * Removes the given key from the cache. The key can represent a single value
     * or a collection.
     *
     * @param {string} cacheName - The cache to delete from.
     * @param {string | Uint8Array} key - The key to delete.
     * @returns {Promise<CacheDelete.Response>} -
     * {@link CacheDelete.Success} on success.
     * {@link CacheDelete.Error} on failure.
     */
    async delete(cacheName, key) {
        const client = this.getNextDataClient();
        return await client.delete(cacheName, key);
    }
    /**
     * Adds multiple elements to the back of the given list. Creates the list if
     * it does not already exist.
     *
     * @param {string} cacheName - The cache to store the list in.
     * @param {string} listName - The list to add to.
     * @param {string[] | Uint8Array[]} values - The elements to add to the list.
     * @param {ListConcatenateBackOptions} [options]
     * @param {number} [options.truncateFrontToSize] - If the list exceeds this
     * length, remove excess from the front of the list. Must be positive.
     * @param {CollectionTtl} [options.ttl] - How the TTL should be managed.
     * Refreshes the list's TTL using the client's default if this is not
     * supplied.
     * @returns {Promise<CacheListConcatenateBack.Response>} -
     * {@link CacheListConcatenateBack.Success} on success.
     * {@link CacheListConcatenateBack.Error} on failure.
     */
    async listConcatenateBack(cacheName, listName, values, options) {
        const client = this.getNextDataClient();
        return await client.listConcatenateBack(cacheName, listName, values, options === null || options === void 0 ? void 0 : options.truncateFrontToSize, options === null || options === void 0 ? void 0 : options.ttl);
    }
    /**
     * Adds multiple elements to the front of the given list. Creates the list if
     * it does not already exist.
     *
     * @param {string} cacheName - The cache to store the list in.
     * @param {string} listName - The list to add to.
     * @param {string[] | Uint8Array[]} values - The elements to add to the list.
     * @param {ListConcatenateFrontOptions} [options]
     * @param {number} [options.truncateBackToSize] - If the list exceeds this
     * length, remove excess from the back of the list. Must be positive.
     * @param {CollectionTtl} [options.ttl] - How the TTL should be managed.
     * Refreshes the list's TTL using the client's default if this is not
     * supplied.
     * @returns {Promise<CacheListConcatenateFront.Response>} -
     * {@link CacheListConcatenateFront.Success} on success.
     * {@link CacheListConcatenateFront.Error} on failure.
     */
    async listConcatenateFront(cacheName, listName, values, options) {
        const client = this.getNextDataClient();
        return await client.listConcatenateFront(cacheName, listName, values, options === null || options === void 0 ? void 0 : options.truncateBackToSize, options === null || options === void 0 ? void 0 : options.ttl);
    }
    /**
     * Fetches all elements of the given list.
     *
     * @param {string} cacheName - The cache containing the list.
     * @param {string} listName - The list to fetch.
     * @param {ListFetchCallOptions} [options]
     * @param {number} [options.startIndex] - Start inclusive index for fetch operation.
     * @param {number} [options.endIndex] - End exclusive index for fetch operation.
     * @returns {Promise<CacheListFetch.Response>} -
     * {@link CacheListFetch.Hit} containing the list elements if the list exists.
     * {@link CacheListFetch.Miss} if the list does not exist.
     * {@link CacheListFetch.Error} on failure.
     */
    async listFetch(cacheName, listName, options) {
        const client = this.getNextDataClient();
        return await client.listFetch(cacheName, listName, options === null || options === void 0 ? void 0 : options.startIndex, options === null || options === void 0 ? void 0 : options.endIndex);
    }
    /**
     * Gets the number of elements in the given list.
     *
     * @param {string} cacheName - The cache containing the list.
     * @param {string} listName - The list to get the length of.
     * @returns {Promise<CacheListLength.Response>} -
     * {@link CacheListLength.Hit} containing the length if the list exists.
     * {@link CacheListLength.Miss} if the list does not exist.
     * {@link CacheListLength.Error} on failure.
     */
    async listLength(cacheName, listName) {
        const client = this.getNextDataClient();
        return await client.listLength(cacheName, listName);
    }
    /**
     * Gets and removes the last value from the given list.
     *
     * @param {string} cacheName - The cache containing the list.
     * @param {string} listName - The list to pop.
     * @returns {Promise<CacheListPopBack.Response>} -
     * {@link CacheListPopBack.Hit} containing the element if the list exists.
     * {@link CacheListPopBack.Miss} if the list does not exist.
     * {@link CacheListPopBack.Error} on failure.
     */
    async listPopBack(cacheName, listName) {
        const client = this.getNextDataClient();
        return await client.listPopBack(cacheName, listName);
    }
    /**
     * Gets and removes the first value from the given list.
     *
     * @param {string} cacheName - The cache containing the list.
     * @param {string} listName - The list to pop.
     * @returns {Promise<CacheListPopFront.Response>} -
     * {@link CacheListPopFront.Hit} containing the element if the list exists.
     * {@link CacheListPopFront.Miss} if the list does not exist.
     * {@link CacheListPopFront.Error} on failure.
     */
    async listPopFront(cacheName, listName) {
        const client = this.getNextDataClient();
        return await client.listPopFront(cacheName, listName);
    }
    /**
     * Adds an element to the back of the given list. Creates the list if
     * it does not already exist.
     *
     * @param {string} cacheName - The cache to store the list in.
     * @param {string} listName - The list to push to.
     * @param {string | Uint8Array} value - The value to push.
     * @param {ListPushBackOptions} [options]
     * @param {number} [options.truncateFrontToSize] - If the list exceeds this
     * length, remove excess from the front of the list. Must be positive.
     * @param {CollectionTtl} [options.ttl] - How the TTL should be managed.
     * Refreshes the list's TTL using the client's default if this is not
     * supplied.
     * @returns {Promise<CacheListPushBack.Response>} -
     * {@link CacheListPushBack.Success} containing the list's new length on
     * success.
     * {@link CacheListPushBack.Error} on failure.
     */
    async listPushBack(cacheName, listName, value, options) {
        const client = this.getNextDataClient();
        return await client.listPushBack(cacheName, listName, value, options === null || options === void 0 ? void 0 : options.truncateFrontToSize, options === null || options === void 0 ? void 0 : options.ttl);
    }
    /**
     * Adds an element to the front of the given list. Creates the list if
     * it does not already exist.
     *
     * @param {string} cacheName - The cache to store the list in.
     * @param {string} listName - The list to push to.
     * @param {string | Uint8Array} value - The value to push.
     * @param {ListPushFrontOptions} [options]
     * @param {number} [options.truncateBackToSize] - If the list exceeds this
     * length, remove excess from the end of the list. Must be positive.
     * @param {CollectionTtl} [options.ttl] - How the TTL should be managed.
     * Refreshes the list's TTL using the client's default if this is not
     * supplied.
     * @returns {Promise<CacheListPushFront.Response>} -
     * {@link CacheListPushFront.Success} containing the list's new length on
     * success.
     * {@link CacheListPushFront.Error} on failure.
     */
    async listPushFront(cacheName, listName, value, options) {
        const client = this.getNextDataClient();
        return await client.listPushFront(cacheName, listName, value, options === null || options === void 0 ? void 0 : options.truncateBackToSize, options === null || options === void 0 ? void 0 : options.ttl);
    }
    /**
     * Removes all elements from the given list equal to the given value.
     *
     * @param {string} cacheName - The cache containing the list.
     * @param {string} listName - The list to remove from.
     * @param {string | Uint8Array} value - The value to remove.
     * @returns {Promise<CacheListRemoveValue.Response>} -
     * {@link CacheListRemoveValue.Success} on success. Removing an element that
     * does not occur in the list or removing from a non-existent list counts as a
     * success.
     * {@link CacheListRemoveValue.Error} on failure.
     */
    async listRemoveValue(cacheName, listName, value) {
        const client = this.getNextDataClient();
        return await client.listRemoveValue(cacheName, listName, value);
    }
    /**
     * Retains slice of elements of a given list, deletes the rest of the list
     * that isn't being retained. Returns a Success or Error.
     *
     * @param {string} cacheName - The cache containing the list.
     * @param {string} listName - The list to retain a slice of.
     * @param {ListRetainCallOptions} [options]
     * @param {number} [options.startIndex] - Start inclusive index for fetch
     * operation. Defaults to start of array if not given, 0.
     * @param {number} [options.endIndex] - End exclusive index for fetch
     * operation. Defaults to end of array if not given.
     * @param {CollectionTtl} [options.ttl] - How the TTL should be managed.
     * Refreshes the list's TTL using the client's default if this is not
     * supplied.
     * @returns {Promise<CacheListRetain.Response>} -
     * {@link CacheListRetain.Success} on success.
     * {@link CacheListRetain.Error} on failure.
     */
    async listRetain(cacheName, listName, options) {
        const client = this.getNextDataClient();
        return await client.listRetain(cacheName, listName, options === null || options === void 0 ? void 0 : options.startIndex, options === null || options === void 0 ? void 0 : options.endIndex, options === null || options === void 0 ? void 0 : options.ttl);
    }
    /**
     * Fetches all elements of the given set
     *
     * @param {string} cacheName - The cache containing the set.
     * @param {string} setName - The set to fetch.
     * @returns {Promise<CacheSetFetch.Response>} -
     * {@link CacheSetFetch.Hit} containing the set elements if the set exists.
     * {@link CacheSetFetch.Miss} if the set does not exist.
     * {@link CacheSetFetch.Error} on failure.
     */
    async setFetch(cacheName, setName) {
        const client = this.getNextDataClient();
        return await client.setFetch(cacheName, setName);
    }
    /**
     * Adds an element to the given set. Creates the set if it does not already
     * exist.
     *
     * @remarks
     * After this operation the set will contain the union of the element passed
     * in and the original elements of the set.
     *
     * @param {string} cacheName - The cache to store the set in.
     * @param {string} setName - The set to add to.
     * @param {string | Uint8Array} element - The element to add.
     * @param {SetAddElementOptions} options
     * @param {CollectionTtl} [options.ttl] - How the TTL should be managed.
     * Refreshes the set's TTL using the client's default if this is not supplied.
     * @returns {Promise<CacheSetAddElement.Response>} -
     * {@link CacheSetAddElement.Success} on success.
     * {@link CacheSetAddElement.Error} on failure.
     */
    async setAddElement(cacheName, setName, element, options) {
        return (await this.setAddElements(cacheName, setName, [element], options)).toSingularResponse();
    }
    /**
     * Adds multiple elements to the given set. Creates the set if it does not
     * already exist.
     *
     * @remarks
     * After this operation, the set will contain the union of the elements passed
     * in and the original elements of the set.
     *
     * @param {string} cacheName - The cache to store the set in.
     * @param {string} setName - The set to add to.
     * @param {string[] | Uint8Array[]} elements - The elements to add.
     * @param {SetAddElementsOptions} options
     * @param {CollectionTtl} [options.ttl] - How the TTL should be managed.
     * Refreshes the set's TTL using the client's default if this is not supplied.
     * @returns {Promise<CacheSetAddElements.Response>} -
     * {@link CacheSetAddElements.Success} on success.
     * {@link CacheSetAddElements.Error} on failure.
     */
    async setAddElements(cacheName, setName, elements, options) {
        const client = this.getNextDataClient();
        return await client.setAddElements(cacheName, setName, elements, options === null || options === void 0 ? void 0 : options.ttl);
    }
    /**
     * Removes an element from the given set.
     *
     * @param {string} cacheName - The cache containing the set.
     * @param {string} setName - The set to remove from.
     * @param {string | Uint8Array} element - The element to remove.
     * @returns {Promise<CacheSetRemoveElement.Response>} -
     * {@link CacheSetRemoveElement.Success} on success. Removing an element that
     * does not occur in the set or removing from a non-existent set counts as a
     * success.
     * {@link CacheSetRemoveElement.Error} on failure.
     */
    async setRemoveElement(cacheName, setName, element) {
        return (await this.setRemoveElements(cacheName, setName, [element])).toSingularResponse();
    }
    /**
     * Removes multiple elements from the given set.
     *
     * @param {string} cacheName - The cache containing the set.
     * @param {string} setName - The set to remove from.
     * @param {string[] | Uint8Array[]} elements - The elements to remove.
     * @returns {Promise<CacheSetRemoveElements.Response>} -
     * {@link CacheSetRemoveElements.Success} on success. Removing elements that
     * do not occur in the set or removing from a non-existent set counts as a
     * success.
     * {@link CacheSetRemoveElements.Error} on failure.
     */
    async setRemoveElements(cacheName, setName, elements) {
        const client = this.getNextDataClient();
        return await client.setRemoveElements(cacheName, setName, elements);
    }
    /**
     * Associates the given key with the given value. If a value for the key is
     * already present it is not replaced with the new value.
     *
     * @param {string} cacheName - The cache to store the value in.
     * @param {string | Uint8Array} key - The key to set.
     * @param {string | Uint8Array} field - The value to be stored.
     * @param {SetIfNotExistsOptions} [options]
     * @param {number} [options.ttl] - The time to live for the item in the cache.
     * Uses the client's default TTL if this is not supplied.
     * @returns {Promise<CacheSetIfNotExists.Response>} -
     * {@link CacheSetIfNotExists.Stored} on storing the new value.
     * {@link CacheSetIfNotExists.NotStored} on not storing the new value.
     * {@link CacheSetIfNotExists.Error} on failure.
     */
    async setIfNotExists(cacheName, key, field, options) {
        const client = this.getNextDataClient();
        return await client.setIfNotExists(cacheName, key, field, options === null || options === void 0 ? void 0 : options.ttl);
    }
    /**
     * Flushes / clears all the items of the given cache
     *
     * @param {string} cacheName - The cache to be flushed.
     * @returns {Promise<CacheFlush.Response>} -
     * {@link CacheFlush.Success} on success.
     * {@link CacheFlush.Error} on failure.
     */
    async flushCache(cacheName) {
        return await this.controlClient.flushCache(cacheName);
    }
    /**
     * Fetches all elements of the given dictionary.
     *
     * @param {string} cacheName - The cache to perform the lookup in.
     * @param {string} dictionaryName - The dictionary to fetch.
     * @returns {Promise<CacheDictionaryFetch.Response>} -
     * {@link CacheDictionaryFetch.Hit} containing the dictionary elements if the
     * dictionary exists.
     * {@link CacheDictionaryFetch.Miss} if the dictionary does not exist.
     * {@link CacheDictionaryFetch.Error} on failure.
     */
    async dictionaryFetch(cacheName, dictionaryName) {
        const client = this.getNextDataClient();
        return await client.dictionaryFetch(cacheName, dictionaryName);
    }
    /**
     * Adds an integer quantity to a field value.
     *
     * @remarks
     * Incrementing the value of a missing field sets the value to amount.
     *
     * @param {string} cacheName - The cache containing the field.
     * @param {string | Uint8Array} field - The field to increment.
     * @param {number} amount - The quantity to add to the value. May be positive,
     * negative, or zero. Defaults to 1.
     * @param {IncrementOptions} options
     * @param {CollectionTtl} [options.ttl] - How the TTL should be managed.
     * @returns {Promise<CacheIncrement>} -
     * {@link CacheIncrement.Success} containing the incremented value
     * on success.
     * {@link CacheIncrement.Error} on failure. Incrementing a value
     * that was not set using this method or is not the string representation of
     * an integer results in a failure with a FailedPreconditionException error.
     */
    async increment(cacheName, field, amount = 1, options) {
        const client = this.getNextDataClient();
        return await client.increment(cacheName, field, amount, options === null || options === void 0 ? void 0 : options.ttl);
    }
    /**
     * Adds an element to the given dictionary. Creates the dictionary if it does
     * not already exist.
     *
     * @param {string} cacheName - The cache to store the dictionary in.
     * @param {string} dictionaryName - The dictionary to add to.
     * @param {string | Uint8Array} field - The field to set.
     * @param {string | Uint8Array} value - The value to store.
     * @param {DictionarySetFieldOptions} options
     * @param {CollectionTtl} [options.ttl] - How the TTL should be managed.
     * Refreshes the dictionary's TTL using the client's default if this is not
     * supplied.
     * @returns {Promise<CacheDictionarySetField.Response>} -
     * {@link CacheDictionarySetField.Success} on success.
     * {@link CacheDictionarySetField.Error} on failure.
     */
    async dictionarySetField(cacheName, dictionaryName, field, value, options) {
        const client = this.getNextDataClient();
        return await client.dictionarySetField(cacheName, dictionaryName, field, value, options === null || options === void 0 ? void 0 : options.ttl);
    }
    /**
     * Adds multiple elements to the given dictionary. Creates the dictionary if
     * it does not already exist.
     *
     * @param {string} cacheName - The cache to store the dictionary in.
     * @param {string} dictionaryName - The dictionary to add to.
     * @param {Map<string | Uint8Array, string | Uint8Array>} elements - The
     * elements to set.
     * @param {DictionarySetFieldsOptions} options
     * @param {CollectionTtl} [options.ttl] - How the TTL should be managed.
     * Refreshes the dictionary's TTL using the client's default if this is not
     * supplied.
     * @returns {Promise<CacheDictionarySetFields.Response>} -
     * {@link CacheDictionarySetFields.Success} on success.
     * {@link CacheDictionarySetFields.Error} on failure.
     */
    async dictionarySetFields(cacheName, dictionaryName, elements, options) {
        const client = this.getNextDataClient();
        return await client.dictionarySetFields(cacheName, dictionaryName, elements, options === null || options === void 0 ? void 0 : options.ttl);
    }
    /**
     * Gets the value stored for the given dictionary and field.
     *
     * @param {string} cacheName - The cache containing the dictionary.
     * @param {string} dictionaryName - The dictionary to look up.
     * @param {string | Uint8Array} field - The field to look up.
     * @returns {Promise<CacheDictionaryGetField.Response>} -
     * {@link CacheDictionaryGetField.Hit} containing the dictionary element if
     * one is found.
     * {@link CacheDictionaryGetField.Miss} if the dictionary does not exist.
     * {@link CacheDictionaryGetField.Error} on failure.
     */
    async dictionaryGetField(cacheName, dictionaryName, field) {
        const client = this.getNextDataClient();
        return await client.dictionaryGetField(cacheName, dictionaryName, field);
    }
    /**
     * Gets multiple values from the given dictionary.
     *
     * @param {string} cacheName - The cache containing the dictionary.
     * @param {string} dictionaryName - The dictionary to look up.
     * @param {string[] | Uint8Array[]} fields - The fields to look up.
     * @returns {Promise<CacheDictionaryGetFields.Response>} -
     * {@link CacheDictionaryGetFields.Hit} containing the dictionary elements if
     * the dictionary exists.
     * {@link CacheDictionaryGetFields.Miss} if the dictionary does not exist.
     * {@link CacheDictionaryGetFields.Error} on failure.
     */
    async dictionaryGetFields(cacheName, dictionaryName, fields) {
        const client = this.getNextDataClient();
        return await client.dictionaryGetFields(cacheName, dictionaryName, fields);
    }
    /**
     * Removes an element from the given dictionary.
     *
     * @remarks
     * Performs a no-op if the dictionary or field does not exist.
     *
     * @param {string} cacheName - The cache containing the dictionary.
     * @param {string} dictionaryName - The dictionary to remove from.
     * @param {string | Uint8Array} field - The field to remove.
     * @returns {Promise<CacheDictionaryRemoveField.Response>} -
     * {@link CacheDictionaryRemoveField.Success} on success.
     * {@link CacheDictionaryRemoveField.Error} on failure.
     */
    async dictionaryRemoveField(cacheName, dictionaryName, field) {
        const client = this.getNextDataClient();
        return await client.dictionaryRemoveField(cacheName, dictionaryName, field);
    }
    /**
     * Removes multiple fields from the given dictionary.
     *
     * @remarks
     * Performs a no-op if the dictionary or fields do not exist.
     *
     * @param {string} cacheName - The cache containing the dictionary.
     * @param {string} dictionaryName - The dictionary to remove from.
     * @param {string[] | Uint8Array[]} fields - The fields to remove.
     * @returns {Promise<CacheDictionaryRemoveFields.Response>} -
     * {@link CacheDictionaryRemoveFields.Success} on success.
     * {@link CacheDictionaryRemoveFields.Error} on failure.
     */
    async dictionaryRemoveFields(cacheName, dictionaryName, fields) {
        const client = this.getNextDataClient();
        return await client.dictionaryRemoveFields(cacheName, dictionaryName, fields);
    }
    /**
     * Adds an integer quantity to a dictionary value.
     *
     * @remarks
     * Incrementing the value of a missing field sets the value to amount.
     *
     * @param {string} cacheName - The cache containing the dictionary.
     * @param {string} dictionaryName - The dictionary to set.
     * @param {string | Uint8Array} field - The field to increment.
     * @param {number} amount - The quantity to add to the value. May be positive,
     * negative, or zero. Defaults to 1.
     * @param {DictionaryIncrementOptions} options
     * @param {CollectionTtl} [options.ttl] - How the TTL should be managed.
     * Refreshes the dictionary's TTL using the client's default if this is not
     * supplied.
     * @returns {Promise<CacheDictionaryIncrement.Response>} -
     * {@link CacheDictionaryIncrement.Success} containing the incremented value
     * on success.
     * {@link CacheDictionaryIncrement.Error} on failure. Incrementing a value
     * that was not set using this method or is not the string representation of
     * an integer results in a failure with a FailedPreconditionException error.
     */
    async dictionaryIncrement(cacheName, dictionaryName, field, amount = 1, options) {
        const client = this.getNextDataClient();
        return await client.dictionaryIncrement(cacheName, dictionaryName, field, amount, options === null || options === void 0 ? void 0 : options.ttl);
    }
    /**
     * Adds an element to the given sorted set. If the element already exists, its
     * score is updated. Creates the sorted set if it does not exist.
     *
     * @param {string} cacheName - The cache containing the sorted set.
     * @param {string} sortedSetName - The sorted set to add to.
     * @param {string | Uint8Array} value - The value to add.
     * @param {number} score - The score to assign to the value.
     * @param {SortedSetPutElementOptions} options
     * @param {CollectionTtl} [options.ttl] - How the TTL should be managed.
     * Refreshes the sorted set's TTL using the client's default if this is not
     * supplied.
     * @returns {Promise<CacheSortedSetPutElement.Response>} -
     * {@link CacheSortedSetPutElement.Success} on success.
     * {@link CacheSortedSetPutElement.Error} on failure.
     * @returns
     */
    async sortedSetPutElement(cacheName, sortedSetName, value, score, options) {
        const client = this.getNextDataClient();
        return await client.sortedSetPutElement(cacheName, sortedSetName, value, score, options === null || options === void 0 ? void 0 : options.ttl);
    }
    /**
     * Adds elements to the given sorted set. For any values that already exist, it
     * the score is updated. Creates the sorted set if it does not exist.
     *
     * @param {string} cacheName - The cache containing the sorted set.
     * @param {string} sortedSetName - The sorted set to add to.
     * @param {Map<string | Uint8Array, number>| Record<string, number>} elements - The value->score pairs to add to the sorted set.
     * @param {SortedSetPutElementOptions} options
     * @param {CollectionTtl} [options.ttl] - How the TTL should be managed.
     * Refreshes the sorted set's TTL using the client's default if this is not
     * supplied.
     * @returns {Promise<CacheSortedSetPutElements.Response>} -
     * {@link CacheSortedSetPutElements.Success} on success.
     * {@link CacheSortedSetPutElements.Error} on failure.
     * @returns
     */
    async sortedSetPutElements(cacheName, sortedSetName, elements, options) {
        const client = this.getNextDataClient();
        return await client.sortedSetPutElements(cacheName, sortedSetName, elements, options === null || options === void 0 ? void 0 : options.ttl);
    }
    /**
     * Fetch the elements in the given sorted set by index (rank).
     *
     * @param {string} cacheName - The cache containing the sorted set.
     * @param {string} sortedSetName - The sorted set to fetch from.
     * @param {SortedSetFetchByRankOptions} options
     * @param {number} [options.startRank] - The rank of the first element to
     * fetch. Defaults to 0. This rank is inclusive, ie the element at this rank
     * will be fetched.
     * @param {number} [options.endRank] - The rank of the last element to fetch.
     * This rank is exclusive, ie the element at this rank will not be fetched.
     * Defaults to null, which fetches up until and including the last element.
     * @param {SortedSetOrder} [options.order] - The order to fetch the elements in.
     * Defaults to ascending.
     * @returns {Promise<CacheSortedSetFetch.Response>}
     * {@link CacheSortedSetFetch.Hit} containing the requested elements when found.
     * {@link CacheSortedSetFetch.Miss} when the sorted set does not exist.
     * {@link CacheSortedSetFetch.Error} on failure.
     */
    async sortedSetFetchByRank(cacheName, sortedSetName, options) {
        var _a, _b;
        const client = this.getNextDataClient();
        return await client.sortedSetFetchByRank(cacheName, sortedSetName, (_a = options === null || options === void 0 ? void 0 : options.order) !== null && _a !== void 0 ? _a : index_1.SortedSetOrder.Ascending, (_b = options === null || options === void 0 ? void 0 : options.startRank) !== null && _b !== void 0 ? _b : 0, options === null || options === void 0 ? void 0 : options.endRank);
    }
    /**
     * Fetch the elements in the given sorted set by score.
     *
     * @param {string} cacheName - The cache containing the sorted set.
     * @param {string} sortedSetName - The sorted set to fetch from.
     * @param {SortedSetFetchByScoreOptions} options
     * @param {number} [options.minScore] - The minimum score (inclusive) of the
     * elements to fetch. Defaults to negative infinity.
     * @param {number} [options.maxScore] - The maximum score (inclusive) of the
     * elements to fetch. Defaults to positive infinity.
     * @param {SortedSetOrder} [options.order] - The order to fetch the elements in.
     * Defaults to ascending.
     * @param {number} [options.offset] - The number of elements to skip before
     * returning the first element. Defaults to 0. Note: this is not the rank of
     * the first element to return, but the number of elements of the result set
     * to skip before returning the first element.
     * @param {number} [options.count] - The maximum number of elements to return.
     * Defaults to undefined, which returns all elements.
     * @returns {Promise<CacheSortedSetFetch.Response>} -
     * {@link CacheSortedSetFetch.Hit} containing the requested elements when found.
     * {@link CacheSortedSetFetch.Miss} when the sorted set does not exist.
     * {@link CacheSortedSetFetch.Error} on failure.
     */
    async sortedSetFetchByScore(cacheName, sortedSetName, options) {
        var _a;
        const client = this.getNextDataClient();
        return await client.sortedSetFetchByScore(cacheName, sortedSetName, (_a = options === null || options === void 0 ? void 0 : options.order) !== null && _a !== void 0 ? _a : index_1.SortedSetOrder.Ascending, options === null || options === void 0 ? void 0 : options.minScore, options === null || options === void 0 ? void 0 : options.maxScore, options === null || options === void 0 ? void 0 : options.offset, options === null || options === void 0 ? void 0 : options.count);
    }
    /**
     * Look up the rank of an element in the sorted set, by the value of the element.
     *
     * @param {string} cacheName - The cache containing the sorted set.
     * @param {string} sortedSetName - The sorted set to fetch from.
     * @param {string | Uint8Array} value - The value of the element whose rank we are retrieving.
     * @returns {Promise<CacheSortedSetGetRank.Response>}
     * {@link CacheSortedSetGetRank.Hit} containing the rank of the requested elements when found.
     * {@link CacheSortedSetGetRank.Miss} when the element does not exist.
     * {@link CacheSortedSetGetRank.Error} on failure.
     */
    async sortedSetGetRank(cacheName, sortedSetName, value) {
        const client = this.getNextDataClient();
        return await client.sortedSetGetRank(cacheName, sortedSetName, value);
    }
    /**
     * Look up the score of an element in the sorted set, by the value of the element.
     *
     * @param {string} cacheName - The cache containing the sorted set.
     * @param {string} sortedSetName - The sorted set to fetch from.
     * @param {string | Uint8Array} value - The value of the element whose score we are retrieving.
     * @returns {Promise<CacheSortedSetGetScore.Response>}
     * {@link CacheSortedSetGetScore.Hit} containing the score of the requested element when found.
     * {@link CacheSortedSetGetScore.Miss} when the element or collection does not exist.
     * {@link CacheSortedSetGetScore.Error} on failure.
     */
    async sortedSetGetScore(cacheName, sortedSetName, value) {
        const client = this.getNextDataClient();
        return await client.sortedSetGetScore(cacheName, sortedSetName, value);
    }
    /**
     * Look up the scores of multiple elements in the sorted set, by the value of the elements.
     *
     * @param {string} cacheName - The cache containing the sorted set.
     * @param {string} sortedSetName - The sorted set to fetch from.
     * @param {string[] | Uint8Array[]} values - The values of the elements whose scores we are retrieving.
     * @returns {Promise<CacheSortedSetGetScores.Response>}
     * {@link CacheSortedSetGetScores.Hit} containing the scores of the requested elements when found.
     * {@link CacheSortedSetGetScores.Miss} when the element or collection does not exist.
     * {@link CacheSortedSetGetScores.Error} on failure.
     */
    async sortedSetGetScores(cacheName, sortedSetName, values) {
        const client = this.getNextDataClient();
        return await client.sortedSetGetScores(cacheName, sortedSetName, values);
    }
    /**
     * Increment the score of an element in the sorted set.
     *
     * @param {string} cacheName - The cache containing the sorted set.
     * @param {string} sortedSetName - The sorted set to fetch from.
     * @param {string | Uint8Array} value - The value of the element whose score we are incrementing.
     * @param {number} amount - The quantity to add to the score. May be positive,
     * negative, or zero. Defaults to 1.
     * @param {SortedSetIncrementOptions} options
     * @param {CollectionTtl} [options.ttl] - How the TTL should be managed.
     * Refreshes the sorted set's TTL using the client's default if this is not
     * supplied.
     * @returns {Promise<CacheSortedSetIncrementScore.Response>} -
     * {@link CacheSortedSetIncrementScore.Success} containing the incremented score
     * on success.
     * {@link CacheSortedSetIncrementScore.Error} on failure. Incrementing a score
     * that was not set using this method or is not the string representation of
     * an integer results in a failure with a FailedPreconditionException error.
     */
    async sortedSetIncrementScore(cacheName, sortedSetName, value, amount, options) {
        const client = this.getNextDataClient();
        return await client.sortedSetIncrementScore(cacheName, sortedSetName, value, amount || 1, options === null || options === void 0 ? void 0 : options.ttl);
    }
    /**
     * Remove an element from the sorted set
     * @param {string} cacheName - The cache containing the sorted set.
     * @param {string} sortedSetName - The sorted set to remove from.
     * @param {string | Uint8Array} value - The value of the element to remove from the set.
     * @returns {Promise<CacheSortedSetRemoveElement.Response>}
     * {@link CacheSortedSetRemoveElement.Success} if the element was successfully removed
     * {@link CacheSortedSetIncrementScore.Error} on failure
     */
    async sortedSetRemoveElement(cacheName, sortedSetName, value) {
        const client = this.getNextDataClient();
        return await client.sortedSetRemoveElement(cacheName, sortedSetName, value);
    }
    /**
     * Remove multiple elements from the sorted set
     * @param {string} cacheName - The cache containing the sorted set.
     * @param {string} sortedSetName - The sorted set to remove from.
     * @param {string | Uint8Array} values - The values of the elements to remove from the set.
     * @returns {Promise<CacheSortedSetRemoveElement.Response>}
     * {@link CacheSortedSetRemoveElement.Success} if the elements were successfully removed
     * {@link CacheSortedSetIncrementScore.Error} on failure
     */
    async sortedSetRemoveElements(cacheName, sortedSetName, values) {
        const client = this.getNextDataClient();
        return await client.sortedSetRemoveElements(cacheName, sortedSetName, values);
    }
    /**
     * Return the type of the key in the cache
     * @param {string} cacheName - The cache containing the key.
     * @param {string} key - The key for which type is requested.
     * @returns {Promise<ItemGetType.Response>}
     * {@link ItemGetType.Hit} containing type of key when found.
     * {@link ItemGetType.Miss} when the key does not exist.
     * {@link ItemGetType.Error} on failure.
     */
    async itemGetType(cacheName, key) {
        const client = this.getNextDataClient();
        return await client.itemGetType(cacheName, key);
    }
    getNextDataClient() {
        const client = this.dataClients[this.nextDataClientIndex];
        this.nextDataClientIndex =
            (this.nextDataClientIndex + 1) % this.dataClients.length;
        return client;
    }
}
exports.AbstractCacheClient = AbstractCacheClient;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQWJzdHJhY3RDYWNoZUNsaWVudC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3NyYy9pbnRlcm5hbC9jbGllbnRzL2NhY2hlL0Fic3RyYWN0Q2FjaGVDbGllbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBQUEsMENBOEN3QjtBQXVCeEIsTUFBc0IsbUJBQW1CO0lBU3ZDLFlBQ0UsYUFBNkIsRUFDN0IsV0FBMEIsRUFDMUIsVUFBd0I7UUFFeEIsSUFBSSxDQUFDLGFBQWEsR0FBRyxhQUFhLENBQUM7UUFDbkMsSUFBSSxDQUFDLFdBQVcsR0FBRyxXQUFXLENBQUM7UUFDL0IsSUFBSSxDQUFDLFVBQVUsR0FBRyxVQUFVLENBQUM7UUFFN0IsNEVBQTRFO1FBQzVFLHlFQUF5RTtRQUN6RSxrQkFBa0I7UUFDbEIsSUFBSSxDQUFDLG1CQUFtQixHQUFHLENBQUMsQ0FBQztJQUMvQixDQUFDO0lBRUQ7O09BRUc7SUFDSSxLQUFLLENBQUMsSUFBSTs7UUFDZixPQUFPLE1BQU0sQ0FBQSxNQUFBLElBQUksQ0FBQyxVQUFVLDBDQUFFLElBQUksRUFBRSxDQUFBLENBQUM7SUFDdkMsQ0FBQztJQUVEOzs7Ozs7OztPQVFHO0lBQ0ksS0FBSyxDQUFDLFdBQVcsQ0FBQyxTQUFpQjtRQUN4QyxPQUFPLE1BQU0sSUFBSSxDQUFDLGFBQWEsQ0FBQyxXQUFXLENBQUMsU0FBUyxDQUFDLENBQUM7SUFDekQsQ0FBQztJQUVEOzs7Ozs7O09BT0c7SUFDSSxLQUFLLENBQUMsV0FBVyxDQUFDLFNBQWlCO1FBQ3hDLE9BQU8sTUFBTSxJQUFJLENBQUMsYUFBYSxDQUFDLFdBQVcsQ0FBQyxTQUFTLENBQUMsQ0FBQztJQUN6RCxDQUFDO0lBRUQ7Ozs7OztPQU1HO0lBQ0ksS0FBSyxDQUFDLFVBQVU7UUFDckIsT0FBTyxNQUFNLElBQUksQ0FBQyxhQUFhLENBQUMsVUFBVSxFQUFFLENBQUM7SUFDL0MsQ0FBQztJQUVEOzs7Ozs7Ozs7T0FTRztJ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QUFDO0lBQ2hCLENBQUM7Q0FDRjtBQS9rQ0Qsa0RBK2tDQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIENyZWF0ZUNhY2hlLFxuICBEZWxldGVDYWNoZSxcbiAgTGlzdENhY2hlcyxcbiAgQ2FjaGVGbHVzaCxcbiAgQ2FjaGVHZXQsXG4gIENhY2hlU2V0LFxuICBDYWNoZURlbGV0ZSxcbiAgQ2FjaGVJbmNyZW1lbnQsXG4gIEluY3JlbWVudE9wdGlvbnMsXG4gIENhY2hlU2V0SWZOb3RFeGlzdHMsXG4gIFNldElmTm90RXhpc3RzT3B0aW9ucyxcbiAgQ2FjaGVTZXRGZXRjaCxcbiAgQ2FjaGVTZXRBZGRFbGVtZW50LFxuICBDYWNoZVNldEFkZEVsZW1lbnRzLFxuICBDYWNoZVNldFJlbW92ZUVsZW1lbnQsXG4gIENhY2hlU2V0UmVtb3ZlRWxlbWVudHMsXG4gIENhY2hlTGlzdEZldGNoLFxuICBDYWNoZUxpc3RMZW5ndGgsXG4gIENhY2hlTGlzdFB1c2hGcm9udCxcbiAgQ2FjaGVMaXN0UHVzaEJhY2ssXG4gIENhY2hlTGlzdENvbmNhdGVuYXRlQmFjayxcbiAgQ2FjaGVMaXN0Q29uY2F0ZW5hdGVGcm9udCxcbiAgQ2FjaGVMaXN0UG9wQmFjayxcbiAgQ2FjaGVMaXN0UG9wRnJvbnQsXG4gIENhY2hlTGlzdFJlbW92ZVZhbHVlLFxuICBDYWNoZUxpc3RSZXRhaW4sXG4gIENhY2hlRGljdGlvbmFyeVNldEZpZWxkLFxuICBDYWNoZURpY3Rpb25hcnlTZXRGaWVsZHMsXG4gIENhY2hlRGljdGlvbmFyeUdldEZpZWxkLFxuICBDYWNoZURpY3Rpb25hcnlHZXRGaWVsZHMsXG4gIENhY2hlRGljdGlvbmFyeUluY3JlbWVudCxcbiAgQ2FjaGVEaWN0aW9uYXJ5RmV0Y2gsXG4gIENhY2hlRGljdGlvbmFyeVJlbW92ZUZpZWxkLFxuICBDYWNoZURpY3Rpb25hcnlSZW1vdmVGaWVsZHMsXG4gIENhY2hlU29ydGVkU2V0RmV0Y2gsXG4gIENhY2hlU29ydGVkU2V0UHV0RWxlbWVudCxcbiAgQ2FjaGVTb3J0ZWRTZXRQdXRFbGVtZW50cyxcbiAgQ2FjaGVTb3J0ZWRTZXRHZXRSYW5rLFxuICBDYWNoZVNvcnRlZFNldEdldFNjb3JlLFxuICBDYWNoZVNvcnRlZFNldEdldFNjb3JlcyxcbiAgQ2FjaGVTb3J0ZWRTZXRJbmNyZW1lbnRTY29yZSxcbiAgQ2FjaGVTb3J0ZWRTZXRSZW1vdmVFbGVtZW50LFxuICBDYWNoZVNvcnRlZFNldFJlbW92ZUVsZW1lbnRzLFxuICBTb3J0ZWRTZXRPcmRlcixcbiAgSXRlbUdldFR5cGUsXG59IGZyb20gJy4uLy4uLy4uL2luZGV4JztcbmltcG9ydCB7TGlzdEZldGNoQ2FsbE9wdGlvbnMsIExpc3RSZXRhaW5DYWxsT3B0aW9uc30gZnJvbSAnLi4vLi4vLi4vdXRpbHMnO1xuaW1wb3J0IHtcbiAgSUNhY2hlQ2xpZW50LFxuICBTZXRPcHRpb25zLFxuICBTZXRBZGRFbGVtZW50T3B0aW9ucyxcbiAgU2V0QWRkRWxlbWVudHNPcHRpb25zLFxuICBMaXN0UHVzaEZyb250T3B0aW9ucyxcbiAgTGlzdFB1c2hCYWNrT3B0aW9ucyxcbiAgTGlzdENvbmNhdGVuYXRlQmFja09wdGlvbnMsXG4gIExpc3RDb25jYXRlbmF0ZUZyb250T3B0aW9ucyxcbiAgRGljdGlvbmFyeVNldEZpZWxkT3B0aW9ucyxcbiAgRGljdGlvbmFyeUluY3JlbWVudE9wdGlvbnMsXG4gIFNvcnRlZFNldEZldGNoQnlSYW5rT3B0aW9ucyxcbiAgU29ydGVkU2V0UHV0RWxlbWVudE9wdGlvbnMsXG4gIFNvcnRlZFNldFB1dEVsZW1lbnRzT3B0aW9ucyxcbiAgU29ydGVkU2V0RmV0Y2hCeVNjb3JlT3B0aW9ucyxcbiAgU29ydGVkU2V0SW5jcmVtZW50T3B0aW9ucyxcbn0gZnJvbSAnLi4vLi4vLi4vY2xpZW50cy9JQ2FjaGVDbGllbnQnO1xuaW1wb3J0IHtJQ29udHJvbENsaWVudH0gZnJvbSAnLi9JQ29udHJvbENsaWVudCc7XG5pbXBvcnQge0lEYXRhQ2xpZW50fSBmcm9tICcuL0lEYXRhQ2xpZW50JztcbmltcG9ydCB7SVBpbmdDbGllbnR9IGZyb20gJy4vSVBpbmdDbGllbnQnO1xuXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgQWJzdHJhY3RDYWNoZUNsaWVudCBpbXBsZW1lbnRzIElDYWNoZUNsaWVudCB7XG4gIC8vIG1ha2luZyB0aGVzZSBwcm90ZWN0ZWQgdW50aWwgd2UgZnVsbHkgYWJzdHJhY3QgYXdheSB0aGUgbm9kZWpzIGNsaWVudFxuICBwcm90ZWN0ZWQgcmVhZG9ubHkgY29udHJvbENsaWVudDogSUNvbnRyb2xDbGllbnQ7XG4gIHByb3RlY3RlZCByZWFkb25seSBkYXRhQ2xpZW50czogSURhdGFDbGllbnRbXTtcbiAgLy8gVE9ETzogTWFrZSBwaW5nQ2xpZW50IHJlcXVpcmVkIGlmIGFuZCB3aGVuIHRoZSBub2RlanMgc2lkZSBzdGFydHMgYWRkaW5nXG4gIC8vICBvbmUgYXMgd2VsbFxuICBwcm90ZWN0ZWQgcmVhZG9ubHkgcGluZ0NsaWVudD86IElQaW5nQ2xpZW50O1xuICBwcm90ZWN0ZWQgbmV4dERhdGFDbGllbnRJbmRleDogbnVtYmVyO1xuXG4gIHByb3RlY3RlZCBjb25zdHJ1Y3RvcihcbiAgICBjb250cm9sQ2xpZW50OiBJQ29udHJvbENsaWVudCxcbiAgICBkYXRhQ2xpZW50czogSURhdGFDbGllbnRbXSxcbiAgICBwaW5nQ2xpZW50PzogSVBpbmdDbGllbnRcbiAgKSB7XG4gICAgdGhpcy5jb250cm9sQ2xpZW50ID0gY29udHJvbENsaWVudDtcbiAgICB0aGlzLmRhdGFDbGllbnRzID0gZGF0YUNsaWVudHM7XG4gICAgdGhpcy5waW5nQ2xpZW50ID0gcGluZ0NsaWVudDtcblxuICAgIC8vIFdlIHJvdW5kLXJvYmluIHRoZSByZXF1ZXN0cyB0aHJvdWdoIGFsbCBvZiBvdXIgY2xpZW50cy4gIFNpbmNlIGphdmFzY3JpcHRcbiAgICAvLyBpcyBzaW5nbGUtdGhyZWFkZWQsIHdlIGRvbid0IGhhdmUgdG8gd29ycnkgYWJvdXQgdGhyZWFkIHNhZmV0eSBvbiB0aGlzXG4gICAgLy8gaW5kZXggdmFyaWFibGUuXG4gICAgdGhpcy5uZXh0RGF0YUNsaWVudEluZGV4ID0gMDtcbiAgfVxuXG4gIC8qKlxuICAgKiBQaW5nIHRoZSBzZXJ2aWNlIHRvIHZlcmlmeSBpdCBpcyB1cCBhbmQgcnVubmluZ1xuICAgKi9cbiAgcHVibGljIGFzeW5jIHBpbmcoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMucGluZ0NsaWVudD8ucGluZygpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBjYWNoZSBpZiBpdCBkb2VzIG5vdCBleGlzdC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNhY2hlTmFtZSAtIFRoZSBjYWNoZSB0byBiZSBjcmVhdGVkLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxDcmVhdGVDYWNoZS5SZXNwb25zZT59IC1cbiAgICoge0BsaW5rIENyZWF0ZUNhY2hlLlN1Y2Nlc3N9IG9uIHN1Y2Nlc3MuXG4gICAqIHtAbGluayBDcmVhdGVDYWNoZS5BbHJlYWR5RXhpc3RzfSBpZiB0aGUgY2FjaGUgYWxyZWFkeSBleGlzdHMuXG4gICAqIHtAbGluayBDcmVhdGVDYWNoZS5FcnJvcn0gb24gZmFpbHVyZS5cbiAgICovXG4gIHB1YmxpYyBhc3luYyBjcmVhdGVDYWNoZShjYWNoZU5hbWU6IHN0cmluZyk6IFByb21pc2U8Q3JlYXRlQ2FjaGUuUmVzcG9uc2U+IHtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5jb250cm9sQ2xpZW50LmNyZWF0ZUNhY2hlKGNhY2hlTmFtZSk7XG4gIH1cblxuICAvKipcbiAgICogRGVsZXRlcyBhIGNhY2hlIGFuZCBhbGwgaXRlbXMgc3RvcmVkIGluIGl0LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2FjaGVOYW1lIC0gVGhlIGNhY2hlIHRvIGRlbGV0ZS5cbiAgICogQHJldHVybnMge1Byb21pc2U8RGVsZXRlQ2FjaGUuUmVzcG9uc2U+fSAtXG4gICAqIHtAbGluayBEZWxldGVDYWNoZS5TdWNjZXNzfSBvbiBzdWNjZXNzLlxuICAgKiB7QGxpbmsgRGVsZXRlQ2FjaGUuRXJyb3J9IG9uIGZhaWx1cmUuXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgZGVsZXRlQ2FjaGUoY2FjaGVOYW1lOiBzdHJpbmcpOiBQcm9taXNlPERlbGV0ZUNhY2hlLlJlc3BvbnNlPiB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuY29udHJvbENsaWVudC5kZWxldGVDYWNoZShjYWNoZU5hbWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIExpc3RzIGFsbCBjYWNoZXMuXG4gICAqXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPExpc3RDYWNoZXMuUmVzcG9uc2U+fSAtXG4gICAqIHtAbGluayBMaXN0Q2FjaGVzLlN1Y2Nlc3N9IGNvbnRhaW5pbmcgdGhlIGxpc3Qgb24gc3VjY2Vzcy5cbiAgICoge0BsaW5rIExpc3RDYWNoZXMuRXJyb3J9IG9uIGZhaWx1cmUuXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgbGlzdENhY2hlcygpOiBQcm9taXNlPExpc3RDYWNoZXMuUmVzcG9uc2U+IHtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5jb250cm9sQ2xpZW50Lmxpc3RDYWNoZXMoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSB2YWx1ZSBzdG9yZWQgZm9yIHRoZSBnaXZlbiBrZXkuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjYWNoZU5hbWUgLSBUaGUgY2FjaGUgdG8gcGVyZm9ybSB0aGUgbG9va3VwIGluLlxuICAgKiBAcGFyYW0ge3N0cmluZyB8IFVpbnQ4QXJyYXl9IGtleSAtIFRoZSBrZXkgdG8gbG9vayB1cC5cbiAgICogQHJldHVybnMge1Byb21pc2U8Q2FjaGVHZXQuUmVzcG9uc2U+fSAtXG4gICAqIHtAbGluayBDYWNoZUdldC5IaXR9IGNvbnRhaW5pbmcgdGhlIHZhbHVlIGlmIG9uZSBpcyBmb3VuZC5cbiAgICoge0BsaW5rIENhY2hlR2V0Lk1pc3N9IGlmIHRoZSBrZXkgZG9lcyBub3QgZXhpc3QuXG4gICAqIHtAbGluayBDYWNoZUdldC5FcnJvcn0gb24gZmFpbHVyZS5cbiAgICovXG4gIHB1YmxpYyBhc3luYyBnZXQoXG4gICAgY2FjaGVOYW1lOiBzdHJpbmcsXG4gICAga2V5OiBzdHJpbmcgfCBVaW50OEFycmF5XG4gICk6IFByb21pc2U8Q2FjaGVHZXQuUmVzcG9uc2U+IHtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5nZXROZXh0RGF0YUNsaWVudCgpLmdldChjYWNoZU5hbWUsIGtleSk7XG4gIH1cblxuICAvKipcbiAgICogQXNzb2NpYXRlcyB0aGUgZ2l2ZW4ga2V5IHdpdGggdGhlIGdpdmVuIHZhbHVlLiBJZiBhIHZhbHVlIGZvciB0aGUga2V5IGlzXG4gICAqIGFscmVhZHkgcHJlc2VudCBpdCBpcyByZXBsYWNlZCB3aXRoIHRoZSBuZXcgdmFsdWUuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjYWNoZU5hbWUgLSBUaGUgY2FjaGUgdG8gc3RvcmUgdGhlIHZhbHVlIGluLlxuICAgKiBAcGFyYW0ge3N0cmluZyB8IFVpbnQ4QXJyYXl9IGtleSAtIFRoZSBrZXkgdG8gc2V0LlxuICAgKiBAcGFyYW0ge3N0cmluZyB8IFVpbnQ4QXJyYXl9IHZhbHVlIC0gVGhlIHZhbHVlIHRvIGJlIHN0b3JlZC5cbiAgICogQHBhcmFtIHtTZXRPcHRpb25zfSBbb3B0aW9uc11cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLnR0bF0gLSBUaGUgdGltZSB0byBsaXZlIGZvciB0aGUgaXRlbSBpbiB0aGUgY2FjaGUuXG4gICAqIFVzZXMgdGhlIGNsaWVudCdzIGRlZmF1bHQgVFRMIGlmIHRoaXMgaXMgbm90IHN1cHBsaWVkLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxDYWNoZVNldC5SZXNwb25zZT59IC1cbiAgICoge0BsaW5rIENhY2hlU2V0LlN1Y2Nlc3N9IG9uIHN1Y2Nlc3MuXG4gICAqIHtAbGluayBDYWNoZVNldC5FcnJvcn0gb24gZmFpbHVyZS5cbiAgICovXG4gIHB1YmxpYyBhc3luYyBzZXQoXG4gICAgY2FjaGVOYW1lOiBzdHJpbmcsXG4gICAga2V5OiBzdHJpbmcgfCBVaW50OEFycmF5LFxuICAgIHZhbHVlOiBzdHJpbmcgfCBVaW50OEFycmF5LFxuICAgIG9wdGlvbnM/OiBTZXRPcHRpb25zXG4gICk6IFByb21pc2U8Q2FjaGVTZXQuUmVzcG9uc2U+IHtcbiAgICBjb25zdCBjbGllbnQgPSB0aGlzLmdldE5leHREYXRhQ2xpZW50KCk7XG4gICAgcmV0dXJuIGF3YWl0IGNsaWVudC5zZXQoY2FjaGVOYW1lLCBrZXksIHZhbHVlLCBvcHRpb25zPy50dGwpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgdGhlIGdpdmVuIGtleSBmcm9tIHRoZSBjYWNoZS4gVGhlIGtleSBjYW4gcmVwcmVzZW50IGEgc2luZ2xlIHZhbHVlXG4gICAqIG9yIGEgY29sbGVjdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNhY2hlTmFtZSAtIFRoZSBjYWNoZSB0byBkZWxldGUgZnJvbS5cbiAgICogQHBhcmFtIHtzdHJpbmcgfCBVaW50OEFycmF5fSBrZXkgLSBUaGUga2V5IHRvIGRlbGV0ZS5cbiAgICogQHJldHVybnMge1Byb21pc2U8Q2FjaGVEZWxldGUuUmVzcG9uc2U+fSAtXG4gICAqIHtAbGluayBDYWNoZURlbGV0ZS5TdWNjZXNzfSBvbiBzdWNjZXNzLlxuICAgKiB7QGxpbmsgQ2FjaGVEZWxldGUuRXJyb3J9IG9uIGZhaWx1cmUuXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgZGVsZXRlKFxuICAgIGNhY2hlTmFtZTogc3RyaW5nLFxuICAgIGtleTogc3RyaW5nIHwgVWludDhBcnJheVxuICApOiBQcm9taXNlPENhY2hlRGVsZXRlLlJlc3BvbnNlPiB7XG4gICAgY29uc3QgY2xpZW50ID0gdGhpcy5nZXROZXh0RGF0YUNsaWVudCgpO1xuICAgIHJldHVybiBhd2FpdCBjbGllbnQuZGVsZXRlKGNhY2hlTmFtZSwga2V5KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIG11bHRpcGxlIGVsZW1lbnRzIHRvIHRoZSBiYWNrIG9mIHRoZSBnaXZlbiBsaXN0LiBDcmVhdGVzIHRoZSBsaXN0IGlmXG4gICAqIGl0IGRvZXMgbm90IGFscmVhZHkgZXhpc3QuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjYWNoZU5hbWUgLSBUaGUgY2FjaGUgdG8gc3RvcmUgdGhlIGxpc3QgaW4uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBsaXN0TmFtZSAtIFRoZSBsaXN0IHRvIGFkZCB0by5cbiAgICogQHBhcmFtIHtzdHJpbmdbXSB8IFVpbnQ4QXJyYXlbXX0gdmFsdWVzIC0gVGhlIGVsZW1lbnRzIHRvIGFkZCB0byB0aGUgbGlzdC5cbiAgICogQHBhcmFtIHtMaXN0Q29uY2F0ZW5hdGVCYWNrT3B0aW9uc30gW29wdGlvbnNdXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy50cnVuY2F0ZUZyb250VG9TaXplXSAtIElmIHRoZSBsaXN0IGV4Y2VlZHMgdGhpc1xuICAgKiBsZW5ndGgsIHJlbW92ZSBleGNlc3MgZnJvbSB0aGUgZnJvbnQgb2YgdGhlIGxpc3QuIE11c3QgYmUgcG9zaXRpdmUuXG4gICAqIEBwYXJhbSB7Q29sbGVjdGlvblR0bH0gW29wdGlvbnMudHRsXSAtIEhvdyB0aGUgVFRMIHNob3VsZCBiZSBtYW5hZ2VkLlxuICAgKiBSZWZyZXNoZXMgdGhlIGxpc3QncyBUVEwgdXNpbmcgdGhlIGNsaWVudCdzIGRlZmF1bHQgaWYgdGhpcyBpcyBub3RcbiAgICogc3VwcGxpZWQuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPENhY2hlTGlzdENvbmNhdGVuYXRlQmFjay5SZXNwb25zZT59IC1cbiAgICoge0BsaW5rIENhY2hlTGlzdENvbmNhdGVuYXRlQmFjay5TdWNjZXNzfSBvbiBzdWNjZXNzLlxuICAgKiB7QGxpbmsgQ2FjaGVMaXN0Q29uY2F0ZW5hdGVCYWNrLkVycm9yfSBvbiBmYWlsdXJlLlxuICAgKi9cbiAgcHVibGljIGFzeW5jIGxpc3RDb25jYXRlbmF0ZUJhY2soXG4gICAgY2FjaGVOYW1lOiBzdHJpbmcsXG4gICAgbGlzdE5hbWU6IHN0cmluZyxcbiAgICB2YWx1ZXM6IHN0cmluZ1tdIHwgVWludDhBcnJheVtdLFxuICAgIG9wdGlvbnM/OiBMaXN0Q29uY2F0ZW5hdGVCYWNrT3B0aW9uc1xuICApOiBQcm9taXNlPENhY2hlTGlzdENvbmNhdGVuYXRlQmFjay5SZXNwb25zZT4ge1xuICAgIGNvbnN0IGNsaWVudCA9IHRoaXMuZ2V0TmV4dERhdGFDbGllbnQoKTtcbiAgICByZXR1cm4gYXdhaXQgY2xpZW50Lmxpc3RDb25jYXRlbmF0ZUJhY2soXG4gICAgICBjYWNoZU5hbWUsXG4gICAgICBsaXN0TmFtZSxcbiAgICAgIHZhbHVlcyxcbiAgICAgIG9wdGlvbnM/LnRydW5jYXRlRnJvbnRUb1NpemUsXG4gICAgICBvcHRpb25zPy50dGxcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgbXVsdGlwbGUgZWxlbWVudHMgdG8gdGhlIGZyb250IG9mIHRoZSBnaXZlbiBsaXN0LiBDcmVhdGVzIHRoZSBsaXN0IGlmXG4gICAqIGl0IGRvZXMgbm90IGFscmVhZHkgZXhpc3QuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjYWNoZU5hbWUgLSBUaGUgY2FjaGUgdG8gc3RvcmUgdGhlIGxpc3QgaW4uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBsaXN0TmFtZSAtIFRoZSBsaXN0IHRvIGFkZCB0by5cbiAgICogQHBhcmFtIHtzdHJpbmdbXSB8IFVpbnQ4QXJyYXlbXX0gdmFsdWVzIC0gVGhlIGVsZW1lbnRzIHRvIGFkZCB0byB0aGUgbGlzdC5cbiAgICogQHBhcmFtIHtMaXN0Q29uY2F0ZW5hdGVGcm9udE9wdGlvbnN9IFtvcHRpb25zXVxuICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMudHJ1bmNhdGVCYWNrVG9TaXplXSAtIElmIHRoZSBsaXN0IGV4Y2VlZHMgdGhpc1xuICAgKiBsZW5ndGgsIHJlbW92ZSBleGNlc3MgZnJvbSB0aGUgYmFjayBvZiB0aGUgbGlzdC4gTXVzdCBiZSBwb3NpdGl2ZS5cbiAgICogQHBhcmFtIHtDb2xsZWN0aW9uVHRsfSBbb3B0aW9ucy50dGxdIC0gSG93IHRoZSBUVEwgc2hvdWxkIGJlIG1hbmFnZWQuXG4gICAqIFJlZnJlc2hlcyB0aGUgbGlzdCdzIFRUTCB1c2luZyB0aGUgY2xpZW50J3MgZGVmYXVsdCBpZiB0aGlzIGlzIG5vdFxuICAgKiBzdXBwbGllZC5cbiAgICogQHJldHVybnMge1Byb21pc2U8Q2FjaGVMaXN0Q29uY2F0ZW5hdGVGcm9udC5SZXNwb25zZT59IC1cbiAgICoge0BsaW5rIENhY2hlTGlzdENvbmNhdGVuYXRlRnJvbnQuU3VjY2Vzc30gb24gc3VjY2Vzcy5cbiAgICoge0BsaW5rIENhY2hlTGlzdENvbmNhdGVuYXRlRnJvbnQuRXJyb3J9IG9uIGZhaWx1cmUuXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgbGlzdENvbmNhdGVuYXRlRnJvbnQoXG4gICAgY2FjaGVOYW1lOiBzdHJpbmcsXG4gICAgbGlzdE5hbWU6IHN0cmluZyxcbiAgICB2YWx1ZXM6IHN0cmluZ1tdIHwgVWludDhBcnJheVtdLFxuICAgIG9wdGlvbnM/OiBMaXN0Q29uY2F0ZW5hdGVGcm9udE9wdGlvbnNcbiAgKTogUHJvbWlzZTxDYWNoZUxpc3RDb25jYXRlbmF0ZUZyb250LlJlc3BvbnNlPiB7XG4gICAgY29uc3QgY2xpZW50ID0gdGhpcy5nZXROZXh0RGF0YUNsaWVudCgpO1xuICAgIHJldHVybiBhd2FpdCBjbGllbnQubGlzdENvbmNhdGVuYXRlRnJvbnQoXG4gICAgICBjYWNoZU5hbWUsXG4gICAgICBsaXN0TmFtZSxcbiAgICAgIHZhbHVlcyxcbiAgICAgIG9wdGlvbnM/LnRydW5jYXRlQmFja1RvU2l6ZSxcbiAgICAgIG9wdGlvbnM/LnR0bFxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2hlcyBhbGwgZWxlbWVudHMgb2YgdGhlIGdpdmVuIGxpc3QuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjYWNoZU5hbWUgLSBUaGUgY2FjaGUgY29udGFpbmluZyB0aGUgbGlzdC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGxpc3ROYW1lIC0gVGhlIGxpc3QgdG8gZmV0Y2guXG4gICAqIEBwYXJhbSB7TGlzdEZldGNoQ2FsbE9wdGlvbnN9IFtvcHRpb25zXVxuICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuc3RhcnRJbmRleF0gLSBTdGFydCBpbmNsdXNpdmUgaW5kZXggZm9yIGZldGNoIG9wZXJhdGlvbi5cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmVuZEluZGV4XSAtIEVuZCBleGNsdXNpdmUgaW5kZXggZm9yIGZldGNoIG9wZXJhdGlvbi5cbiAgICogQHJldHVybnMge1Byb21pc2U8Q2FjaGVMaXN0RmV0Y2guUmVzcG9uc2U+fSAtXG4gICAqIHtAbGluayBDYWNoZUxpc3RGZXRjaC5IaXR9IGNvbnRhaW5pbmcgdGhlIGxpc3QgZWxlbWVudHMgaWYgdGhlIGxpc3QgZXhpc3RzLlxuICAgKiB7QGxpbmsgQ2FjaGVMaXN0RmV0Y2guTWlzc30gaWYgdGhlIGxpc3QgZG9lcyBub3QgZXhpc3QuXG4gICAqIHtAbGluayBDYWNoZUxpc3RGZXRjaC5FcnJvcn0gb24gZmFpbHVyZS5cbiAgICovXG4gIHB1YmxpYyBhc3luYyBsaXN0RmV0Y2goXG4gICAgY2FjaGVOYW1lOiBzdHJpbmcsXG4gICAgbGlzdE5hbWU6IHN0cmluZyxcbiAgICBvcHRpb25zPzogTGlzdEZldGNoQ2FsbE9wdGlvbnNcbiAgKTogUHJvbWlzZTxDYWNoZUxpc3RGZXRjaC5SZXNwb25zZT4ge1xuICAgIGNvbnN0IGNsaWVudCA9IHRoaXMuZ2V0TmV4dERhdGFDbGllbnQoKTtcbiAgICByZXR1cm4gYXdhaXQgY2xpZW50Lmxpc3RGZXRjaChcbiAgICAgIGNhY2hlTmFtZSxcbiAgICAgIGxpc3ROYW1lLFxuICAgICAgb3B0aW9ucz8uc3RhcnRJbmRleCxcbiAgICAgIG9wdGlvbnM/LmVuZEluZGV4XG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBudW1iZXIgb2YgZWxlbWVudHMgaW4gdGhlIGdpdmVuIGxpc3QuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjYWNoZU5hbWUgLSBUaGUgY2FjaGUgY29udGFpbmluZyB0aGUgbGlzdC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGxpc3ROYW1lIC0gVGhlIGxpc3QgdG8gZ2V0IHRoZSBsZW5ndGggb2YuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPENhY2hlTGlzdExlbmd0aC5SZXNwb25zZT59IC1cbiAgICoge0BsaW5rIENhY2hlTGlzdExlbmd0aC5IaXR9IGNvbnRhaW5pbmcgdGhlIGxlbmd0aCBpZiB0aGUgbGlzdCBleGlzdHMuXG4gICAqIHtAbGluayBDYWNoZUxpc3RMZW5ndGguTWlzc30gaWYgdGhlIGxpc3QgZG9lcyBub3QgZXhpc3QuXG4gICAqIHtAbGluayBDYWNoZUxpc3RMZW5ndGguRXJyb3J9IG9uIGZhaWx1cmUuXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgbGlzdExlbmd0aChcbiAgICBjYWNoZU5hbWU6IHN0cmluZyxcbiAgICBsaXN0TmFtZTogc3RyaW5nXG4gICk6IFByb21pc2U8Q2FjaGVMaXN0TGVuZ3RoLlJlc3BvbnNlPiB7XG4gICAgY29uc3QgY2xpZW50ID0gdGhpcy5nZXROZXh0RGF0YUNsaWVudCgpO1xuICAgIHJldHVybiBhd2FpdCBjbGllbnQubGlzdExlbmd0aChjYWNoZU5hbWUsIGxpc3ROYW1lKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGFuZCByZW1vdmVzIHRoZSBsYXN0IHZhbHVlIGZyb20gdGhlIGdpdmVuIGxpc3QuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjYWNoZU5hbWUgLSBUaGUgY2FjaGUgY29udGFpbmluZyB0aGUgbGlzdC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGxpc3ROYW1lIC0gVGhlIGxpc3QgdG8gcG9wLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxDYWNoZUxpc3RQb3BCYWNrLlJlc3BvbnNlPn0gLVxuICAgKiB7QGxpbmsgQ2FjaGVMaXN0UG9wQmFjay5IaXR9IGNvbnRhaW5pbmcgdGhlIGVsZW1lbnQgaWYgdGhlIGxpc3QgZXhpc3RzLlxuICAgKiB7QGxpbmsgQ2FjaGVMaXN0UG9wQmFjay5NaXNzfSBpZiB0aGUgbGlzdCBkb2VzIG5vdCBleGlzdC5cbiAgICoge0BsaW5rIENhY2hlTGlzdFBvcEJhY2suRXJyb3J9IG9uIGZhaWx1cmUuXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgbGlzdFBvcEJhY2soXG4gICAgY2FjaGVOYW1lOiBzdHJpbmcsXG4gICAgbGlzdE5hbWU6IHN0cmluZ1xuICApOiBQcm9taXNlPENhY2hlTGlzdFBvcEJhY2suUmVzcG9uc2U+IHtcbiAgICBjb25zdCBjbGllbnQgPSB0aGlzLmdldE5leHREYXRhQ2xpZW50KCk7XG4gICAgcmV0dXJuIGF3YWl0IGNsaWVudC5saXN0UG9wQmFjayhjYWNoZU5hbWUsIGxpc3ROYW1lKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGFuZCByZW1vdmVzIHRoZSBmaXJzdCB2YWx1ZSBmcm9tIHRoZSBnaXZlbiBsaXN0LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2FjaGVOYW1lIC0gVGhlIGNhY2hlIGNvbnRhaW5pbmcgdGhlIGxpc3QuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBsaXN0TmFtZSAtIFRoZSBsaXN0IHRvIHBvcC5cbiAgICogQHJldHVybnMge1Byb21pc2U8Q2FjaGVMaXN0UG9wRnJvbnQuUmVzcG9uc2U+fSAtXG4gICAqIHtAbGluayBDYWNoZUxpc3RQb3BGcm9udC5IaXR9IGNvbnRhaW5pbmcgdGhlIGVsZW1lbnQgaWYgdGhlIGxpc3QgZXhpc3RzLlxuICAgKiB7QGxpbmsgQ2FjaGVMaXN0UG9wRnJvbnQuTWlzc30gaWYgdGhlIGxpc3QgZG9lcyBub3QgZXhpc3QuXG4gICAqIHtAbGluayBDYWNoZUxpc3RQb3BGcm9udC5FcnJvcn0gb24gZmFpbHVyZS5cbiAgICovXG4gIHB1YmxpYyBhc3luYyBsaXN0UG9wRnJvbnQoXG4gICAgY2FjaGVOYW1lOiBzdHJpbmcsXG4gICAgbGlzdE5hbWU6IHN0cmluZ1xuICApOiBQcm9taXNlPENhY2hlTGlzdFBvcEZyb250LlJlc3BvbnNlPiB7XG4gICAgY29uc3QgY2xpZW50ID0gdGhpcy5nZXROZXh0RGF0YUNsaWVudCgpO1xuICAgIHJldHVybiBhd2FpdCBjbGllbnQubGlzdFBvcEZyb250KGNhY2hlTmFtZSwgbGlzdE5hbWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgYW4gZWxlbWVudCB0byB0aGUgYmFjayBvZiB0aGUgZ2l2ZW4gbGlzdC4gQ3JlYXRlcyB0aGUgbGlzdCBpZlxuICAgKiBpdCBkb2VzIG5vdCBhbHJlYWR5IGV4aXN0LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2FjaGVOYW1lIC0gVGhlIGNhY2hlIHRvIHN0b3JlIHRoZSBsaXN0IGluLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbGlzdE5hbWUgLSBUaGUgbGlzdCB0byBwdXNoIHRvLlxuICAgKiBAcGFyYW0ge3N0cmluZyB8IFVpbnQ4QXJyYXl9IHZhbHVlIC0gVGhlIHZhbHVlIHRvIHB1c2guXG4gICAqIEBwYXJhbSB7TGlzdFB1c2hCYWNrT3B0aW9uc30gW29wdGlvbnNdXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy50cnVuY2F0ZUZyb250VG9TaXplXSAtIElmIHRoZSBsaXN0IGV4Y2VlZHMgdGhpc1xuICAgKiBsZW5ndGgsIHJlbW92ZSBleGNlc3MgZnJvbSB0aGUgZnJvbnQgb2YgdGhlIGxpc3QuIE11c3QgYmUgcG9zaXRpdmUuXG4gICAqIEBwYXJhbSB7Q29sbGVjdGlvblR0bH0gW29wdGlvbnMudHRsXSAtIEhvdyB0aGUgVFRMIHNob3VsZCBiZSBtYW5hZ2VkLlxuICAgKiBSZWZyZXNoZXMgdGhlIGxpc3QncyBUVEwgdXNpbmcgdGhlIGNsaWVudCdzIGRlZmF1bHQgaWYgdGhpcyBpcyBub3RcbiAgICogc3VwcGxpZWQuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPENhY2hlTGlzdFB1c2hCYWNrLlJlc3BvbnNlPn0gLVxuICAgKiB7QGxpbmsgQ2FjaGVMaXN0UHVzaEJhY2suU3VjY2Vzc30gY29udGFpbmluZyB0aGUgbGlzdCdzIG5ldyBsZW5ndGggb25cbiAgICogc3VjY2Vzcy5cbiAgICoge0BsaW5rIENhY2hlTGlzdFB1c2hCYWNrLkVycm9yfSBvbiBmYWlsdXJlLlxuICAgKi9cbiAgcHVibGljIGFzeW5jIGxpc3RQdXNoQmFjayhcbiAgICBjYWNoZU5hbWU6IHN0cmluZyxcbiAgICBsaXN0TmFtZTogc3RyaW5nLFxuICAgIHZhbHVlOiBzdHJpbmcgfCBVaW50OEFycmF5LFxuICAgIG9wdGlvbnM/OiBMaXN0UHVzaEJhY2tPcHRpb25zXG4gICk6IFByb21pc2U8Q2FjaGVMaXN0UHVzaEJhY2suUmVzcG9uc2U+IHtcbiAgICBjb25zdCBjbGllbnQgPSB0aGlzLmdldE5leHREYXRhQ2xpZW50KCk7XG4gICAgcmV0dXJuIGF3YWl0IGNsaWVudC5saXN0UHVzaEJhY2soXG4gICAgICBjYWNoZU5hbWUsXG4gICAgICBsaXN0TmFtZSxcbiAgICAgIHZhbHVlLFxuICAgICAgb3B0aW9ucz8udHJ1bmNhdGVGcm9udFRvU2l6ZSxcbiAgICAgIG9wdGlvbnM/LnR0bFxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogQWRkcyBhbiBlbGVtZW50IHRvIHRoZSBmcm9udCBvZiB0aGUgZ2l2ZW4gbGlzdC4gQ3JlYXRlcyB0aGUgbGlzdCBpZlxuICAgKiBpdCBkb2VzIG5vdCBhbHJlYWR5IGV4aXN0LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2FjaGVOYW1lIC0gVGhlIGNhY2hlIHRvIHN0b3JlIHRoZSBsaXN0IGluLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbGlzdE5hbWUgLSBUaGUgbGlzdCB0byBwdXNoIHRvLlxuICAgKiBAcGFyYW0ge3N0cmluZyB8IFVpbnQ4QXJyYXl9IHZhbHVlIC0gVGhlIHZhbHVlIHRvIHB1c2guXG4gICAqIEBwYXJhbSB7TGlzdFB1c2hGcm9udE9wdGlvbnN9IFtvcHRpb25zXVxuICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMudHJ1bmNhdGVCYWNrVG9TaXplXSAtIElmIHRoZSBsaXN0IGV4Y2VlZHMgdGhpc1xuICAgKiBsZW5ndGgsIHJlbW92ZSBleGNlc3MgZnJvbSB0aGUgZW5kIG9mIHRoZSBsaXN0LiBNdXN0IGJlIHBvc2l0aXZlLlxuICAgKiBAcGFyYW0ge0NvbGxlY3Rpb25UdGx9IFtvcHRpb25zLnR0bF0gLSBIb3cgdGhlIFRUTCBzaG91bGQgYmUgbWFuYWdlZC5cbiAgICogUmVmcmVzaGVzIHRoZSBsaXN0J3MgVFRMIHVzaW5nIHRoZSBjbGllbnQncyBkZWZhdWx0IGlmIHRoaXMgaXMgbm90XG4gICAqIHN1cHBsaWVkLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxDYWNoZUxpc3RQdXNoRnJvbnQuUmVzcG9uc2U+fSAtXG4gICAqIHtAbGluayBDYWNoZUxpc3RQdXNoRnJvbnQuU3VjY2Vzc30gY29udGFpbmluZyB0aGUgbGlzdCdzIG5ldyBsZW5ndGggb25cbiAgICogc3VjY2Vzcy5cbiAgICoge0BsaW5rIENhY2hlTGlzdFB1c2hGcm9udC5FcnJvcn0gb24gZmFpbHVyZS5cbiAgICovXG4gIHB1YmxpYyBhc3luYyBsaXN0UHVzaEZyb250KFxuICAgIGNhY2hlTmFtZTogc3RyaW5nLFxuICAgIGxpc3ROYW1lOiBzdHJpbmcsXG4gICAgdmFsdWU6IHN0cmluZyB8IFVpbnQ4QXJyYXksXG4gICAgb3B0aW9ucz86IExpc3RQdXNoRnJvbnRPcHRpb25zXG4gICk6IFByb21pc2U8Q2FjaGVMaXN0UHVzaEZyb250LlJlc3BvbnNlPiB7XG4gICAgY29uc3QgY2xpZW50ID0gdGhpcy5nZXROZXh0RGF0YUNsaWVudCgpO1xuICAgIHJldHVybiBhd2FpdCBjbGllbnQubGlzdFB1c2hGcm9udChcbiAgICAgIGNhY2hlTmFtZSxcbiAgICAgIGxpc3ROYW1lLFxuICAgICAgdmFsdWUsXG4gICAgICBvcHRpb25zPy50cnVuY2F0ZUJhY2tUb1NpemUsXG4gICAgICBvcHRpb25zPy50dGxcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgYWxsIGVsZW1lbnRzIGZyb20gdGhlIGdpdmVuIGxpc3QgZXF1YWwgdG8gdGhlIGdpdmVuIHZhbHVlLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2FjaGVOYW1lIC0gVGhlIGNhY2hlIGNvbnRhaW5pbmcgdGhlIGxpc3QuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBsaXN0TmFtZSAtIFRoZSBsaXN0IHRvIHJlbW92ZSBmcm9tLlxuICAgKiBAcGFyYW0ge3N0cmluZyB8IFVpbnQ4QXJyYXl9IHZhbHVlIC0gVGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAgICogQHJldHVybnMge1Byb21pc2U8Q2FjaGVMaXN0UmVtb3ZlVmFsdWUuUmVzcG9uc2U+fSAtXG4gICAqIHtAbGluayBDYWNoZUxpc3RSZW1vdmVWYWx1ZS5TdWNjZXNzfSBvbiBzdWNjZXNzLiBSZW1vdmluZyBhbiBlbGVtZW50IHRoYXRcbiAgICogZG9lcyBub3Qgb2NjdXIgaW4gdGhlIGxpc3Qgb3IgcmVtb3ZpbmcgZnJvbSBhIG5vbi1leGlzdGVudCBsaXN0IGNvdW50cyBhcyBhXG4gICAqIHN1Y2Nlc3MuXG4gICAqIHtAbGluayBDYWNoZUxpc3RSZW1vdmVWYWx1ZS5FcnJvcn0gb24gZmFpbHVyZS5cbiAgICovXG4gIHB1YmxpYyBhc3luYyBsaXN0UmVtb3ZlVmFsdWUoXG4gICAgY2FjaGVOYW1lOiBzdHJpbmcsXG4gICAgbGlzdE5hbWU6IHN0cmluZyxcbiAgICB2YWx1ZTogc3RyaW5nIHwgVWludDhBcnJheVxuICApOiBQcm9taXNlPENhY2hlTGlzdFJlbW92ZVZhbHVlLlJlc3BvbnNlPiB7XG4gICAgY29uc3QgY2xpZW50ID0gdGhpcy5nZXROZXh0RGF0YUNsaWVudCgpO1xuICAgIHJldHVybiBhd2FpdCBjbGllbnQubGlzdFJlbW92ZVZhbHVlKGNhY2hlTmFtZSwgbGlzdE5hbWUsIHZhbHVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXRhaW5zIHNsaWNlIG9mIGVsZW1lbnRzIG9mIGEgZ2l2ZW4gbGlzdCwgZGVsZXRlcyB0aGUgcmVzdCBvZiB0aGUgbGlzdFxuICAgKiB0aGF0IGlzbid0IGJlaW5nIHJldGFpbmVkLiBSZXR1cm5zIGEgU3VjY2VzcyBvciBFcnJvci5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNhY2hlTmFtZSAtIFRoZSBjYWNoZSBjb250YWluaW5nIHRoZSBsaXN0LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbGlzdE5hbWUgLSBUaGUgbGlzdCB0byByZXRhaW4gYSBzbGljZSBvZi5cbiAgICogQHBhcmFtIHtMaXN0UmV0YWluQ2FsbE9wdGlvbnN9IFtvcHRpb25zXVxuICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuc3RhcnRJbmRleF0gLSBTdGFydCBpbmNsdXNpdmUgaW5kZXggZm9yIGZldGNoXG4gICAqIG9wZXJhdGlvbi4gRGVmYXVsdHMgdG8gc3RhcnQgb2YgYXJyYXkgaWYgbm90IGdpdmVuLCAwLlxuICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuZW5kSW5kZXhdIC0gRW5kIGV4Y2x1c2l2ZSBpbmRleCBmb3IgZmV0Y2hcbiAgICogb3BlcmF0aW9uLiBEZWZhdWx0cyB0byBlbmQgb2YgYXJyYXkgaWYgbm90IGdpdmVuLlxuICAgKiBAcGFyYW0ge0NvbGxlY3Rpb25UdGx9IFtvcHRpb25zLnR0bF0gLSBIb3cgdGhlIFRUTCBzaG91bGQgYmUgbWFuYWdlZC5cbiAgICogUmVmcmVzaGVzIHRoZSBsaXN0J3MgVFRMIHVzaW5nIHRoZSBjbGllbnQncyBkZWZhdWx0IGlmIHRoaXMgaXMgbm90XG4gICAqIHN1cHBsaWVkLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxDYWNoZUxpc3RSZXRhaW4uUmVzcG9uc2U+fSAtXG4gICAqIHtAbGluayBDYWNoZUxpc3RSZXRhaW4uU3VjY2Vzc30gb24gc3VjY2Vzcy5cbiAgICoge0BsaW5rIENhY2hlTGlzdFJldGFpbi5FcnJvcn0gb24gZmFpbHVyZS5cbiAgICovXG4gIHB1YmxpYyBhc3luYyBsaXN0UmV0YWluKFxuICAgIGNhY2hlTmFtZTogc3RyaW5nLFxuICAgIGxpc3ROYW1lOiBzdHJpbmcsXG4gICAgb3B0aW9ucz86IExpc3RSZXRhaW5DYWxsT3B0aW9uc1xuICApOiBQcm9taXNlPENhY2hlTGlzdFJldGFpbi5SZXNwb25zZT4ge1xuICAgIGNvbnN0IGNsaWVudCA9IHRoaXMuZ2V0TmV4dERhdGFDbGllbnQoKTtcbiAgICByZXR1cm4gYXdhaXQgY2xpZW50Lmxpc3RSZXRhaW4oXG4gICAgICBjYWNoZU5hbWUsXG4gICAgICBsaXN0TmFtZSxcbiAgICAgIG9wdGlvbnM/LnN0YXJ0SW5kZXgsXG4gICAgICBvcHRpb25zPy5lbmRJbmRleCxcbiAgICAgIG9wdGlvbnM/LnR0bFxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2hlcyBhbGwgZWxlbWVudHMgb2YgdGhlIGdpdmVuIHNldFxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2FjaGVOYW1lIC0gVGhlIGNhY2hlIGNvbnRhaW5pbmcgdGhlIHNldC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHNldE5hbWUgLSBUaGUgc2V0IHRvIGZldGNoLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxDYWNoZVNldEZldGNoLlJlc3BvbnNlPn0gLVxuICAgKiB7QGxpbmsgQ2FjaGVTZXRGZXRjaC5IaXR9IGNvbnRhaW5pbmcgdGhlIHNldCBlbGVtZW50cyBpZiB0aGUgc2V0IGV4aXN0cy5cbiAgICoge0BsaW5rIENhY2hlU2V0RmV0Y2guTWlzc30gaWYgdGhlIHNldCBkb2VzIG5vdCBleGlzdC5cbiAgICoge0BsaW5rIENhY2hlU2V0RmV0Y2guRXJyb3J9IG9uIGZhaWx1cmUuXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgc2V0RmV0Y2goXG4gICAgY2FjaGVOYW1lOiBzdHJpbmcsXG4gICAgc2V0TmFtZTogc3RyaW5nXG4gICk6IFByb21pc2U8Q2FjaGVTZXRGZXRjaC5SZXNwb25zZT4ge1xuICAgIGNvbnN0IGNsaWVudCA9IHRoaXMuZ2V0TmV4dERhdGFDbGllbnQoKTtcbiAgICByZXR1cm4gYXdhaXQgY2xpZW50LnNldEZldGNoKGNhY2hlTmFtZSwgc2V0TmFtZSk7XG4gIH1cblxuICAvKipcbiAgICogQWRkcyBhbiBlbGVtZW50IHRvIHRoZSBnaXZlbiBzZXQuIENyZWF0ZXMgdGhlIHNldCBpZiBpdCBkb2VzIG5vdCBhbHJlYWR5XG4gICAqIGV4aXN0LlxuICAgKlxuICAgKiBAcmVtYXJrc1xuICAgKiBBZnRlciB0aGlzIG9wZXJhdGlvbiB0aGUgc2V0IHdpbGwgY29udGFpbiB0aGUgdW5pb24gb2YgdGhlIGVsZW1lbnQgcGFzc2VkXG4gICAqIGluIGFuZCB0aGUgb3JpZ2luYWwgZWxlbWVudHMgb2YgdGhlIHNldC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNhY2hlTmFtZSAtIFRoZSBjYWNoZSB0byBzdG9yZSB0aGUgc2V0IGluLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc2V0TmFtZSAtIFRoZSBzZXQgdG8gYWRkIHRvLlxuICAgKiBAcGFyYW0ge3N0cmluZyB8IFVpbnQ4QXJyYXl9IGVsZW1lbnQgLSBUaGUgZWxlbWVudCB0byBhZGQuXG4gICAqIEBwYXJhbSB7U2V0QWRkRWxlbWVudE9wdGlvbnN9IG9wdGlvbnNcbiAgICogQHBhcmFtIHtDb2xsZWN0aW9uVHRsfSBbb3B0aW9ucy50dGxdIC0gSG93IHRoZSBUVEwgc2hvdWxkIGJlIG1hbmFnZWQuXG4gICAqIFJlZnJlc2hlcyB0aGUgc2V0J3MgVFRMIHVzaW5nIHRoZSBjbGllbnQncyBkZWZhdWx0IGlmIHRoaXMgaXMgbm90IHN1cHBsaWVkLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxDYWNoZVNldEFkZEVsZW1lbnQuUmVzcG9uc2U+fSAtXG4gICAqIHtAbGluayBDYWNoZVNldEFkZEVsZW1lbnQuU3VjY2Vzc30gb24gc3VjY2Vzcy5cbiAgICoge0BsaW5rIENhY2hlU2V0QWRkRWxlbWVudC5FcnJvcn0gb24gZmFpbHVyZS5cbiAgICovXG4gIHB1YmxpYyBhc3luYyBzZXRBZGRFbGVtZW50KFxuICAgIGNhY2hlTmFtZTogc3RyaW5nLFxuICAgIHNldE5hbWU6IHN0cmluZyxcbiAgICBlbGVtZW50OiBzdHJpbmcgfCBVaW50OEFycmF5LFxuICAgIG9wdGlvbnM/OiBTZXRBZGRFbGVtZW50T3B0aW9uc1xuICApOiBQcm9taXNlPENhY2hlU2V0QWRkRWxlbWVudC5SZXNwb25zZT4ge1xuICAgIHJldHVybiAoXG4gICAgICBhd2FpdCB0aGlzLnNldEFkZEVsZW1lbnRzKFxuICAgICAgICBjYWNoZU5hbWUsXG4gICAgICAgIHNldE5hbWUsXG4gICAgICAgIFtlbGVtZW50XSBhcyBzdHJpbmdbXSB8IFVpbnQ4QXJyYXlbXSxcbiAgICAgICAgb3B0aW9uc1xuICAgICAgKVxuICAgICkudG9TaW5ndWxhclJlc3BvbnNlKCk7XG4gIH1cblxuICAvKipcbiAgICogQWRkcyBtdWx0aXBsZSBlbGVtZW50cyB0byB0aGUgZ2l2ZW4gc2V0LiBDcmVhdGVzIHRoZSBzZXQgaWYgaXQgZG9lcyBub3RcbiAgICogYWxyZWFkeSBleGlzdC5cbiAgICpcbiAgICogQHJlbWFya3NcbiAgICogQWZ0ZXIgdGhpcyBvcGVyYXRpb24sIHRoZSBzZXQgd2lsbCBjb250YWluIHRoZSB1bmlvbiBvZiB0aGUgZWxlbWVudHMgcGFzc2VkXG4gICAqIGluIGFuZCB0aGUgb3JpZ2luYWwgZWxlbWVudHMgb2YgdGhlIHNldC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNhY2hlTmFtZSAtIFRoZSBjYWNoZSB0byBzdG9yZSB0aGUgc2V0IGluLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc2V0TmFtZSAtIFRoZSBzZXQgdG8gYWRkIHRvLlxuICAgKiBAcGFyYW0ge3N0cmluZ1tdIHwgVWludDhBcnJheVtdfSBlbGVtZW50cyAtIFRoZSBlbGVtZW50cyB0byBhZGQuXG4gICAqIEBwYXJhbSB7U2V0QWRkRWxlbWVudHNPcHRpb25zfSBvcHRpb25zXG4gICAqIEBwYXJhbSB7Q29sbGVjdGlvblR0bH0gW29wdGlvbnMudHRsXSAtIEhvdyB0aGUgVFRMIHNob3VsZCBiZSBtYW5hZ2VkLlxuICAgKiBSZWZyZXNoZXMgdGhlIHNldCdzIFRUTCB1c2luZyB0aGUgY2xpZW50J3MgZGVmYXVsdCBpZiB0aGlzIGlzIG5vdCBzdXBwbGllZC5cbiAgICogQHJldHVybnMge1Byb21pc2U8Q2FjaGVTZXRBZGRFbGVtZW50cy5SZXNwb25zZT59IC1cbiAgICoge0BsaW5rIENhY2hlU2V0QWRkRWxlbWVudHMuU3VjY2Vzc30gb24gc3VjY2Vzcy5cbiAgICoge0BsaW5rIENhY2hlU2V0QWRkRWxlbWVudHMuRXJyb3J9IG9uIGZhaWx1cmUuXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgc2V0QWRkRWxlbWVudHMoXG4gICAgY2FjaGVOYW1lOiBzdHJpbmcsXG4gICAgc2V0TmFtZTogc3RyaW5nLFxuICAgIGVsZW1lbnRzOiBzdHJpbmdbXSB8IFVpbnQ4QXJyYXlbXSxcbiAgICBvcHRpb25zPzogU2V0QWRkRWxlbWVudHNPcHRpb25zXG4gICk6IFByb21pc2U8Q2FjaGVTZXRBZGRFbGVtZW50cy5SZXNwb25zZT4ge1xuICAgIGNvbnN0IGNsaWVudCA9IHRoaXMuZ2V0TmV4dERhdGFDbGllbnQoKTtcbiAgICByZXR1cm4gYXdhaXQgY2xpZW50LnNldEFkZEVsZW1lbnRzKFxuICAgICAgY2FjaGVOYW1lLFxuICAgICAgc2V0TmFtZSxcbiAgICAgIGVsZW1lbnRzLFxuICAgICAgb3B0aW9ucz8udHRsXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGFuIGVsZW1lbnQgZnJvbSB0aGUgZ2l2ZW4gc2V0LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2FjaGVOYW1lIC0gVGhlIGNhY2hlIGNvbnRhaW5pbmcgdGhlIHNldC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHNldE5hbWUgLSBUaGUgc2V0IHRvIHJlbW92ZSBmcm9tLlxuICAgKiBAcGFyYW0ge3N0cmluZyB8IFVpbnQ4QXJyYXl9IGVsZW1lbnQgLSBUaGUgZWxlbWVudCB0byByZW1vdmUuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPENhY2hlU2V0UmVtb3ZlRWxlbWVudC5SZXNwb25zZT59IC1cbiAgICoge0BsaW5rIENhY2hlU2V0UmVtb3ZlRWxlbWVudC5TdWNjZXNzfSBvbiBzdWNjZXNzLiBSZW1vdmluZyBhbiBlbGVtZW50IHRoYXRcbiAgICogZG9lcyBub3Qgb2NjdXIgaW4gdGhlIHNldCBvciByZW1vdmluZyBmcm9tIGEgbm9uLWV4aXN0ZW50IHNldCBjb3VudHMgYXMgYVxuICAgKiBzdWNjZXNzLlxuICAgKiB7QGxpbmsgQ2FjaGVTZXRSZW1vdmVFbGVtZW50LkVycm9yfSBvbiBmYWlsdXJlLlxuICAgKi9cbiAgcHVibGljIGFzeW5jIHNldFJlbW92ZUVsZW1lbnQoXG4gICAgY2FjaGVOYW1lOiBzdHJpbmcsXG4gICAgc2V0TmFtZTogc3RyaW5nLFxuICAgIGVsZW1lbnQ6IHN0cmluZyB8IFVpbnQ4QXJyYXlcbiAgKTogUHJvbWlzZTxDYWNoZVNldFJlbW92ZUVsZW1lbnQuUmVzcG9uc2U+IHtcbiAgICByZXR1cm4gKFxuICAgICAgYXdhaXQgdGhpcy5zZXRSZW1vdmVFbGVtZW50cyhjYWNoZU5hbWUsIHNldE5hbWUsIFtlbGVtZW50XSBhc1xuICAgICAgICB8IHN0cmluZ1tdXG4gICAgICAgIHwgVWludDhBcnJheVtdKVxuICAgICkudG9TaW5ndWxhclJlc3BvbnNlKCk7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlcyBtdWx0aXBsZSBlbGVtZW50cyBmcm9tIHRoZSBnaXZlbiBzZXQuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjYWNoZU5hbWUgLSBUaGUgY2FjaGUgY29udGFpbmluZyB0aGUgc2V0LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc2V0TmFtZSAtIFRoZSBzZXQgdG8gcmVtb3ZlIGZyb20uXG4gICAqIEBwYXJhbSB7c3RyaW5nW10gfCBVaW50OEFycmF5W119IGVsZW1lbnRzIC0gVGhlIGVsZW1lbnRzIHRvIHJlbW92ZS5cbiAgICogQHJldHVybnMge1Byb21pc2U8Q2FjaGVTZXRSZW1vdmVFbGVtZW50cy5SZXNwb25zZT59IC1cbiAgICoge0BsaW5rIENhY2hlU2V0UmVtb3ZlRWxlbWVudHMuU3VjY2Vzc30gb24gc3VjY2Vzcy4gUmVtb3ZpbmcgZWxlbWVudHMgdGhhdFxuICAgKiBkbyBub3Qgb2NjdXIgaW4gdGhlIHNldCBvciByZW1vdmluZyBmcm9tIGEgbm9uLWV4aXN0ZW50IHNldCBjb3VudHMgYXMgYVxuICAgKiBzdWNjZXNzLlxuICAgKiB7QGxpbmsgQ2FjaGVTZXRSZW1vdmVFbGVtZW50cy5FcnJvcn0gb24gZmFpbHVyZS5cbiAgICovXG4gIHB1YmxpYyBhc3luYyBzZXRSZW1vdmVFbGVtZW50cyhcbiAgICBjYWNoZU5hbWU6IHN0cmluZyxcbiAgICBzZXROYW1lOiBzdHJpbmcsXG4gICAgZWxlbWVudHM6IHN0cmluZ1tdIHwgVWludDhBcnJheVtdXG4gICk6IFByb21pc2U8Q2FjaGVTZXRSZW1vdmVFbGVtZW50cy5SZXNwb25zZT4ge1xuICAgIGNvbnN0IGNsaWVudCA9IHRoaXMuZ2V0TmV4dERhdGFDbGllbnQoKTtcbiAgICByZXR1cm4gYXdhaXQgY2xpZW50LnNldFJlbW92ZUVsZW1lbnRzKGNhY2hlTmFtZSwgc2V0TmFtZSwgZWxlbWVudHMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFzc29jaWF0ZXMgdGhlIGdpdmVuIGtleSB3aXRoIHRoZSBnaXZlbiB2YWx1ZS4gSWYgYSB2YWx1ZSBmb3IgdGhlIGtleSBpc1xuICAgKiBhbHJlYWR5IHByZXNlbnQgaXQgaXMgbm90IHJlcGxhY2VkIHdpdGggdGhlIG5ldyB2YWx1ZS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNhY2hlTmFtZSAtIFRoZSBjYWNoZSB0byBzdG9yZSB0aGUgdmFsdWUgaW4uXG4gICAqIEBwYXJhbSB7c3RyaW5nIHwgVWludDhBcnJheX0ga2V5IC0gVGhlIGtleSB0byBzZXQuXG4gICAqIEBwYXJhbSB7c3RyaW5nIHwgVWludDhBcnJheX0gZmllbGQgLSBUaGUgdmFsdWUgdG8gYmUgc3RvcmVkLlxuICAgKiBAcGFyYW0ge1NldElmTm90RXhpc3RzT3B0aW9uc30gW29wdGlvbnNdXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy50dGxdIC0gVGhlIHRpbWUgdG8gbGl2ZSBmb3IgdGhlIGl0ZW0gaW4gdGhlIGNhY2hlLlxuICAgKiBVc2VzIHRoZSBjbGllbnQncyBkZWZhdWx0IFRUTCBpZiB0aGlzIGlzIG5vdCBzdXBwbGllZC5cbiAgICogQHJldHVybnMge1Byb21pc2U8Q2FjaGVTZXRJZk5vdEV4aXN0cy5SZXNwb25zZT59IC1cbiAgICoge0BsaW5rIENhY2hlU2V0SWZOb3RFeGlzdHMuU3RvcmVkfSBvbiBzdG9yaW5nIHRoZSBuZXcgdmFsdWUuXG4gICAqIHtAbGluayBDYWNoZVNldElmTm90RXhpc3RzLk5vdFN0b3JlZH0gb24gbm90IHN0b3JpbmcgdGhlIG5ldyB2YWx1ZS5cbiAgICoge0BsaW5rIENhY2hlU2V0SWZOb3RFeGlzdHMuRXJyb3J9IG9uIGZhaWx1cmUuXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgc2V0SWZOb3RFeGlzdHMoXG4gICAgY2FjaGVOYW1lOiBzdHJpbmcsXG4gICAga2V5OiBzdHJpbmcgfCBVaW50OEFycmF5LFxuICAgIGZpZWxkOiBzdHJpbmcgfCBVaW50OEFycmF5LFxuICAgIG9wdGlvbnM/OiBTZXRJZk5vdEV4aXN0c09wdGlvbnNcbiAgKTogUHJvbWlzZTxDYWNoZVNldElmTm90RXhpc3RzLlJlc3BvbnNlPiB7XG4gICAgY29uc3QgY2xpZW50ID0gdGhpcy5nZXROZXh0RGF0YUNsaWVudCgpO1xuICAgIHJldHVybiBhd2FpdCBjbGllbnQuc2V0SWZOb3RFeGlzdHMoY2FjaGVOYW1lLCBrZXksIGZpZWxkLCBvcHRpb25zPy50dGwpO1xuICB9XG5cbiAgLyoqXG4gICAqIEZsdXNoZXMgLyBjbGVhcnMgYWxsIHRoZSBpdGVtcyBvZiB0aGUgZ2l2ZW4gY2FjaGVcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNhY2hlTmFtZSAtIFRoZSBjYWNoZSB0byBiZSBmbHVzaGVkLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxDYWNoZUZsdXNoLlJlc3BvbnNlPn0gLVxuICAgKiB7QGxpbmsgQ2FjaGVGbHVzaC5TdWNjZXNzfSBvbiBzdWNjZXNzLlxuICAgKiB7QGxpbmsgQ2FjaGVGbHVzaC5FcnJvcn0gb24gZmFpbHVyZS5cbiAgICovXG4gIHB1YmxpYyBhc3luYyBmbHVzaENhY2hlKGNhY2hlTmFtZTogc3RyaW5nKTogUHJvbWlzZTxDYWNoZUZsdXNoLlJlc3BvbnNlPiB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuY29udHJvbENsaWVudC5mbHVzaENhY2hlKGNhY2hlTmFtZSk7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2hlcyBhbGwgZWxlbWVudHMgb2YgdGhlIGdpdmVuIGRpY3Rpb25hcnkuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjYWNoZU5hbWUgLSBUaGUgY2FjaGUgdG8gcGVyZm9ybSB0aGUgbG9va3VwIGluLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZGljdGlvbmFyeU5hbWUgLSBUaGUgZGljdGlvbmFyeSB0byBmZXRjaC5cbiAgICogQHJldHVybnMge1Byb21pc2U8Q2FjaGVEaWN0aW9uYXJ5RmV0Y2guUmVzcG9uc2U+fSAtXG4gICAqIHtAbGluayBDYWNoZURpY3Rpb25hcnlGZXRjaC5IaXR9IGNvbnRhaW5pbmcgdGhlIGRpY3Rpb25hcnkgZWxlbWVudHMgaWYgdGhlXG4gICAqIGRpY3Rpb25hcnkgZXhpc3RzLlxuICAgKiB7QGxpbmsgQ2FjaGVEaWN0aW9uYXJ5RmV0Y2guTWlzc30gaWYgdGhlIGRpY3Rpb25hcnkgZG9lcyBub3QgZXhpc3QuXG4gICAqIHtAbGluayBDYWNoZURpY3Rpb25hcnlGZXRjaC5FcnJvcn0gb24gZmFpbHVyZS5cbiAgICovXG4gIHB1YmxpYyBhc3luYyBkaWN0aW9uYXJ5RmV0Y2goXG4gICAgY2FjaGVOYW1lOiBzdHJpbmcsXG4gICAgZGljdGlvbmFyeU5hbWU6IHN0cmluZ1xuICApOiBQcm9taXNlPENhY2hlRGljdGlvbmFyeUZldGNoLlJlc3BvbnNlPiB7XG4gICAgY29uc3QgY2xpZW50ID0gdGhpcy5nZXROZXh0RGF0YUNsaWVudCgpO1xuICAgIHJldHVybiBhd2FpdCBjbGllbnQuZGljdGlvbmFyeUZldGNoKGNhY2hlTmFtZSwgZGljdGlvbmFyeU5hbWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgYW4gaW50ZWdlciBxdWFudGl0eSB0byBhIGZpZWxkIHZhbHVlLlxuICAgKlxuICAgKiBAcmVtYXJrc1xuICAgKiBJbmNyZW1lbnRpbmcgdGhlIHZhbHVlIG9mIGEgbWlzc2luZyBmaWVsZCBzZXRzIHRoZSB2YWx1ZSB0byBhbW91bnQuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjYWNoZU5hbWUgLSBUaGUgY2FjaGUgY29udGFpbmluZyB0aGUgZmllbGQuXG4gICAqIEBwYXJhbSB7c3RyaW5nIHwgVWludDhBcnJheX0gZmllbGQgLSBUaGUgZmllbGQgdG8gaW5jcmVtZW50LlxuICAgKiBAcGFyYW0ge251bWJlcn0gYW1vdW50IC0gVGhlIHF1YW50aXR5IHRvIGFkZCB0byB0aGUgdmFsdWUuIE1heSBiZSBwb3NpdGl2ZSxcbiAgICogbmVnYXRpdmUsIG9yIHplcm8uIERlZmF1bHRzIHRvIDEuXG4gICAqIEBwYXJhbSB7SW5jcmVtZW50T3B0aW9uc30gb3B0aW9uc1xuICAgKiBAcGFyYW0ge0NvbGxlY3Rpb25UdGx9IFtvcHRpb25zLnR0bF0gLSBIb3cgdGhlIFRUTCBzaG91bGQgYmUgbWFuYWdlZC5cbiAgICogQHJldHVybnMge1Byb21pc2U8Q2FjaGVJbmNyZW1lbnQ+fSAtXG4gICAqIHtAbGluayBDYWNoZUluY3JlbWVudC5TdWNjZXNzfSBjb250YWluaW5nIHRoZSBpbmNyZW1lbnRlZCB2YWx1ZVxuICAgKiBvbiBzdWNjZXNzLlxuICAgKiB7QGxpbmsgQ2FjaGVJbmNyZW1lbnQuRXJyb3J9IG9uIGZhaWx1cmUuIEluY3JlbWVudGluZyBhIHZhbHVlXG4gICAqIHRoYXQgd2FzIG5vdCBzZXQgdXNpbmcgdGhpcyBtZXRob2Qgb3IgaXMgbm90IHRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2ZcbiAgICogYW4gaW50ZWdlciByZXN1bHRzIGluIGEgZmFpbHVyZSB3aXRoIGEgRmFpbGVkUHJlY29uZGl0aW9uRXhjZXB0aW9uIGVycm9yLlxuICAgKi9cbiAgcHVibGljIGFzeW5jIGluY3JlbWVudChcbiAgICBjYWNoZU5hbWU6IHN0cmluZyxcbiAgICBmaWVsZDogc3RyaW5nIHwgVWludDhBcnJheSxcbiAgICBhbW91bnQgPSAxLFxuICAgIG9wdGlvbnM/OiBJbmNyZW1lbnRPcHRpb25zXG4gICk6IFByb21pc2U8Q2FjaGVJbmNyZW1lbnQuUmVzcG9uc2U+IHtcbiAgICBjb25zdCBjbGllbnQgPSB0aGlzLmdldE5leHREYXRhQ2xpZW50KCk7XG4gICAgcmV0dXJuIGF3YWl0IGNsaWVudC5pbmNyZW1lbnQoY2FjaGVOYW1lLCBmaWVsZCwgYW1vdW50LCBvcHRpb25zPy50dGwpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgYW4gZWxlbWVudCB0byB0aGUgZ2l2ZW4gZGljdGlvbmFyeS4gQ3JlYXRlcyB0aGUgZGljdGlvbmFyeSBpZiBpdCBkb2VzXG4gICAqIG5vdCBhbHJlYWR5IGV4aXN0LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2FjaGVOYW1lIC0gVGhlIGNhY2hlIHRvIHN0b3JlIHRoZSBkaWN0aW9uYXJ5IGluLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZGljdGlvbmFyeU5hbWUgLSBUaGUgZGljdGlvbmFyeSB0byBhZGQgdG8uXG4gICAqIEBwYXJhbSB7c3RyaW5nIHwgVWludDhBcnJheX0gZmllbGQgLSBUaGUgZmllbGQgdG8gc2V0LlxuICAgKiBAcGFyYW0ge3N0cmluZyB8IFVpbnQ4QXJyYXl9IHZhbHVlIC0gVGhlIHZhbHVlIHRvIHN0b3JlLlxuICAgKiBAcGFyYW0ge0RpY3Rpb25hcnlTZXRGaWVsZE9wdGlvbnN9IG9wdGlvbnNcbiAgICogQHBhcmFtIHtDb2xsZWN0aW9uVHRsfSBbb3B0aW9ucy50dGxdIC0gSG93IHRoZSBUVEwgc2hvdWxkIGJlIG1hbmFnZWQuXG4gICAqIFJlZnJlc2hlcyB0aGUgZGljdGlvbmFyeSdzIFRUTCB1c2luZyB0aGUgY2xpZW50J3MgZGVmYXVsdCBpZiB0aGlzIGlzIG5vdFxuICAgKiBzdXBwbGllZC5cbiAgICogQHJldHVybnMge1Byb21pc2U8Q2FjaGVEaWN0aW9uYXJ5U2V0RmllbGQuUmVzcG9uc2U+fSAtXG4gICAqIHtAbGluayBDYWNoZURpY3Rpb25hcnlTZXRGaWVsZC5TdWNjZXNzfSBvbiBzdWNjZXNzLlxuICAgKiB7QGxpbmsgQ2FjaGVEaWN0aW9uYXJ5U2V0RmllbGQuRXJyb3J9IG9uIGZhaWx1cmUuXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgZGljdGlvbmFyeVNldEZpZWxkKFxuICAgIGNhY2hlTmFtZTogc3RyaW5nLFxuICAgIGRpY3Rpb25hcnlOYW1lOiBzdHJpbmcsXG4gICAgZmllbGQ6IHN0cmluZyB8IFVpbnQ4QXJyYXksXG4gICAgdmFsdWU6IHN0cmluZyB8IFVpbnQ4QXJyYXksXG4gICAgb3B0aW9ucz86IERpY3Rpb25hcnlTZXRGaWVsZE9wdGlvbnNcbiAgKTogUHJvbWlzZTxDYWNoZURpY3Rpb25hcnlTZXRGaWVsZC5SZXNwb25zZT4ge1xuICAgIGNvbnN0IGNsaWVudCA9IHRoaXMuZ2V0TmV4dERhdGFDbGllbnQoKTtcbiAgICByZXR1cm4gYXdhaXQgY2xpZW50LmRpY3Rpb25hcnlTZXRGaWVsZChcbiAgICAgIGNhY2hlTmFtZSxcbiAgICAgIGRpY3Rpb25hcnlOYW1lLFxuICAgICAgZmllbGQsXG4gICAgICB2YWx1ZSxcbiAgICAgIG9wdGlvbnM/LnR0bFxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogQWRkcyBtdWx0aXBsZSBlbGVtZW50cyB0byB0aGUgZ2l2ZW4gZGljdGlvbmFyeS4gQ3JlYXRlcyB0aGUgZGljdGlvbmFyeSBpZlxuICAgKiBpdCBkb2VzIG5vdCBhbHJlYWR5IGV4aXN0LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2FjaGVOYW1lIC0gVGhlIGNhY2hlIHRvIHN0b3JlIHRoZSBkaWN0aW9uYXJ5IGluLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZGljdGlvbmFyeU5hbWUgLSBUaGUgZGljdGlvbmFyeSB0byBhZGQgdG8uXG4gICAqIEBwYXJhbSB7TWFwPHN0cmluZyB8IFVpbnQ4QXJyYXksIHN0cmluZyB8IFVpbnQ4QXJyYXk+fSBlbGVtZW50cyAtIFRoZVxuICAgKiBlbGVtZW50cyB0byBzZXQuXG4gICAqIEBwYXJhbSB7RGljdGlvbmFyeVNldEZpZWxkc09wdGlvbnN9IG9wdGlvbnNcbiAgICogQHBhcmFtIHtDb2xsZWN0aW9uVHRsfSBbb3B0aW9ucy50dGxdIC0gSG93IHRoZSBUVEwgc2hvdWxkIGJlIG1hbmFnZWQuXG4gICAqIFJlZnJlc2hlcyB0aGUgZGljdGlvbmFyeSdzIFRUTCB1c2luZyB0aGUgY2xpZW50J3MgZGVmYXVsdCBpZiB0aGlzIGlzIG5vdFxuICAgKiBzdXBwbGllZC5cbiAgICogQHJldHVybnMge1Byb21pc2U8Q2FjaGVEaWN0aW9uYXJ5U2V0RmllbGRzLlJlc3BvbnNlPn0gLVxuICAgKiB7QGxpbmsgQ2FjaGVEaWN0aW9uYXJ5U2V0RmllbGRzLlN1Y2Nlc3N9IG9uIHN1Y2Nlc3MuXG4gICAqIHtAbGluayBDYWNoZURpY3Rpb25hcnlTZXRGaWVsZHMuRXJyb3J9IG9uIGZhaWx1cmUuXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgZGljdGlvbmFyeVNldEZpZWxkcyhcbiAgICBjYWNoZU5hbWU6IHN0cmluZyxcbiAgICBkaWN0aW9uYXJ5TmFtZTogc3RyaW5nLFxuICAgIGVsZW1lbnRzOlxuICAgICAgfCBNYXA8c3RyaW5nIHwgVWludDhBcnJheSwgc3RyaW5nIHwgVWludDhBcnJheT5cbiAgICAgIHwgUmVjb3JkPHN0cmluZywgc3RyaW5nIHwgVWludDhBcnJheT4sXG4gICAgb3B0aW9ucz86IERpY3Rpb25hcnlTZXRGaWVsZE9wdGlvbnNcbiAgKTogUHJvbWlzZTxDYWNoZURpY3Rpb25hcnlTZXRGaWVsZHMuUmVzcG9uc2U+IHtcbiAgICBjb25zdCBjbGllbnQgPSB0aGlzLmdldE5leHREYXRhQ2xpZW50KCk7XG4gICAgcmV0dXJuIGF3YWl0IGNsaWVudC5kaWN0aW9uYXJ5U2V0RmllbGRzKFxuICAgICAgY2FjaGVOYW1lLFxuICAgICAgZGljdGlvbmFyeU5hbWUsXG4gICAgICBlbGVtZW50cyxcbiAgICAgIG9wdGlvbnM/LnR0bFxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgdmFsdWUgc3RvcmVkIGZvciB0aGUgZ2l2ZW4gZGljdGlvbmFyeSBhbmQgZmllbGQuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjYWNoZU5hbWUgLSBUaGUgY2FjaGUgY29udGFpbmluZyB0aGUgZGljdGlvbmFyeS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGRpY3Rpb25hcnlOYW1lIC0gVGhlIGRpY3Rpb25hcnkgdG8gbG9vayB1cC5cbiAgICogQHBhcmFtIHtzdHJpbmcgfCBVaW50OEFycmF5fSBmaWVsZCAtIFRoZSBmaWVsZCB0byBsb29rIHVwLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxDYWNoZURpY3Rpb25hcnlHZXRGaWVsZC5SZXNwb25zZT59IC1cbiAgICoge0BsaW5rIENhY2hlRGljdGlvbmFyeUdldEZpZWxkLkhpdH0gY29udGFpbmluZyB0aGUgZGljdGlvbmFyeSBlbGVtZW50IGlmXG4gICAqIG9uZSBpcyBmb3VuZC5cbiAgICoge0BsaW5rIENhY2hlRGljdGlvbmFyeUdldEZpZWxkLk1pc3N9IGlmIHRoZSBkaWN0aW9uYXJ5IGRvZXMgbm90IGV4aXN0LlxuICAgKiB7QGxpbmsgQ2FjaGVEaWN0aW9uYXJ5R2V0RmllbGQuRXJyb3J9IG9uIGZhaWx1cmUuXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgZGljdGlvbmFyeUdldEZpZWxkKFxuICAgIGNhY2hlTmFtZTogc3RyaW5nLFxuICAgIGRpY3Rpb25hcnlOYW1lOiBzdHJpbmcsXG4gICAgZmllbGQ6IHN0cmluZyB8IFVpbnQ4QXJyYXlcbiAgKTogUHJvbWlzZTxDYWNoZURpY3Rpb25hcnlHZXRGaWVsZC5SZXNwb25zZT4ge1xuICAgIGNvbnN0IGNsaWVudCA9IHRoaXMuZ2V0TmV4dERhdGFDbGllbnQoKTtcbiAgICByZXR1cm4gYXdhaXQgY2xpZW50LmRpY3Rpb25hcnlHZXRGaWVsZChjYWNoZU5hbWUsIGRpY3Rpb25hcnlOYW1lLCBmaWVsZCk7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyBtdWx0aXBsZSB2YWx1ZXMgZnJvbSB0aGUgZ2l2ZW4gZGljdGlvbmFyeS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNhY2hlTmFtZSAtIFRoZSBjYWNoZSBjb250YWluaW5nIHRoZSBkaWN0aW9uYXJ5LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZGljdGlvbmFyeU5hbWUgLSBUaGUgZGljdGlvbmFyeSB0byBsb29rIHVwLlxuICAgKiBAcGFyYW0ge3N0cmluZ1tdIHwgVWludDhBcnJheVtdfSBmaWVsZHMgLSBUaGUgZmllbGRzIHRvIGxvb2sgdXAuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPENhY2hlRGljdGlvbmFyeUdldEZpZWxkcy5SZXNwb25zZT59IC1cbiAgICoge0BsaW5rIENhY2hlRGljdGlvbmFyeUdldEZpZWxkcy5IaXR9IGNvbnRhaW5pbmcgdGhlIGRpY3Rpb25hcnkgZWxlbWVudHMgaWZcbiAgICogdGhlIGRpY3Rpb25hcnkgZXhpc3RzLlxuICAgKiB7QGxpbmsgQ2FjaGVEaWN0aW9uYXJ5R2V0RmllbGRzLk1pc3N9IGlmIHRoZSBkaWN0aW9uYXJ5IGRvZXMgbm90IGV4aXN0LlxuICAgKiB7QGxpbmsgQ2FjaGVEaWN0aW9uYXJ5R2V0RmllbGRzLkVycm9yfSBvbiBmYWlsdXJlLlxuICAgKi9cbiAgcHVibGljIGFzeW5jIGRpY3Rpb25hcnlHZXRGaWVsZHMoXG4gICAgY2FjaGVOYW1lOiBzdHJpbmcsXG4gICAgZGljdGlvbmFyeU5hbWU6IHN0cmluZyxcbiAgICBmaWVsZHM6IHN0cmluZ1tdIHwgVWludDhBcnJheVtdXG4gICk6IFByb21pc2U8Q2FjaGVEaWN0aW9uYXJ5R2V0RmllbGRzLlJlc3BvbnNlPiB7XG4gICAgY29uc3QgY2xpZW50ID0gdGhpcy5nZXROZXh0RGF0YUNsaWVudCgpO1xuICAgIHJldHVybiBhd2FpdCBjbGllbnQuZGljdGlvbmFyeUdldEZpZWxkcyhjYWNoZU5hbWUsIGRpY3Rpb25hcnlOYW1lLCBmaWVsZHMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgYW4gZWxlbWVudCBmcm9tIHRoZSBnaXZlbiBkaWN0aW9uYXJ5LlxuICAgKlxuICAgKiBAcmVtYXJrc1xuICAgKiBQZXJmb3JtcyBhIG5vLW9wIGlmIHRoZSBkaWN0aW9uYXJ5IG9yIGZpZWxkIGRvZXMgbm90IGV4aXN0LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2FjaGVOYW1lIC0gVGhlIGNhY2hlIGNvbnRhaW5pbmcgdGhlIGRpY3Rpb25hcnkuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBkaWN0aW9uYXJ5TmFtZSAtIFRoZSBkaWN0aW9uYXJ5IHRvIHJlbW92ZSBmcm9tLlxuICAgKiBAcGFyYW0ge3N0cmluZyB8IFVpbnQ4QXJyYXl9IGZpZWxkIC0gVGhlIGZpZWxkIHRvIHJlbW92ZS5cbiAgICogQHJldHVybnMge1Byb21pc2U8Q2FjaGVEaWN0aW9uYXJ5UmVtb3ZlRmllbGQuUmVzcG9uc2U+fSAtXG4gICAqIHtAbGluayBDYWNoZURpY3Rpb25hcnlSZW1vdmVGaWVsZC5TdWNjZXNzfSBvbiBzdWNjZXNzLlxuICAgKiB7QGxpbmsgQ2FjaGVEaWN0aW9uYXJ5UmVtb3ZlRmllbGQuRXJyb3J9IG9uIGZhaWx1cmUuXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgZGljdGlvbmFyeVJlbW92ZUZpZWxkKFxuICAgIGNhY2hlTmFtZTogc3RyaW5nLFxuICAgIGRpY3Rpb25hcnlOYW1lOiBzdHJpbmcsXG4gICAgZmllbGQ6IHN0cmluZyB8IFVpbnQ4QXJyYXlcbiAgKTogUHJvbWlzZTxDYWNoZURpY3Rpb25hcnlSZW1vdmVGaWVsZC5SZXNwb25zZT4ge1xuICAgIGNvbnN0IGNsaWVudCA9IHRoaXMuZ2V0TmV4dERhdGFDbGllbnQoKTtcbiAgICByZXR1cm4gYXdhaXQgY2xpZW50LmRpY3Rpb25hcnlSZW1vdmVGaWVsZChjYWNoZU5hbWUsIGRpY3Rpb25hcnlOYW1lLCBmaWVsZCk7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlcyBtdWx0aXBsZSBmaWVsZHMgZnJvbSB0aGUgZ2l2ZW4gZGljdGlvbmFyeS5cbiAgICpcbiAgICogQHJlbWFya3NcbiAgICogUGVyZm9ybXMgYSBuby1vcCBpZiB0aGUgZGljdGlvbmFyeSBvciBmaWVsZHMgZG8gbm90IGV4aXN0LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2FjaGVOYW1lIC0gVGhlIGNhY2hlIGNvbnRhaW5pbmcgdGhlIGRpY3Rpb25hcnkuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBkaWN0aW9uYXJ5TmFtZSAtIFRoZSBkaWN0aW9uYXJ5IHRvIHJlbW92ZSBmcm9tLlxuICAgKiBAcGFyYW0ge3N0cmluZ1tdIHwgVWludDhBcnJheVtdfSBmaWVsZHMgLSBUaGUgZmllbGRzIHRvIHJlbW92ZS5cbiAgICogQHJldHVybnMge1Byb21pc2U8Q2FjaGVEaWN0aW9uYXJ5UmVtb3ZlRmllbGRzLlJlc3BvbnNlPn0gLVxuICAgKiB7QGxpbmsgQ2FjaGVEaWN0aW9uYXJ5UmVtb3ZlRmllbGRzLlN1Y2Nlc3N9IG9uIHN1Y2Nlc3MuXG4gICAqIHtAbGluayBDYWNoZURpY3Rpb25hcnlSZW1vdmVGaWVsZHMuRXJyb3J9IG9uIGZhaWx1cmUuXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgZGljdGlvbmFyeVJlbW92ZUZpZWxkcyhcbiAgICBjYWNoZU5hbWU6IHN0cmluZyxcbiAgICBkaWN0aW9uYXJ5TmFtZTogc3RyaW5nLFxuICAgIGZpZWxkczogc3RyaW5nW10gfCBVaW50OEFycmF5W11cbiAgKTogUHJvbWlzZTxDYWNoZURpY3Rpb25hcnlSZW1vdmVGaWVsZHMuUmVzcG9uc2U+IHtcbiAgICBjb25zdCBjbGllbnQgPSB0aGlzLmdldE5leHREYXRhQ2xpZW50KCk7XG4gICAgcmV0dXJuIGF3YWl0IGNsaWVudC5kaWN0aW9uYXJ5UmVtb3ZlRmllbGRzKFxuICAgICAgY2FjaGVOYW1lLFxuICAgICAgZGljdGlvbmFyeU5hbWUsXG4gICAgICBmaWVsZHNcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgYW4gaW50ZWdlciBxdWFudGl0eSB0byBhIGRpY3Rpb25hcnkgdmFsdWUuXG4gICAqXG4gICAqIEByZW1hcmtzXG4gICAqIEluY3JlbWVudGluZyB0aGUgdmFsdWUgb2YgYSBtaXNzaW5nIGZpZWxkIHNldHMgdGhlIHZhbHVlIHRvIGFtb3VudC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNhY2hlTmFtZSAtIFRoZSBjYWNoZSBjb250YWluaW5nIHRoZSBkaWN0aW9uYXJ5LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZGljdGlvbmFyeU5hbWUgLSBUaGUgZGljdGlvbmFyeSB0byBzZXQuXG4gICAqIEBwYXJhbSB7c3RyaW5nIHwgVWludDhBcnJheX0gZmllbGQgLSBUaGUgZmllbGQgdG8gaW5jcmVtZW50LlxuICAgKiBAcGFyYW0ge251bWJlcn0gYW1vdW50IC0gVGhlIHF1YW50aXR5IHRvIGFkZCB0byB0aGUgdmFsdWUuIE1heSBiZSBwb3NpdGl2ZSxcbiAgICogbmVnYXRpdmUsIG9yIHplcm8uIERlZmF1bHRzIHRvIDEuXG4gICAqIEBwYXJhbSB7RGljdGlvbmFyeUluY3JlbWVudE9wdGlvbnN9IG9wdGlvbnNcbiAgICogQHBhcmFtIHtDb2xsZWN0aW9uVHRsfSBbb3B0aW9ucy50dGxdIC0gSG93IHRoZSBUVEwgc2hvdWxkIGJlIG1hbmFnZWQuXG4gICAqIFJlZnJlc2hlcyB0aGUgZGljdGlvbmFyeSdzIFRUTCB1c2luZyB0aGUgY2xpZW50J3MgZGVmYXVsdCBpZiB0aGlzIGlzIG5vdFxuICAgKiBzdXBwbGllZC5cbiAgICogQHJldHVybnMge1Byb21pc2U8Q2FjaGVEaWN0aW9uYXJ5SW5jcmVtZW50LlJlc3BvbnNlPn0gLVxuICAgKiB7QGxpbmsgQ2FjaGVEaWN0aW9uYXJ5SW5jcmVtZW50LlN1Y2Nlc3N9IGNvbnRhaW5pbmcgdGhlIGluY3JlbWVudGVkIHZhbHVlXG4gICAqIG9uIHN1Y2Nlc3MuXG4gICAqIHtAbGluayBDYWNoZURpY3Rpb25hcnlJbmNyZW1lbnQuRXJyb3J9IG9uIGZhaWx1cmUuIEluY3JlbWVudGluZyBhIHZhbHVlXG4gICAqIHRoYXQgd2FzIG5vdCBzZXQgdXNpbmcgdGhpcyBtZXRob2Qgb3IgaXMgbm90IHRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2ZcbiAgICogYW4gaW50ZWdlciByZXN1bHRzIGluIGEgZmFpbHVyZSB3aXRoIGEgRmFpbGVkUHJlY29uZGl0aW9uRXhjZXB0aW9uIGVycm9yLlxuICAgKi9cbiAgcHVibGljIGFzeW5jIGRpY3Rpb25hcnlJbmNyZW1lbnQoXG4gICAgY2FjaGVOYW1lOiBzdHJpbmcsXG4gICAgZGljdGlvbmFyeU5hbWU6IHN0cmluZyxcbiAgICBmaWVsZDogc3RyaW5nIHwgVWludDhBcnJheSxcbiAgICBhbW91bnQgPSAxLFxuICAgIG9wdGlvbnM/OiBEaWN0aW9uYXJ5SW5jcmVtZW50T3B0aW9uc1xuICApOiBQcm9taXNlPENhY2hlRGljdGlvbmFyeUluY3JlbWVudC5SZXNwb25zZT4ge1xuICAgIGNvbnN0IGNsaWVudCA9IHRoaXMuZ2V0TmV4dERhdGFDbGllbnQoKTtcbiAgICByZXR1cm4gYXdhaXQgY2xpZW50LmRpY3Rpb25hcnlJbmNyZW1lbnQoXG4gICAgICBjYWNoZU5hbWUsXG4gICAgICBkaWN0aW9uYXJ5TmFtZSxcbiAgICAgIGZpZWxkLFxuICAgICAgYW1vdW50LFxuICAgICAgb3B0aW9ucz8udHRsXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIGFuIGVsZW1lbnQgdG8gdGhlIGdpdmVuIHNvcnRlZCBzZXQuIElmIHRoZSBlbGVtZW50IGFscmVhZHkgZXhpc3RzLCBpdHNcbiAgICogc2NvcmUgaXMgdXBkYXRlZC4gQ3JlYXRlcyB0aGUgc29ydGVkIHNldCBpZiBpdCBkb2VzIG5vdCBleGlzdC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNhY2hlTmFtZSAtIFRoZSBjYWNoZSBjb250YWluaW5nIHRoZSBzb3J0ZWQgc2V0LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc29ydGVkU2V0TmFtZSAtIFRoZSBzb3J0ZWQgc2V0IHRvIGFkZCB0by5cbiAgICogQHBhcmFtIHtzdHJpbmcgfCBVaW50OEFycmF5fSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBhZGQuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzY29yZSAtIFRoZSBzY29yZSB0byBhc3NpZ24gdG8gdGhlIHZhbHVlLlxuICAgKiBAcGFyYW0ge1NvcnRlZFNldFB1dEVsZW1lbnRPcHRpb25zfSBvcHRpb25zXG4gICAqIEBwYXJhbSB7Q29sbGVjdGlvblR0bH0gW29wdGlvbnMudHRsXSAtIEhvdyB0aGUgVFRMIHNob3VsZCBiZSBtYW5hZ2VkLlxuICAgKiBSZWZyZXNoZXMgdGhlIHNvcnRlZCBzZXQncyBUVEwgdXNpbmcgdGhlIGNsaWVudCdzIGRlZmF1bHQgaWYgdGhpcyBpcyBub3RcbiAgICogc3VwcGxpZWQuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPENhY2hlU29ydGVkU2V0UHV0RWxlbWVudC5SZXNwb25zZT59IC1cbiAgICoge0BsaW5rIENhY2hlU29ydGVkU2V0UHV0RWxlbWVudC5TdWNjZXNzfSBvbiBzdWNjZXNzLlxuICAgKiB7QGxpbmsgQ2FjaGVTb3J0ZWRTZXRQdXRFbGVtZW50LkVycm9yfSBvbiBmYWlsdXJlLlxuICAgKiBAcmV0dXJuc1xuICAgKi9cbiAgcHVibGljIGFzeW5jIHNvcnRlZFNldFB1dEVsZW1lbnQoXG4gICAgY2FjaGVOYW1lOiBzdHJpbmcsXG4gICAgc29ydGVkU2V0TmFtZTogc3RyaW5nLFxuICAgIHZhbHVlOiBzdHJpbmcgfCBVaW50OEFycmF5LFxuICAgIHNjb3JlOiBudW1iZXIsXG4gICAgb3B0aW9ucz86IFNvcnRlZFNldFB1dEVsZW1lbnRPcHRpb25zXG4gICk6IFByb21pc2U8Q2FjaGVTb3J0ZWRTZXRQdXRFbGVtZW50LlJlc3BvbnNlPiB7XG4gICAgY29uc3QgY2xpZW50ID0gdGhpcy5nZXROZXh0RGF0YUNsaWVudCgpO1xuICAgIHJldHVybiBhd2FpdCBjbGllbnQuc29ydGVkU2V0UHV0RWxlbWVudChcbiAgICAgIGNhY2hlTmFtZSxcbiAgICAgIHNvcnRlZFNldE5hbWUsXG4gICAgICB2YWx1ZSxcbiAgICAgIHNjb3JlLFxuICAgICAgb3B0aW9ucz8udHRsXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIGVsZW1lbnRzIHRvIHRoZSBnaXZlbiBzb3J0ZWQgc2V0LiBGb3IgYW55IHZhbHVlcyB0aGF0IGFscmVhZHkgZXhpc3QsIGl0XG4gICAqIHRoZSBzY29yZSBpcyB1cGRhdGVkLiBDcmVhdGVzIHRoZSBzb3J0ZWQgc2V0IGlmIGl0IGRvZXMgbm90IGV4aXN0LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2FjaGVOYW1lIC0gVGhlIGNhY2hlIGNvbnRhaW5pbmcgdGhlIHNvcnRlZCBzZXQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzb3J0ZWRTZXROYW1lIC0gVGhlIHNvcnRlZCBzZXQgdG8gYWRkIHRvLlxuICAgKiBAcGFyYW0ge01hcDxzdHJpbmcgfCBVaW50OEFycmF5LCBudW1iZXI+fCBSZWNvcmQ8c3RyaW5nLCBudW1iZXI+fSBlbGVtZW50cyAtIFRoZSB2YWx1ZS0+c2NvcmUgcGFpcnMgdG8gYWRkIHRvIHRoZSBzb3J0ZWQgc2V0LlxuICAgKiBAcGFyYW0ge1NvcnRlZFNldFB1dEVsZW1lbnRPcHRpb25zfSBvcHRpb25zXG4gICAqIEBwYXJhbSB7Q29sbGVjdGlvblR0bH0gW29wdGlvbnMudHRsXSAtIEhvdyB0aGUgVFRMIHNob3VsZCBiZSBtYW5hZ2VkLlxuICAgKiBSZWZyZXNoZXMgdGhlIHNvcnRlZCBzZXQncyBUVEwgdXNpbmcgdGhlIGNsaWVudCdzIGRlZmF1bHQgaWYgdGhpcyBpcyBub3RcbiAgICogc3VwcGxpZWQuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPENhY2hlU29ydGVkU2V0UHV0RWxlbWVudHMuUmVzcG9uc2U+fSAtXG4gICAqIHtAbGluayBDYWNoZVNvcnRlZFNldFB1dEVsZW1lbnRzLlN1Y2Nlc3N9IG9uIHN1Y2Nlc3MuXG4gICAqIHtAbGluayBDYWNoZVNvcnRlZFNldFB1dEVsZW1lbnRzLkVycm9yfSBvbiBmYWlsdXJlLlxuICAgKiBAcmV0dXJuc1xuICAgKi9cbiAgcHVibGljIGFzeW5jIHNvcnRlZFNldFB1dEVsZW1lbnRzKFxuICAgIGNhY2hlTmFtZTogc3RyaW5nLFxuICAgIHNvcnRlZFNldE5hbWU6IHN0cmluZyxcbiAgICBlbGVtZW50czogTWFwPHN0cmluZyB8IFVpbnQ4QXJyYXksIG51bWJlcj4gfCBSZWNvcmQ8c3RyaW5nLCBudW1iZXI+LFxuICAgIG9wdGlvbnM/OiBTb3J0ZWRTZXRQdXRFbGVtZW50c09wdGlvbnNcbiAgKTogUHJvbWlzZTxDYWNoZVNvcnRlZFNldFB1dEVsZW1lbnRzLlJlc3BvbnNlPiB7XG4gICAgY29uc3QgY2xpZW50ID0gdGhpcy5nZXROZXh0RGF0YUNsaWVudCgpO1xuICAgIHJldHVybiBhd2FpdCBjbGllbnQuc29ydGVkU2V0UHV0RWxlbWVudHMoXG4gICAgICBjYWNoZU5hbWUsXG4gICAgICBzb3J0ZWRTZXROYW1lLFxuICAgICAgZWxlbWVudHMsXG4gICAgICBvcHRpb25zPy50dGxcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIHRoZSBlbGVtZW50cyBpbiB0aGUgZ2l2ZW4gc29ydGVkIHNldCBieSBpbmRleCAocmFuaykuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjYWNoZU5hbWUgLSBUaGUgY2FjaGUgY29udGFpbmluZyB0aGUgc29ydGVkIHNldC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHNvcnRlZFNldE5hbWUgLSBUaGUgc29ydGVkIHNldCB0byBmZXRjaCBmcm9tLlxuICAgKiBAcGFyYW0ge1NvcnRlZFNldEZldGNoQnlSYW5rT3B0aW9uc30gb3B0aW9uc1xuICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuc3RhcnRSYW5rXSAtIFRoZSByYW5rIG9mIHRoZSBmaXJzdCBlbGVtZW50IHRvXG4gICAqIGZldGNoLiBEZWZhdWx0cyB0byAwLiBUaGlzIHJhbmsgaXMgaW5jbHVzaXZlLCBpZSB0aGUgZWxlbWVudCBhdCB0aGlzIHJhbmtcbiAgICogd2lsbCBiZSBmZXRjaGVkLlxuICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuZW5kUmFua10gLSBUaGUgcmFuayBvZiB0aGUgbGFzdCBlbGVtZW50IHRvIGZldGNoLlxuICAgKiBUaGlzIHJhbmsgaXMgZXhjbHVzaXZlLCBpZSB0aGUgZWxlbWVudCBhdCB0aGlzIHJhbmsgd2lsbCBub3QgYmUgZmV0Y2hlZC5cbiAgICogRGVmYXVsdHMgdG8gbnVsbCwgd2hpY2ggZmV0Y2hlcyB1cCB1bnRpbCBhbmQgaW5jbHVkaW5nIHRoZSBsYXN0IGVsZW1lbnQuXG4gICAqIEBwYXJhbSB7U29ydGVkU2V0T3JkZXJ9IFtvcHRpb25zLm9yZGVyXSAtIFRoZSBvcmRlciB0byBmZXRjaCB0aGUgZWxlbWVudHMgaW4uXG4gICAqIERlZmF1bHRzIHRvIGFzY2VuZGluZy5cbiAgICogQHJldHVybnMge1Byb21pc2U8Q2FjaGVTb3J0ZWRTZXRGZXRjaC5SZXNwb25zZT59XG4gICAqIHtAbGluayBDYWNoZVNvcnRlZFNldEZldGNoLkhpdH0gY29udGFpbmluZyB0aGUgcmVxdWVzdGVkIGVsZW1lbnRzIHdoZW4gZm91bmQuXG4gICAqIHtAbGluayBDYWNoZVNvcnRlZFNldEZldGNoLk1pc3N9IHdoZW4gdGhlIHNvcnRlZCBzZXQgZG9lcyBub3QgZXhpc3QuXG4gICAqIHtAbGluayBDYWNoZVNvcnRlZFNldEZldGNoLkVycm9yfSBvbiBmYWlsdXJlLlxuICAgKi9cbiAgcHVibGljIGFzeW5jIHNvcnRlZFNldEZldGNoQnlSYW5rKFxuICAgIGNhY2hlTmFtZTogc3RyaW5nLFxuICAgIHNvcnRlZFNldE5hbWU6IHN0cmluZyxcbiAgICBvcHRpb25zPzogU29ydGVkU2V0RmV0Y2hCeVJhbmtPcHRpb25zXG4gICk6IFByb21pc2U8Q2FjaGVTb3J0ZWRTZXRGZXRjaC5SZXNwb25zZT4ge1xuICAgIGNvbnN0IGNsaWVudCA9IHRoaXMuZ2V0TmV4dERhdGFDbGllbnQoKTtcbiAgICByZXR1cm4gYXdhaXQgY2xpZW50LnNvcnRlZFNldEZldGNoQnlSYW5rKFxuICAgICAgY2FjaGVOYW1lLFxuICAgICAgc29ydGVkU2V0TmFtZSxcbiAgICAgIG9wdGlvbnM/Lm9yZGVyID8/IFNvcnRlZFNldE9yZGVyLkFzY2VuZGluZyxcbiAgICAgIG9wdGlvbnM/LnN0YXJ0UmFuayA/PyAwLFxuICAgICAgb3B0aW9ucz8uZW5kUmFua1xuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggdGhlIGVsZW1lbnRzIGluIHRoZSBnaXZlbiBzb3J0ZWQgc2V0IGJ5IHNjb3JlLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2FjaGVOYW1lIC0gVGhlIGNhY2hlIGNvbnRhaW5pbmcgdGhlIHNvcnRlZCBzZXQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzb3J0ZWRTZXROYW1lIC0gVGhlIHNvcnRlZCBzZXQgdG8gZmV0Y2ggZnJvbS5cbiAgICogQHBhcmFtIHtTb3J0ZWRTZXRGZXRjaEJ5U2NvcmVPcHRpb25zfSBvcHRpb25zXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5taW5TY29yZV0gLSBUaGUgbWluaW11bSBzY29yZSAoaW5jbHVzaXZlKSBvZiB0aGVcbiAgICogZWxlbWVudHMgdG8gZmV0Y2guIERlZmF1bHRzIHRvIG5lZ2F0aXZlIGluZmluaXR5LlxuICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMubWF4U2NvcmVdIC0gVGhlIG1heGltdW0gc2NvcmUgKGluY2x1c2l2ZSkgb2YgdGhlXG4gICAqIGVsZW1lbnRzIHRvIGZldGNoLiBEZWZhdWx0cyB0byBwb3NpdGl2ZSBpbmZpbml0eS5cbiAgICogQHBhcmFtIHtTb3J0ZWRTZXRPcmRlcn0gW29wdGlvbnMub3JkZXJdIC0gVGhlIG9yZGVyIHRvIGZldGNoIHRoZSBlbGVtZW50cyBpbi5cbiAgICogRGVmYXVsdHMgdG8gYXNjZW5kaW5nLlxuICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMub2Zmc2V0XSAtIFRoZSBudW1iZXIgb2YgZWxlbWVudHMgdG8gc2tpcCBiZWZvcmVcbiAgICogcmV0dXJuaW5nIHRoZSBmaXJzdCBlbGVtZW50LiBEZWZhdWx0cyB0byAwLiBOb3RlOiB0aGlzIGlzIG5vdCB0aGUgcmFuayBvZlxuICAgKiB0aGUgZmlyc3QgZWxlbWVudCB0byByZXR1cm4sIGJ1dCB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzIG9mIHRoZSByZXN1bHQgc2V0XG4gICAqIHRvIHNraXAgYmVmb3JlIHJldHVybmluZyB0aGUgZmlyc3QgZWxlbWVudC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmNvdW50XSAtIFRoZSBtYXhpbXVtIG51bWJlciBvZiBlbGVtZW50cyB0byByZXR1cm4uXG4gICAqIERlZmF1bHRzIHRvIHVuZGVmaW5lZCwgd2hpY2ggcmV0dXJucyBhbGwgZWxlbWVudHMuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPENhY2hlU29ydGVkU2V0RmV0Y2guUmVzcG9uc2U+fSAtXG4gICAqIHtAbGluayBDYWNoZVNvcnRlZFNldEZldGNoLkhpdH0gY29udGFpbmluZyB0aGUgcmVxdWVzdGVkIGVsZW1lbnRzIHdoZW4gZm91bmQuXG4gICAqIHtAbGluayBDYWNoZVNvcnRlZFNldEZldGNoLk1pc3N9IHdoZW4gdGhlIHNvcnRlZCBzZXQgZG9lcyBub3QgZXhpc3QuXG4gICAqIHtAbGluayBDYWNoZVNvcnRlZFNldEZldGNoLkVycm9yfSBvbiBmYWlsdXJlLlxuICAgKi9cbiAgcHVibGljIGFzeW5jIHNvcnRlZFNldEZldGNoQnlTY29yZShcbiAgICBjYWNoZU5hbWU6IHN0cmluZyxcbiAgICBzb3J0ZWRTZXROYW1lOiBzdHJpbmcsXG4gICAgb3B0aW9ucz86IFNvcnRlZFNldEZldGNoQnlTY29yZU9wdGlvbnNcbiAgKTogUHJvbWlzZTxDYWNoZVNvcnRlZFNldEZldGNoLlJlc3BvbnNlPiB7XG4gICAgY29uc3QgY2xpZW50ID0gdGhpcy5nZXROZXh0RGF0YUNsaWVudCgpO1xuICAgIHJldHVybiBhd2FpdCBjbGllbnQuc29ydGVkU2V0RmV0Y2hCeVNjb3JlKFxuICAgICAgY2FjaGVOYW1lLFxuICAgICAgc29ydGVkU2V0TmFtZSxcbiAgICAgIG9wdGlvbnM/Lm9yZGVyID8/IFNvcnRlZFNldE9yZGVyLkFzY2VuZGluZyxcbiAgICAgIG9wdGlvbnM/Lm1pblNjb3JlLFxuICAgICAgb3B0aW9ucz8ubWF4U2NvcmUsXG4gICAgICBvcHRpb25zPy5vZmZzZXQsXG4gICAgICBvcHRpb25zPy5jb3VudFxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogTG9vayB1cCB0aGUgcmFuayBvZiBhbiBlbGVtZW50IGluIHRoZSBzb3J0ZWQgc2V0LCBieSB0aGUgdmFsdWUgb2YgdGhlIGVsZW1lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjYWNoZU5hbWUgLSBUaGUgY2FjaGUgY29udGFpbmluZyB0aGUgc29ydGVkIHNldC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHNvcnRlZFNldE5hbWUgLSBUaGUgc29ydGVkIHNldCB0byBmZXRjaCBmcm9tLlxuICAgKiBAcGFyYW0ge3N0cmluZyB8IFVpbnQ4QXJyYXl9IHZhbHVlIC0gVGhlIHZhbHVlIG9mIHRoZSBlbGVtZW50IHdob3NlIHJhbmsgd2UgYXJlIHJldHJpZXZpbmcuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPENhY2hlU29ydGVkU2V0R2V0UmFuay5SZXNwb25zZT59XG4gICAqIHtAbGluayBDYWNoZVNvcnRlZFNldEdldFJhbmsuSGl0fSBjb250YWluaW5nIHRoZSByYW5rIG9mIHRoZSByZXF1ZXN0ZWQgZWxlbWVudHMgd2hlbiBmb3VuZC5cbiAgICoge0BsaW5rIENhY2hlU29ydGVkU2V0R2V0UmFuay5NaXNzfSB3aGVuIHRoZSBlbGVtZW50IGRvZXMgbm90IGV4aXN0LlxuICAgKiB7QGxpbmsgQ2FjaGVTb3J0ZWRTZXRHZXRSYW5rLkVycm9yfSBvbiBmYWlsdXJlLlxuICAgKi9cbiAgcHVibGljIGFzeW5jIHNvcnRlZFNldEdldFJhbmsoXG4gICAgY2FjaGVOYW1lOiBzdHJpbmcsXG4gICAgc29ydGVkU2V0TmFtZTogc3RyaW5nLFxuICAgIHZhbHVlOiBzdHJpbmcgfCBVaW50OEFycmF5XG4gICk6IFByb21pc2U8Q2FjaGVTb3J0ZWRTZXRHZXRSYW5rLlJlc3BvbnNlPiB7XG4gICAgY29uc3QgY2xpZW50ID0gdGhpcy5nZXROZXh0RGF0YUNsaWVudCgpO1xuICAgIHJldHVybiBhd2FpdCBjbGllbnQuc29ydGVkU2V0R2V0UmFuayhjYWNoZU5hbWUsIHNvcnRlZFNldE5hbWUsIHZhbHVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBMb29rIHVwIHRoZSBzY29yZSBvZiBhbiBlbGVtZW50IGluIHRoZSBzb3J0ZWQgc2V0LCBieSB0aGUgdmFsdWUgb2YgdGhlIGVsZW1lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjYWNoZU5hbWUgLSBUaGUgY2FjaGUgY29udGFpbmluZyB0aGUgc29ydGVkIHNldC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHNvcnRlZFNldE5hbWUgLSBUaGUgc29ydGVkIHNldCB0byBmZXRjaCBmcm9tLlxuICAgKiBAcGFyYW0ge3N0cmluZyB8IFVpbnQ4QXJyYXl9IHZhbHVlIC0gVGhlIHZhbHVlIG9mIHRoZSBlbGVtZW50IHdob3NlIHNjb3JlIHdlIGFyZSByZXRyaWV2aW5nLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxDYWNoZVNvcnRlZFNldEdldFNjb3JlLlJlc3BvbnNlPn1cbiAgICoge0BsaW5rIENhY2hlU29ydGVkU2V0R2V0U2NvcmUuSGl0fSBjb250YWluaW5nIHRoZSBzY29yZSBvZiB0aGUgcmVxdWVzdGVkIGVsZW1lbnQgd2hlbiBmb3VuZC5cbiAgICoge0BsaW5rIENhY2hlU29ydGVkU2V0R2V0U2NvcmUuTWlzc30gd2hlbiB0aGUgZWxlbWVudCBvciBjb2xsZWN0aW9uIGRvZXMgbm90IGV4aXN0LlxuICAgKiB7QGxpbmsgQ2FjaGVTb3J0ZWRTZXRHZXRTY29yZS5FcnJvcn0gb24gZmFpbHVyZS5cbiAgICovXG4gIHB1YmxpYyBhc3luYyBzb3J0ZWRTZXRHZXRTY29yZShcbiAgICBjYWNoZU5hbWU6IHN0cmluZyxcbiAgICBzb3J0ZWRTZXROYW1lOiBzdHJpbmcsXG4gICAgdmFsdWU6IHN0cmluZyB8IFVpbnQ4QXJyYXlcbiAgKTogUHJvbWlzZTxDYWNoZVNvcnRlZFNldEdldFNjb3JlLlJlc3BvbnNlPiB7XG4gICAgY29uc3QgY2xpZW50ID0gdGhpcy5nZXROZXh0RGF0YUNsaWVudCgpO1xuICAgIHJldHVybiBhd2FpdCBjbGllbnQuc29ydGVkU2V0R2V0U2NvcmUoY2FjaGVOYW1lLCBzb3J0ZWRTZXROYW1lLCB2YWx1ZSk7XG4gIH1cblxuICAvKipcbiAgICogTG9vayB1cCB0aGUgc2NvcmVzIG9mIG11bHRpcGxlIGVsZW1lbnRzIGluIHRoZSBzb3J0ZWQgc2V0LCBieSB0aGUgdmFsdWUgb2YgdGhlIGVsZW1lbnRzLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2FjaGVOYW1lIC0gVGhlIGNhY2hlIGNvbnRhaW5pbmcgdGhlIHNvcnRlZCBzZXQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzb3J0ZWRTZXROYW1lIC0gVGhlIHNvcnRlZCBzZXQgdG8gZmV0Y2ggZnJvbS5cbiAgICogQHBhcmFtIHtzdHJpbmdbXSB8IFVpbnQ4QXJyYXlbXX0gdmFsdWVzIC0gVGhlIHZhbHVlcyBvZiB0aGUgZWxlbWVudHMgd2hvc2Ugc2NvcmVzIHdlIGFyZSByZXRyaWV2aW5nLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxDYWNoZVNvcnRlZFNldEdldFNjb3Jlcy5SZXNwb25zZT59XG4gICAqIHtAbGluayBDYWNoZVNvcnRlZFNldEdldFNjb3Jlcy5IaXR9IGNvbnRhaW5pbmcgdGhlIHNjb3JlcyBvZiB0aGUgcmVxdWVzdGVkIGVsZW1lbnRzIHdoZW4gZm91bmQuXG4gICAqIHtAbGluayBDYWNoZVNvcnRlZFNldEdldFNjb3Jlcy5NaXNzfSB3aGVuIHRoZSBlbGVtZW50IG9yIGNvbGxlY3Rpb24gZG9lcyBub3QgZXhpc3QuXG4gICAqIHtAbGluayBDYWNoZVNvcnRlZFNldEdldFNjb3Jlcy5FcnJvcn0gb24gZmFpbHVyZS5cbiAgICovXG4gIHB1YmxpYyBhc3luYyBzb3J0ZWRTZXRHZXRTY29yZXMoXG4gICAgY2FjaGVOYW1lOiBzdHJpbmcsXG4gICAgc29ydGVkU2V0TmFtZTogc3RyaW5nLFxuICAgIHZhbHVlczogc3RyaW5nW10gfCBVaW50OEFycmF5W11cbiAgKTogUHJvbWlzZTxDYWNoZVNvcnRlZFNldEdldFNjb3Jlcy5SZXNwb25zZT4ge1xuICAgIGNvbnN0IGNsaWVudCA9IHRoaXMuZ2V0TmV4dERhdGFDbGllbnQoKTtcbiAgICByZXR1cm4gYXdhaXQgY2xpZW50LnNvcnRlZFNldEdldFNjb3JlcyhjYWNoZU5hbWUsIHNvcnRlZFNldE5hbWUsIHZhbHVlcyk7XG4gIH1cblxuICAvKipcbiAgICogSW5jcmVtZW50IHRoZSBzY29yZSBvZiBhbiBlbGVtZW50IGluIHRoZSBzb3J0ZWQgc2V0LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2FjaGVOYW1lIC0gVGhlIGNhY2hlIGNvbnRhaW5pbmcgdGhlIHNvcnRlZCBzZXQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzb3J0ZWRTZXROYW1lIC0gVGhlIHNvcnRlZCBzZXQgdG8gZmV0Y2ggZnJvbS5cbiAgICogQHBhcmFtIHtzdHJpbmcgfCBVaW50OEFycmF5fSB2YWx1ZSAtIFRoZSB2YWx1ZSBvZiB0aGUgZWxlbWVudCB3aG9zZSBzY29yZSB3ZSBhcmUgaW5jcmVtZW50aW5nLlxuICAgKiBAcGFyYW0ge251bWJlcn0gYW1vdW50IC0gVGhlIHF1YW50aXR5IHRvIGFkZCB0byB0aGUgc2NvcmUuIE1heSBiZSBwb3NpdGl2ZSxcbiAgICogbmVnYXRpdmUsIG9yIHplcm8uIERlZmF1bHRzIHRvIDEuXG4gICAqIEBwYXJhbSB7U29ydGVkU2V0SW5jcmVtZW50T3B0aW9uc30gb3B0aW9uc1xuICAgKiBAcGFyYW0ge0NvbGxlY3Rpb25UdGx9IFtvcHRpb25zLnR0bF0gLSBIb3cgdGhlIFRUTCBzaG91bGQgYmUgbWFuYWdlZC5cbiAgICogUmVmcmVzaGVzIHRoZSBzb3J0ZWQgc2V0J3MgVFRMIHVzaW5nIHRoZSBjbGllbnQncyBkZWZhdWx0IGlmIHRoaXMgaXMgbm90XG4gICAqIHN1cHBsaWVkLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxDYWNoZVNvcnRlZFNldEluY3JlbWVudFNjb3JlLlJlc3BvbnNlPn0gLVxuICAgKiB7QGxpbmsgQ2FjaGVTb3J0ZWRTZXRJbmNyZW1lbnRTY29yZS5TdWNjZXNzfSBjb250YWluaW5nIHRoZSBpbmNyZW1lbnRlZCBzY29yZVxuICAgKiBvbiBzdWNjZXNzLlxuICAgKiB7QGxpbmsgQ2FjaGVTb3J0ZWRTZXRJbmNyZW1lbnRTY29yZS5FcnJvcn0gb24gZmFpbHVyZS4gSW5jcmVtZW50aW5nIGEgc2NvcmVcbiAgICogdGhhdCB3YXMgbm90IHNldCB1c2luZyB0aGlzIG1ldGhvZCBvciBpcyBub3QgdGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZlxuICAgKiBhbiBpbnRlZ2VyIHJlc3VsdHMgaW4gYSBmYWlsdXJlIHdpdGggYSBGYWlsZWRQcmVjb25kaXRpb25FeGNlcHRpb24gZXJyb3IuXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgc29ydGVkU2V0SW5jcmVtZW50U2NvcmUoXG4gICAgY2FjaGVOYW1lOiBzdHJpbmcsXG4gICAgc29ydGVkU2V0TmFtZTogc3RyaW5nLFxuICAgIHZhbHVlOiBzdHJpbmcgfCBVaW50OEFycmF5LFxuICAgIGFtb3VudD86IG51bWJlcixcbiAgICBvcHRpb25zPzogU29ydGVkU2V0SW5jcmVtZW50T3B0aW9uc1xuICApOiBQcm9taXNlPENhY2hlU29ydGVkU2V0SW5jcmVtZW50U2NvcmUuUmVzcG9uc2U+IHtcbiAgICBjb25zdCBjbGllbnQgPSB0aGlzLmdldE5leHREYXRhQ2xpZW50KCk7XG4gICAgcmV0dXJuIGF3YWl0IGNsaWVudC5zb3J0ZWRTZXRJbmNyZW1lbnRTY29yZShcbiAgICAgIGNhY2hlTmFtZSxcbiAgICAgIHNvcnRlZFNldE5hbWUsXG4gICAgICB2YWx1ZSxcbiAgICAgIGFtb3VudCB8fCAxLFxuICAgICAgb3B0aW9ucz8udHRsXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgYW4gZWxlbWVudCBmcm9tIHRoZSBzb3J0ZWQgc2V0XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjYWNoZU5hbWUgLSBUaGUgY2FjaGUgY29udGFpbmluZyB0aGUgc29ydGVkIHNldC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHNvcnRlZFNldE5hbWUgLSBUaGUgc29ydGVkIHNldCB0byByZW1vdmUgZnJvbS5cbiAgICogQHBhcmFtIHtzdHJpbmcgfCBVaW50OEFycmF5fSB2YWx1ZSAtIFRoZSB2YWx1ZSBvZiB0aGUgZWxlbWVudCB0byByZW1vdmUgZnJvbSB0aGUgc2V0LlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxDYWNoZVNvcnRlZFNldFJlbW92ZUVsZW1lbnQuUmVzcG9uc2U+fVxuICAgKiB7QGxpbmsgQ2FjaGVTb3J0ZWRTZXRSZW1vdmVFbGVtZW50LlN1Y2Nlc3N9IGlmIHRoZSBlbGVtZW50IHdhcyBzdWNjZXNzZnVsbHkgcmVtb3ZlZFxuICAgKiB7QGxpbmsgQ2FjaGVTb3J0ZWRTZXRJbmNyZW1lbnRTY29yZS5FcnJvcn0gb24gZmFpbHVyZVxuICAgKi9cbiAgcHVibGljIGFzeW5jIHNvcnRlZFNldFJlbW92ZUVsZW1lbnQoXG4gICAgY2FjaGVOYW1lOiBzdHJpbmcsXG4gICAgc29ydGVkU2V0TmFtZTogc3RyaW5nLFxuICAgIHZhbHVlOiBzdHJpbmcgfCBVaW50OEFycmF5XG4gICk6IFByb21pc2U8Q2FjaGVTb3J0ZWRTZXRSZW1vdmVFbGVtZW50LlJlc3BvbnNlPiB7XG4gICAgY29uc3QgY2xpZW50ID0gdGhpcy5nZXROZXh0RGF0YUNsaWVudCgpO1xuICAgIHJldHVybiBhd2FpdCBjbGllbnQuc29ydGVkU2V0UmVtb3ZlRWxlbWVudChjYWNoZU5hbWUsIHNvcnRlZFNldE5hbWUsIHZhbHVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgbXVsdGlwbGUgZWxlbWVudHMgZnJvbSB0aGUgc29ydGVkIHNldFxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2FjaGVOYW1lIC0gVGhlIGNhY2hlIGNvbnRhaW5pbmcgdGhlIHNvcnRlZCBzZXQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzb3J0ZWRTZXROYW1lIC0gVGhlIHNvcnRlZCBzZXQgdG8gcmVtb3ZlIGZyb20uXG4gICAqIEBwYXJhbSB7c3RyaW5nIHwgVWludDhBcnJheX0gdmFsdWVzIC0gVGhlIHZhbHVlcyBvZiB0aGUgZWxlbWVudHMgdG8gcmVtb3ZlIGZyb20gdGhlIHNldC5cbiAgICogQHJldHVybnMge1Byb21pc2U8Q2FjaGVTb3J0ZWRTZXRSZW1vdmVFbGVtZW50LlJlc3BvbnNlPn1cbiAgICoge0BsaW5rIENhY2hlU29ydGVkU2V0UmVtb3ZlRWxlbWVudC5TdWNjZXNzfSBpZiB0aGUgZWxlbWVudHMgd2VyZSBzdWNjZXNzZnVsbHkgcmVtb3ZlZFxuICAgKiB7QGxpbmsgQ2FjaGVTb3J0ZWRTZXRJbmNyZW1lbnRTY29yZS5FcnJvcn0gb24gZmFpbHVyZVxuICAgKi9cbiAgcHVibGljIGFzeW5jIHNvcnRlZFNldFJlbW92ZUVsZW1lbnRzKFxuICAgIGNhY2hlTmFtZTogc3RyaW5nLFxuICAgIHNvcnRlZFNldE5hbWU6IHN0cmluZyxcbiAgICB2YWx1ZXM6IHN0cmluZ1tdIHwgVWludDhBcnJheVtdXG4gICk6IFByb21pc2U8Q2FjaGVTb3J0ZWRTZXRSZW1vdmVFbGVtZW50cy5SZXNwb25zZT4ge1xuICAgIGNvbnN0IGNsaWVudCA9IHRoaXMuZ2V0TmV4dERhdGFDbGllbnQoKTtcbiAgICByZXR1cm4gYXdhaXQgY2xpZW50LnNvcnRlZFNldFJlbW92ZUVsZW1lbnRzKFxuICAgICAgY2FjaGVOYW1lLFxuICAgICAgc29ydGVkU2V0TmFtZSxcbiAgICAgIHZhbHVlc1xuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSB0eXBlIG9mIHRoZSBrZXkgaW4gdGhlIGNhY2hlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjYWNoZU5hbWUgLSBUaGUgY2FjaGUgY29udGFpbmluZyB0aGUga2V5LlxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IC0gVGhlIGtleSBmb3Igd2hpY2ggdHlwZSBpcyByZXF1ZXN0ZWQuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPEl0ZW1HZXRUeXBlLlJlc3BvbnNlPn1cbiAgICoge0BsaW5rIEl0ZW1HZXRUeXBlLkhpdH0gY29udGFpbmluZyB0eXBlIG9mIGtleSB3aGVuIGZvdW5kLlxuICAgKiB7QGxpbmsgSXRlbUdldFR5cGUuTWlzc30gd2hlbiB0aGUga2V5IGRvZXMgbm90IGV4aXN0LlxuICAgKiB7QGxpbmsgSXRlbUdldFR5cGUuRXJyb3J9IG9uIGZhaWx1cmUuXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgaXRlbUdldFR5cGUoXG4gICAgY2FjaGVOYW1lOiBzdHJpbmcsXG4gICAga2V5OiBzdHJpbmcgfCBVaW50OEFycmF5XG4gICk6IFByb21pc2U8SXRlbUdldFR5cGUuUmVzcG9uc2U+IHtcbiAgICBjb25zdCBjbGllbnQgPSB0aGlzLmdldE5leHREYXRhQ2xpZW50KCk7XG4gICAgcmV0dXJuIGF3YWl0IGNsaWVudC5pdGVtR2V0VHlwZShjYWNoZU5hbWUsIGtleSk7XG4gIH1cblxuICBwcm90ZWN0ZWQgZ2V0TmV4dERhdGFDbGllbnQoKTogSURhdGFDbGllbnQge1xuICAgIGNvbnN0IGNsaWVudCA9IHRoaXMuZGF0YUNsaWVudHNbdGhpcy5uZXh0RGF0YUNsaWVudEluZGV4XTtcbiAgICB0aGlzLm5leHREYXRhQ2xpZW50SW5kZXggPVxuICAgICAgKHRoaXMubmV4dERhdGFDbGllbnRJbmRleCArIDEpICUgdGhpcy5kYXRhQ2xpZW50cy5sZW5ndGg7XG4gICAgcmV0dXJuIGNsaWVudDtcbiAgfVxufVxuIl19