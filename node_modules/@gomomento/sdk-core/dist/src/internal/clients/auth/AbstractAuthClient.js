"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AbstractAuthClient = void 0;
class AbstractAuthClient {
    constructor(props) {
        this.authClient = props.createAuthClient();
    }
    /**
     * Generates a new auth token, along with a refresh token to refresh the auth token before expiry.
     *
     * @param {TokenScope} scope - controls the permissions that the new token will have
     * @param {string} expiresIn - How long the token is valid for in epoch timestamp.
     * @returns {Promise<GenerateAuthToken.Response>} -
     * {@link GenerateAuthToken.Success} containing the api token, refresh token, origin and epoch timestamp when token expires.
     * If the token never expires, then no refresh token will be returned and expires at timestamp will be infinite.
     * {@link GenerateAuthToken.Error} on failure.
     */
    async generateAuthToken(scope, expiresIn) {
        return await this.authClient.generateAuthToken(scope, expiresIn);
    }
    /**
     * Refreshes an auth token.  Returns a new set of refresh/auth tokens that will be able to be refreshed again in the future.
     * The new auth token will be valid for the same length of time as the original token, starting from the time of refresh.
     * The original api token will still work until its expired.
     *
     * @param {string} refreshToken - Refresh token used to refresh the api token.
     * @returns {Promise<RefreshAuthToken.Response>} -
     * {@link RefreshAuthToken.Success} containing the new auth token, refresh token, origin and epoch timestamp when token expires.
     * {@link RefreshAuthToken.Error} on failure.
     */
    async refreshAuthToken(refreshToken) {
        return await this.authClient.refreshAuthToken(refreshToken);
    }
}
exports.AbstractAuthClient = AbstractAuthClient;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQWJzdHJhY3RBdXRoQ2xpZW50LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vc3JjL2ludGVybmFsL2NsaWVudHMvYXV0aC9BYnN0cmFjdEF1dGhDbGllbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBT0EsTUFBc0Isa0JBQWtCO0lBSXRDLFlBQXNCLEtBQTBCO1FBQzlDLElBQUksQ0FBQyxVQUFVLEdBQUcsS0FBSyxDQUFDLGdCQUFnQixFQUFFLENBQUM7SUFDN0MsQ0FBQztJQUVEOzs7Ozs7Ozs7T0FTRztJQUNJLEtBQUssQ0FBQyxpQkFBaUIsQ0FDNUIsS0FBaUIsRUFDakIsU0FBb0I7UUFFcEIsT0FBTyxNQUFNLElBQUksQ0FBQyxVQUFVLENBQUMsaUJBQWlCLENBQUMsS0FBSyxFQUFFLFNBQVMsQ0FBQyxDQUFDO0lBQ25FLENBQUM7SUFFRDs7Ozs7Ozs7O09BU0c7SUFDSSxLQUFLLENBQUMsZ0JBQWdCLENBQzNCLFlBQW9CO1FBRXBCLE9BQU8sTUFBTSxJQUFJLENBQUMsVUFBVSxDQUFDLGdCQUFnQixDQUFDLFlBQVksQ0FBQyxDQUFDO0lBQzlELENBQUM7Q0FDRjtBQXhDRCxnREF3Q0MiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge0dlbmVyYXRlQXV0aFRva2VuLCBFeHBpcmVzSW4sIFJlZnJlc2hBdXRoVG9rZW59IGZyb20gJy4uLy4uLy4uL2luZGV4JztcbmltcG9ydCB7SUF1dGhDbGllbnR9IGZyb20gJy4uLy4uLy4uL2NsaWVudHMvSUF1dGhDbGllbnQnO1xuaW1wb3J0IHtUb2tlblNjb3BlfSBmcm9tICcuLi8uLi8uLi9hdXRoL3Rva2Vucy90b2tlbi1zY29wZSc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgQmFzZUF1dGhDbGllbnRQcm9wcyB7XG4gIGNyZWF0ZUF1dGhDbGllbnQ6ICgpID0+IElBdXRoQ2xpZW50O1xufVxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIEFic3RyYWN0QXV0aENsaWVudCBpbXBsZW1lbnRzIElBdXRoQ2xpZW50IHtcbiAgLy8gbWFraW5nIHRoZXNlIHByb3RlY3RlZCB1bnRpbCB3ZSBmdWxseSBhYnN0cmFjdCBhd2F5IHRoZSBub2RlanMgY2xpZW50XG4gIHByb3RlY3RlZCByZWFkb25seSBhdXRoQ2xpZW50OiBJQXV0aENsaWVudDtcblxuICBwcm90ZWN0ZWQgY29uc3RydWN0b3IocHJvcHM6IEJhc2VBdXRoQ2xpZW50UHJvcHMpIHtcbiAgICB0aGlzLmF1dGhDbGllbnQgPSBwcm9wcy5jcmVhdGVBdXRoQ2xpZW50KCk7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGVzIGEgbmV3IGF1dGggdG9rZW4sIGFsb25nIHdpdGggYSByZWZyZXNoIHRva2VuIHRvIHJlZnJlc2ggdGhlIGF1dGggdG9rZW4gYmVmb3JlIGV4cGlyeS5cbiAgICpcbiAgICogQHBhcmFtIHtUb2tlblNjb3BlfSBzY29wZSAtIGNvbnRyb2xzIHRoZSBwZXJtaXNzaW9ucyB0aGF0IHRoZSBuZXcgdG9rZW4gd2lsbCBoYXZlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBleHBpcmVzSW4gLSBIb3cgbG9uZyB0aGUgdG9rZW4gaXMgdmFsaWQgZm9yIGluIGVwb2NoIHRpbWVzdGFtcC5cbiAgICogQHJldHVybnMge1Byb21pc2U8R2VuZXJhdGVBdXRoVG9rZW4uUmVzcG9uc2U+fSAtXG4gICAqIHtAbGluayBHZW5lcmF0ZUF1dGhUb2tlbi5TdWNjZXNzfSBjb250YWluaW5nIHRoZSBhcGkgdG9rZW4sIHJlZnJlc2ggdG9rZW4sIG9yaWdpbiBhbmQgZXBvY2ggdGltZXN0YW1wIHdoZW4gdG9rZW4gZXhwaXJlcy5cbiAgICogSWYgdGhlIHRva2VuIG5ldmVyIGV4cGlyZXMsIHRoZW4gbm8gcmVmcmVzaCB0b2tlbiB3aWxsIGJlIHJldHVybmVkIGFuZCBleHBpcmVzIGF0IHRpbWVzdGFtcCB3aWxsIGJlIGluZmluaXRlLlxuICAgKiB7QGxpbmsgR2VuZXJhdGVBdXRoVG9rZW4uRXJyb3J9IG9uIGZhaWx1cmUuXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgZ2VuZXJhdGVBdXRoVG9rZW4oXG4gICAgc2NvcGU6IFRva2VuU2NvcGUsXG4gICAgZXhwaXJlc0luOiBFeHBpcmVzSW5cbiAgKTogUHJvbWlzZTxHZW5lcmF0ZUF1dGhUb2tlbi5SZXNwb25zZT4ge1xuICAgIHJldHVybiBhd2FpdCB0aGlzLmF1dGhDbGllbnQuZ2VuZXJhdGVBdXRoVG9rZW4oc2NvcGUsIGV4cGlyZXNJbik7XG4gIH1cblxuICAvKipcbiAgICogUmVmcmVzaGVzIGFuIGF1dGggdG9rZW4uICBSZXR1cm5zIGEgbmV3IHNldCBvZiByZWZyZXNoL2F1dGggdG9rZW5zIHRoYXQgd2lsbCBiZSBhYmxlIHRvIGJlIHJlZnJlc2hlZCBhZ2FpbiBpbiB0aGUgZnV0dXJlLlxuICAgKiBUaGUgbmV3IGF1dGggdG9rZW4gd2lsbCBiZSB2YWxpZCBmb3IgdGhlIHNhbWUgbGVuZ3RoIG9mIHRpbWUgYXMgdGhlIG9yaWdpbmFsIHRva2VuLCBzdGFydGluZyBmcm9tIHRoZSB0aW1lIG9mIHJlZnJlc2guXG4gICAqIFRoZSBvcmlnaW5hbCBhcGkgdG9rZW4gd2lsbCBzdGlsbCB3b3JrIHVudGlsIGl0cyBleHBpcmVkLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcmVmcmVzaFRva2VuIC0gUmVmcmVzaCB0b2tlbiB1c2VkIHRvIHJlZnJlc2ggdGhlIGFwaSB0b2tlbi5cbiAgICogQHJldHVybnMge1Byb21pc2U8UmVmcmVzaEF1dGhUb2tlbi5SZXNwb25zZT59IC1cbiAgICoge0BsaW5rIFJlZnJlc2hBdXRoVG9rZW4uU3VjY2Vzc30gY29udGFpbmluZyB0aGUgbmV3IGF1dGggdG9rZW4sIHJlZnJlc2ggdG9rZW4sIG9yaWdpbiBhbmQgZXBvY2ggdGltZXN0YW1wIHdoZW4gdG9rZW4gZXhwaXJlcy5cbiAgICoge0BsaW5rIFJlZnJlc2hBdXRoVG9rZW4uRXJyb3J9IG9uIGZhaWx1cmUuXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgcmVmcmVzaEF1dGhUb2tlbihcbiAgICByZWZyZXNoVG9rZW46IHN0cmluZ1xuICApOiBQcm9taXNlPFJlZnJlc2hBdXRoVG9rZW4uUmVzcG9uc2U+IHtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5hdXRoQ2xpZW50LnJlZnJlc2hBdXRoVG9rZW4ocmVmcmVzaFRva2VuKTtcbiAgfVxufVxuIl19