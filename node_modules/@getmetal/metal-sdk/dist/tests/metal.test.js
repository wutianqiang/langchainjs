"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const index_1 = __importDefault(require("../src/index"));
const axios_1 = __importDefault(require("axios"));
jest.mock('axios');
const mockedAxios = axios_1.default;
const API_KEY = 'api-key';
const CLIENT_ID = 'client-id';
const AXIOS_OPTS = {
    headers: {
        'Content-Type': 'application/json',
        'x-metal-api-key': API_KEY,
        'x-metal-client-id': CLIENT_ID,
    },
};
describe('MetalSDK', () => {
    beforeEach(() => {
        mockedAxios.post.mockClear();
    });
    it('should be defined', () => {
        expect(index_1.default).toBeDefined();
    });
    it('should instantiate properly', () => {
        const indexId = 'index-id';
        const metal = new index_1.default(API_KEY, CLIENT_ID, indexId);
        expect(metal.apiKey).toBe(API_KEY);
        expect(metal.indexId).toBe(indexId);
        expect(metal.clientId).toBe(CLIENT_ID);
    });
    describe('index()', () => {
        it('should error without indexId', () => __awaiter(void 0, void 0, void 0, function* () {
            const metal = new index_1.default(API_KEY, CLIENT_ID);
            const result = metal.index({});
            yield expect(result).rejects.toThrowError('indexId required');
        }));
        it('should error without payload', () => __awaiter(void 0, void 0, void 0, function* () {
            const metal = new index_1.default(API_KEY, CLIENT_ID, 'index-id');
            const result = metal.index({});
            yield expect(result).rejects.toThrowError('payload required');
        }));
        it('should send imageBase64 payload', () => __awaiter(void 0, void 0, void 0, function* () {
            const indexId = 'index-id';
            const base64 = 'base64';
            const metal = new index_1.default(API_KEY, CLIENT_ID, indexId);
            mockedAxios.post.mockResolvedValue({ data: null });
            yield metal.index({ imageBase64: base64 });
            expect(axios_1.default.post).toHaveBeenCalledWith('https://api.getmetal.io/v1/index', {
                imageBase64: base64,
                index: indexId,
            }, AXIOS_OPTS);
            mockedAxios.post.mockClear();
        }));
        it('should send imageUrl payload', () => __awaiter(void 0, void 0, void 0, function* () {
            const indexId = 'index-id';
            const imageUrl = 'image.png';
            const metal = new index_1.default(API_KEY, CLIENT_ID, indexId);
            mockedAxios.post.mockResolvedValue({ data: null });
            yield metal.index({ imageUrl });
            expect(axios_1.default.post).toHaveBeenCalledWith('https://api.getmetal.io/v1/index', {
                imageUrl,
                index: indexId,
            }, AXIOS_OPTS);
        }));
        it('should send text payload', () => __awaiter(void 0, void 0, void 0, function* () {
            const indexId = 'index-id';
            const text = 'text-to-index';
            const metal = new index_1.default(API_KEY, CLIENT_ID, indexId);
            mockedAxios.post.mockResolvedValue({ data: null });
            yield metal.index({ text });
            expect(axios_1.default.post).toHaveBeenCalledWith('https://api.getmetal.io/v1/index', {
                text,
                index: indexId,
            }, AXIOS_OPTS);
        }));
        it('should send metadata payload', () => __awaiter(void 0, void 0, void 0, function* () {
            const indexId = 'index-id';
            const text = 'text-to-index';
            const metadata = { foo: 'bar' };
            const metal = new index_1.default(API_KEY, CLIENT_ID, indexId);
            mockedAxios.post.mockResolvedValue({ data: null });
            yield metal.index({ metadata, text });
            expect(axios_1.default.post).toHaveBeenCalledWith('https://api.getmetal.io/v1/index', {
                metadata,
                text,
                index: indexId,
            }, AXIOS_OPTS);
        }));
        it('should send embedding payload', () => __awaiter(void 0, void 0, void 0, function* () {
            const indexId = 'index-id';
            const embedding = [1, 2, 3];
            const metal = new index_1.default(API_KEY, CLIENT_ID, indexId);
            mockedAxios.post.mockResolvedValue({ data: null });
            yield metal.index({ embedding });
            expect(axios_1.default.post).toHaveBeenCalledWith('https://api.getmetal.io/v1/index', {
                embedding,
                index: indexId,
            }, AXIOS_OPTS);
        }));
    });
    describe('indexMany()', () => {
        it('should send text payload', () => __awaiter(void 0, void 0, void 0, function* () {
            const indexId = 'index-id';
            const text = 'text-to-index';
            const metal = new index_1.default(API_KEY, CLIENT_ID, indexId);
            mockedAxios.post.mockResolvedValue({ data: null });
            yield metal.indexMany([{ text, index: indexId }]);
            expect(axios_1.default.post).toHaveBeenCalledWith('https://api.getmetal.io/v1/index/bulk', {
                data: [
                    {
                        text,
                        index: indexId,
                    },
                ],
            }, AXIOS_OPTS);
        }));
        it('should send metadata payload', () => __awaiter(void 0, void 0, void 0, function* () {
            const indexId = 'index-id';
            const text = 'text-to-index';
            const text2 = 'text-to-index2';
            const metadata = { foo: 'bar' };
            const metal = new index_1.default(API_KEY, CLIENT_ID, indexId);
            mockedAxios.post.mockResolvedValue({ data: null });
            yield metal.indexMany([
                { metadata, text, index: indexId },
                { metadata, text: text2, index: indexId },
            ]);
            expect(axios_1.default.post).toHaveBeenCalledWith('https://api.getmetal.io/v1/index/bulk', {
                data: [
                    {
                        metadata,
                        text,
                        index: indexId,
                    },
                    {
                        metadata,
                        text: text2,
                        index: indexId,
                    },
                ],
            }, AXIOS_OPTS);
        }));
        it('should send embedding payload', () => __awaiter(void 0, void 0, void 0, function* () {
            const indexId = 'index-id';
            const embedding = [1, 2, 3];
            const metal = new index_1.default(API_KEY, CLIENT_ID, indexId);
            mockedAxios.post.mockResolvedValue({ data: null });
            yield metal.indexMany([{ index: indexId, embedding }]);
            expect(axios_1.default.post).toHaveBeenCalledWith('https://api.getmetal.io/v1/index/bulk', {
                data: [
                    {
                        embedding,
                        index: indexId,
                    },
                ],
            }, AXIOS_OPTS);
        }));
    });
    describe('search()', () => {
        it('should error without indexId', () => __awaiter(void 0, void 0, void 0, function* () {
            const metal = new index_1.default(API_KEY, CLIENT_ID);
            const result = metal.search({});
            yield expect(result).rejects.toThrowError('indexId required');
        }));
        it('should error without payload', () => __awaiter(void 0, void 0, void 0, function* () {
            const metal = new index_1.default(API_KEY, CLIENT_ID, 'index-id');
            mockedAxios.post.mockResolvedValue({ data: null });
            yield metal.search();
            expect(axios_1.default.post).toHaveBeenCalledWith('https://api.getmetal.io/v1/search?limit=10', {
                index: 'index-id',
            }, AXIOS_OPTS);
        }));
        it('should send imageBase64 payload', () => __awaiter(void 0, void 0, void 0, function* () {
            const indexId = 'index-id';
            const base64 = 'base64';
            const metal = new index_1.default(API_KEY, CLIENT_ID, indexId);
            mockedAxios.post.mockResolvedValue({ data: null });
            yield metal.search({ imageBase64: base64 });
            expect(axios_1.default.post).toHaveBeenCalledWith('https://api.getmetal.io/v1/search?limit=10', {
                imageBase64: base64,
                index: indexId,
            }, AXIOS_OPTS);
        }));
        it('should send imageUrl payload', () => __awaiter(void 0, void 0, void 0, function* () {
            const indexId = 'index-id';
            const imageUrl = 'image.png';
            const metal = new index_1.default(API_KEY, CLIENT_ID, indexId);
            mockedAxios.post.mockResolvedValue({ data: null });
            yield metal.search({ imageUrl });
            expect(axios_1.default.post).toHaveBeenCalledWith('https://api.getmetal.io/v1/search?limit=10', {
                imageUrl,
                index: indexId,
            }, AXIOS_OPTS);
        }));
        it('should send text payload', () => __awaiter(void 0, void 0, void 0, function* () {
            const indexId = 'index-id';
            const text = 'text-to-search';
            const metal = new index_1.default(API_KEY, CLIENT_ID, indexId);
            mockedAxios.post.mockResolvedValue({ data: null });
            yield metal.search({ text, filters: [{ field: 'favoriteNumber', value: 666 }] });
            expect(axios_1.default.post).toHaveBeenCalledWith('https://api.getmetal.io/v1/search?limit=10', {
                text,
                index: indexId,
                filters: [{ field: 'favoriteNumber', value: 666 }],
            }, AXIOS_OPTS);
        }));
        it('should add idsOnly=true querystring', () => __awaiter(void 0, void 0, void 0, function* () {
            const indexId = 'index-id';
            const text = 'text-to-search';
            const metal = new index_1.default(API_KEY, CLIENT_ID, indexId);
            mockedAxios.post.mockResolvedValue({ data: null });
            yield metal.search({ text, idsOnly: true, limit: 100 });
            expect(axios_1.default.post).toHaveBeenCalledWith('https://api.getmetal.io/v1/search?limit=100&idsOnly=true', {
                text,
                index: indexId,
            }, AXIOS_OPTS);
        }));
    });
    describe('tune()', () => {
        it('should error without indexId', () => __awaiter(void 0, void 0, void 0, function* () {
            const metal = new index_1.default(API_KEY, CLIENT_ID);
            const result = metal.tune({ idA: 'a', idB: 'b', label: 1 });
            yield expect(result).rejects.toThrowError('indexId required');
        }));
        it('should error without payload', () => __awaiter(void 0, void 0, void 0, function* () {
            const metal = new index_1.default(API_KEY, CLIENT_ID, 'index-id');
            // @ts-expect-error testing
            const result = metal.tune({});
            yield expect(result).rejects.toThrowError('idA, idB, & label required for payload');
        }));
        it('should send with payload', () => __awaiter(void 0, void 0, void 0, function* () {
            const indexId = 'index-id';
            const metal = new index_1.default(API_KEY, CLIENT_ID, indexId);
            mockedAxios.post.mockResolvedValue({ data: null });
            const idA = 'id-a';
            const idB = 'id-b';
            const label = 1;
            yield metal.tune({ idA, idB, label });
            expect(axios_1.default.post).toHaveBeenCalledWith(`https://api.getmetal.io/v1/tune`, {
                index: indexId,
                idA,
                idB,
                label,
            }, AXIOS_OPTS);
        }));
    });
    describe('getOne()', () => {
        it('should error without `id`', () => __awaiter(void 0, void 0, void 0, function* () {
            const metal = new index_1.default(API_KEY, CLIENT_ID, 'index-id');
            // @ts-expect-error testing
            const result = metal.getOne();
            yield expect(result).rejects.toThrowError('id required');
        }));
        it('should error without `id`', () => __awaiter(void 0, void 0, void 0, function* () {
            const metal = new index_1.default(API_KEY, CLIENT_ID);
            const result = metal.getOne('megadeth');
            yield expect(result).rejects.toThrowError('indexId required');
        }));
        it('should get one by id', () => __awaiter(void 0, void 0, void 0, function* () {
            const metal = new index_1.default(API_KEY, CLIENT_ID, 'index-id');
            mockedAxios.get.mockResolvedValue({
                data: { id: 'megadeth', metadata: { vocalist: 'Dave Mustain' } },
            });
            yield metal.getOne('megadeth');
            expect(axios_1.default.get).toHaveBeenCalledWith(`https://api.getmetal.io/v1/indexes/index-id/documents/megadeth`, AXIOS_OPTS);
        }));
    });
    describe('deleteOne()', () => {
        it('should error without `id`', () => __awaiter(void 0, void 0, void 0, function* () {
            const metal = new index_1.default(API_KEY, CLIENT_ID, 'index-id');
            // @ts-expect-error testing
            const result = metal.deleteOne();
            yield expect(result).rejects.toThrowError('id required');
        }));
        it('should error without `id`', () => __awaiter(void 0, void 0, void 0, function* () {
            const metal = new index_1.default(API_KEY, CLIENT_ID);
            const result = metal.deleteOne('megadeth');
            yield expect(result).rejects.toThrowError('indexId required');
        }));
        it('should del one by id', () => __awaiter(void 0, void 0, void 0, function* () {
            const metal = new index_1.default(API_KEY, CLIENT_ID, 'index-id');
            mockedAxios.delete.mockResolvedValue({
                data: null,
            });
            yield metal.deleteOne('megadeth');
            expect(axios_1.default.delete).toHaveBeenCalledWith(`https://api.getmetal.io/v1/indexes/index-id/documents/megadeth`, AXIOS_OPTS);
        }));
    });
    describe('deleteMany()', () => {
        it('should error without `ids`', () => __awaiter(void 0, void 0, void 0, function* () {
            const metal = new index_1.default(API_KEY, CLIENT_ID, 'index-id');
            // @ts-expect-error testing
            const result = metal.deleteMany();
            yield expect(result).rejects.toThrowError('ids required');
        }));
        it('should del by ids', () => __awaiter(void 0, void 0, void 0, function* () {
            const metal = new index_1.default(API_KEY, CLIENT_ID);
            mockedAxios.delete.mockResolvedValue({
                data: null,
            });
            yield metal.deleteMany(['megadeth', 'blacksabbath']);
            expect(axios_1.default.delete).toHaveBeenCalledWith(`https://api.getmetal.io/v1/documents/bulk`, Object.assign(Object.assign({}, AXIOS_OPTS), { data: { ids: ['megadeth', 'blacksabbath'] } }));
        }));
    });
});
