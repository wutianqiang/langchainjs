"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BaseClient = void 0;
const path_1 = __importDefault(require("path"));
const protobufjs_1 = __importDefault(require("protobufjs"));
const __1 = require("../");
// path
const protoPath = path_1.default.resolve(__dirname, '../../proto/proto/milvus.proto');
const schemaProtoPath = path_1.default.resolve(__dirname, '../../proto/proto/schema.proto');
/**
 * Base gRPC client, setup all configuration here
 */
class BaseClient {
    /**
     * Sets up the configuration object for the gRPC client.
     *
     * @param configOrAddress The configuration object or the Milvus address as a string.
     * @param ssl Whether to use SSL or not. Default is false.
     * @param username The username for authentication. Required if password is provided.
     * @param password The password for authentication. Required if username is provided.
     */
    constructor(configOrAddress, ssl, username, password, channelOptions) {
        // metadata
        this.metadata = new Map();
        // milvus proto
        this.protoInternalPath = {
            serviceName: 'milvus.proto.milvus.MilvusService',
            collectionSchema: 'milvus.proto.schema.CollectionSchema',
            fieldSchema: 'milvus.proto.schema.FieldSchema',
        };
        // server info
        this.serverInfo = {};
        // The timeout for connecting to the Milvus service.
        this.timeout = __1.DEFAULT_CONNECT_TIMEOUT;
        let config;
        // If a configuration object is provided, use it. Otherwise, create a new object with the provided parameters.
        if (typeof configOrAddress === 'object') {
            config = configOrAddress;
        }
        else {
            config = {
                address: configOrAddress,
                ssl,
                username,
                password,
                channelOptions,
            };
        }
        // Check if the Milvus address is set.
        if (!config.address) {
            throw new Error(__1.ERROR_REASONS.MILVUS_ADDRESS_IS_REQUIRED);
        }
        // if the address starts with https, no need to set the ssl
        config.ssl = config.address.startsWith('https://') || !!config.ssl;
        // make sure these are strings
        config.username = config.username || '';
        config.password = config.password || '';
        // Assign the configuration object.
        this.config = config;
        // Load the Milvus protobuf.
        this.protoPath = protoPath;
        this.schemaProto = protobufjs_1.default.loadSync(schemaProtoPath);
        this.milvusProto = protobufjs_1.default.loadSync(protoPath);
        // Get the CollectionSchemaType and FieldSchemaType from the schemaProto object.
        this.collectionSchemaType = this.schemaProto.lookupType(this.protoInternalPath.collectionSchema);
        this.fieldSchemaType = this.schemaProto.lookupType(this.protoInternalPath.fieldSchema);
        // options
        this.channelOptions = Object.assign({ 
            // Milvus default max_receive_message_length is 100MB, but Milvus support change max_receive_message_length .
            // So SDK should support max_receive_message_length unlimited.
            'grpc.max_receive_message_length': -1, 'grpc.max_send_message_length': -1, 'grpc.keepalive_time_ms': 10 * 1000, 'grpc.keepalive_timeout_ms': 5 * 1000, 'grpc.keepalive_permit_without_calls': 1, 'grpc.enable_retries': 1 }, this.config.channelOptions);
        // Set up the timeout for connecting to the Milvus service.
        this.timeout =
            typeof config.timeout === 'string'
                ? (0, __1.parseTimeToken)(config.timeout)
                : config.timeout || __1.DEFAULT_CONNECT_TIMEOUT;
    }
}
exports.BaseClient = BaseClient;
//# sourceMappingURL=BaseClient.js.map