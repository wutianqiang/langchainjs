"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.VectorDocumentStore = void 0;
const core_1 = require("@tigrisdata/core");
/**
 * A vector store that uses Tigris to store and search for documents.
 */
class VectorDocumentStore {
    constructor(config) {
        const tigrisClient = new core_1.Tigris(config.connection);
        this._searchClient = tigrisClient.getSearch();
        this._indexName = config.indexName;
        this._numDimensions = config.numDimensions;
    }
    /**
     * Ensure that the index exists and is ready to use. Will not do anything if
     * the index already exists.
     */
    enusreIndex() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this._index) {
                return;
            }
            const indexSchema = {
                id: {
                    type: core_1.TigrisDataTypes.STRING,
                    searchIndex: true,
                    id: true,
                },
                content: {
                    type: core_1.TigrisDataTypes.STRING,
                    searchIndex: true,
                },
                metadata: {
                    type: core_1.TigrisDataTypes.OBJECT,
                    searchIndex: true,
                },
                vectors: {
                    type: core_1.TigrisDataTypes.ARRAY,
                    items: {
                        type: core_1.TigrisDataTypes.NUMBER,
                    },
                    searchIndex: true,
                    dimensions: this._numDimensions,
                },
            };
            this._index = yield this._searchClient.createOrUpdateIndex(this._indexName, indexSchema);
        });
    }
    /**
     * Deletes the index.
     * @returns A promise that resolves when the index has been deleted
     */
    deleteIndex() {
        return __awaiter(this, void 0, void 0, function* () {
            return this._searchClient.deleteIndex(this._indexName);
        });
    }
    /**
     * Add documents to the index.
     * @param ids The IDs of the documents to add
     * @param embeddings The embeddings of the documents to add
     * @param documents The documents to add
     * @returns A promise that resolves when the documents have been added
     */
    addDocumentsWithVectors({ ids, embeddings, documents, }) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.enusreIndex();
            const documentsToAdd = documents.map((document, index) => {
                return {
                    id: ids[index],
                    content: document.content,
                    metadata: document.metadata,
                    vectors: embeddings[index],
                };
            });
            return this._index.createOrReplaceMany(documentsToAdd);
        });
    }
    /**
     * Delete documents from the index.
     * @param ids The IDs of the documents to delete
     * @returns A promise that resolves when the documents have been deleted
     * successfully
     */
    deleteDocuments(ids) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.enusreIndex();
            return this._index.deleteMany(ids);
        });
    }
    /**
     * Delete documents from the index by filter.
     * @param filter The filter to apply to the documents to delete
     * @returns A promise that resolves when the documents have been deleted
     * successfully
     */
    deleteDocumentsByFilter(filter) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.enusreIndex();
            return this._index.deleteByQuery(filter);
        });
    }
    /**
     * Get documents from the index by ID.
     * @param ids The IDs of the documents to get
     * @returns A promise that resolves to an array of documents fetched
     * successfully
     */
    getDocuments(ids) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.enusreIndex();
            const response = yield this._index.getMany(ids);
            return response.map((document) => {
                return {
                    content: document.document.content,
                    metadata: document.document.metadata,
                };
            });
        });
    }
    /**
     * Search for the most similar documents to a query,
     * when you already have the embedding of the query.
     * @param embeddings The embeddings to search for
     * @param k The number of results to return
     * @param filter An optional filter to apply to the search
     * @returns A promise that resolves to an array of matched documents
     */
    similaritySearchVector({ query, k, filter, }) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.enusreIndex();
            const results = [];
            // fetch the first page of results only
            const response = yield this.search({ query, k, filter });
            for (const hit of response.hits) {
                results.push({
                    content: hit.document.content,
                    metadata: hit.document.metadata,
                });
            }
            return results;
        });
    }
    /**
     * Search for the most similar documents to a query,
     * when you already have the embedding of the query.
     * @param embeddings The embeddings to search for
     * @param k The number of results to return
     * @param filter An optional filter to apply to the search
     * @returns A promise that resolves to an array of matched documents and their scores
     */
    similaritySearchVectorWithScore({ query, k, filter, }) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.enusreIndex();
            const results = [];
            // fetch the first page of results only
            const response = yield this.search({ query, k, filter });
            for (const hit of response.hits) {
                results.push([
                    {
                        content: hit.document.content,
                        metadata: hit.document.metadata,
                    },
                    hit.meta.textMatch.vectorDistance,
                ]);
            }
            return results;
        });
    }
    /**
     * Search for the most similar documents to a query,
     * when you already have the embedding of the query.
     * @param query The embeddings to search for
     * @param k The number of results to return
     * @param filter An optional filter to apply to the search
     * @returns A promise that resolves to the search results
     */
    search({ query, k, filter, }) {
        return __awaiter(this, void 0, void 0, function* () {
            const request = {
                vectorQuery: {
                    vectors: query,
                },
                filter,
                hitsPerPage: k,
            };
            // fetch the first page of results only
            return this._index.search(request, 1);
        });
    }
    get searchClient() {
        return this._searchClient;
    }
    get index() {
        return this._index;
    }
}
exports.VectorDocumentStore = VectorDocumentStore;
