"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Tigris = void 0;
const api_grpc_pb_1 = require("./proto/server/v1/api_grpc_pb");
const observability_grpc_pb_1 = require("./proto/server/v1/observability_grpc_pb");
const health_grpc_pb_1 = require("./proto/server/v1/health_grpc_pb");
const grpc = __importStar(require("@grpc/grpc-js"));
const grpc_js_1 = require("@grpc/grpc-js");
const observability_pb_1 = require("./proto/server/v1/observability_pb");
const health_pb_1 = require("./proto/server/v1/health_pb");
const types_1 = require("./types");
const auth_pb_1 = require("./proto/server/v1/auth_pb");
const db_1 = require("./db");
const auth_grpc_pb_1 = require("./proto/server/v1/auth_grpc_pb");
const utility_1 = require("./utility");
const logger_1 = require("./utils/logger");
const globals_1 = require("./globals");
const cache_1 = require("./cache");
const cache_grpc_pb_1 = require("./proto/server/v1/cache_grpc_pb");
const cache_pb_1 = require("./proto/server/v1/cache_pb");
const env_loader_1 = require("./utils/env-loader");
const search_grpc_pb_1 = require("./proto/server/v1/search_grpc_pb");
const search_1 = require("./search");
const AuthorizationHeaderName = "authorization";
const AuthorizationBearer = "Bearer ";
class TokenSupplier {
    constructor(config) {
        this.authClient = new auth_grpc_pb_1.AuthClient(config.serverUrl, grpc.credentials.createSsl());
        this.clientId = config.clientId;
        this.clientSecret = config.clientSecret;
        this.config = config;
    }
    getAccessToken() {
        return new Promise((resolve, reject) => {
            if (this.shouldRefresh()) {
                // refresh
                this.authClient.getAccessToken(new auth_pb_1.GetAccessTokenRequest()
                    .setGrantType(auth_pb_1.GrantType.CLIENT_CREDENTIALS)
                    .setClientId(this.clientId)
                    .setClientSecret(this.clientSecret), (error, response) => {
                    if (error) {
                        reject(error);
                    }
                    else {
                        this.accessToken = response.getAccessToken();
                        // retrieve exp
                        const parts = this.accessToken.split(".");
                        const exp = Number(utility_1.Utility.jsonStringToObj(utility_1.Utility._base64Decode(parts[1]), this.config)["exp"]);
                        // 5 min before expiry (note: exp is in seconds)
                        // add random jitter of 1-5 min (i.e. 60000 - 300000 ms)
                        this.nextRefreshTime =
                            exp * 1000 - 300000 - (utility_1.Utility._getRandomInt(300000) + 60000);
                        resolve(this.accessToken);
                    }
                });
            }
            else {
                resolve(this.accessToken);
            }
        });
    }
    shouldRefresh() {
        if (typeof this.accessToken === "undefined") {
            return true;
        }
        return Date.now() >= this.nextRefreshTime;
    }
}
const DEFAULT_GRPC_PORT = 443;
const DEFAULT_URL = "api.preview.tigrisdata.cloud";
const USER_AGENT_KEY = "user-agent";
const USER_AGENT_VAL = "tigris-client-ts.grpc";
const DEST_NAME_KEY = "destination-name";
/**
 * Tigris client
 */
class Tigris {
    /**
     * Create Tigris client
     *
     * @param  config - {@link TigrisClientConfig} configuration
     */
    constructor(config) {
        var _a, _b;
        (0, env_loader_1.initializeEnvironment)();
        if (typeof config === "undefined") {
            config = {};
        }
        if (config.serverUrl === undefined) {
            config.serverUrl = DEFAULT_URL;
            if (((_a = process.env.TIGRIS_URI) === null || _a === void 0 ? void 0 : _a.trim().length) > 0) {
                config.serverUrl = process.env.TIGRIS_URI;
            }
            if (((_b = process.env.TIGRIS_URL) === null || _b === void 0 ? void 0 : _b.trim().length) > 0) {
                config.serverUrl = process.env.TIGRIS_URL;
            }
        }
        if (config.projectName === undefined) {
            if (!("TIGRIS_PROJECT" in process.env)) {
                throw new Error("Unable to resolve TIGRIS_PROJECT environment variable");
            }
            config.projectName = process.env.TIGRIS_PROJECT;
        }
        if (config.serverUrl.startsWith("https://")) {
            config.serverUrl = config.serverUrl.replace("https://", "");
        }
        if (config.serverUrl.startsWith("http://")) {
            config.serverUrl = config.serverUrl.replace("http://", "");
        }
        if (config.clientId === undefined && "TIGRIS_CLIENT_ID" in process.env) {
            config.clientId = process.env.TIGRIS_CLIENT_ID;
        }
        if (config.clientSecret === undefined && "TIGRIS_CLIENT_SECRET" in process.env) {
            config.clientSecret = process.env.TIGRIS_CLIENT_SECRET;
        }
        if (!config.serverUrl.includes(":")) {
            config.serverUrl = config.serverUrl + ":" + DEFAULT_GRPC_PORT;
        }
        this._config = config;
        const defaultMetadata = new grpc_js_1.Metadata();
        defaultMetadata.set(USER_AGENT_KEY, USER_AGENT_VAL);
        defaultMetadata.set(DEST_NAME_KEY, config.serverUrl);
        // TODO: expose retry config to end user once validated
        const svcConfig = {
            loadBalancingConfig: [],
            methodConfig: [
                {
                    name: [
                        {
                            service: "tigrisdata.v1.Tigris",
                        },
                        {
                            service: "tigrisdata.search.v1.Search",
                        },
                    ],
                    waitForReady: true,
                    retryPolicy: {
                        maxAttempts: 3,
                        initialBackoff: "0.1s",
                        maxBackoff: "1.0s",
                        backoffMultiplier: 1.5,
                        retryableStatusCodes: [
                            grpc_js_1.status.UNAVAILABLE,
                            grpc_js_1.status.UNKNOWN,
                            grpc_js_1.status.INTERNAL,
                            grpc_js_1.status.RESOURCE_EXHAUSTED,
                        ],
                    },
                },
            ],
        };
        const grpcOptions = {
            "grpc.service_config": JSON.stringify(svcConfig),
            "grpc.enable_retries": 1,
        };
        if ((config.serverUrl.includes("localhost") ||
            config.serverUrl.startsWith("tigris-local-server:") ||
            config.serverUrl.includes("127.0.0.1") ||
            config.serverUrl.includes("[::1]")) &&
            config.clientId === undefined &&
            config.clientSecret === undefined) {
            // no auth - generate insecure channel
            const insecureCreds = grpc.credentials.createInsecure();
            this.grpcClient = new api_grpc_pb_1.TigrisClient(config.serverUrl, insecureCreds, grpcOptions);
            this.observabilityClient = new observability_grpc_pb_1.ObservabilityClient(config.serverUrl, insecureCreds);
            this.cacheClient = new cache_grpc_pb_1.CacheClient(config.serverUrl, insecureCreds);
            this.searchClient = new search_grpc_pb_1.SearchClient(config.serverUrl, insecureCreds, grpcOptions);
            this.healthAPIClient = new health_grpc_pb_1.HealthAPIClient(config.serverUrl, insecureCreds);
        }
        else if (config.clientId === undefined || config.clientSecret === undefined) {
            throw new Error("Both `clientId` and `clientSecret` are required");
        }
        else {
            // auth & secure channel
            const tokenSupplier = new TokenSupplier(config);
            const channelCreds = grpc.credentials.combineChannelCredentials(grpc.credentials.createSsl(), grpc.credentials.createFromMetadataGenerator((params, callback) => {
                tokenSupplier
                    .getAccessToken()
                    .then((accessToken) => {
                    const md = new grpc.Metadata();
                    md.set(AuthorizationHeaderName, AuthorizationBearer + accessToken);
                    md.merge(defaultMetadata);
                    return callback(undefined, md);
                })
                    .catch((error) => {
                    return callback(error);
                });
            }));
            this.grpcClient = new api_grpc_pb_1.TigrisClient(config.serverUrl, channelCreds, grpcOptions);
            this.observabilityClient = new observability_grpc_pb_1.ObservabilityClient(config.serverUrl, channelCreds);
            this.cacheClient = new cache_grpc_pb_1.CacheClient(config.serverUrl, channelCreds);
            this.searchClient = new search_grpc_pb_1.SearchClient(config.serverUrl, channelCreds, grpcOptions);
            this.healthAPIClient = new health_grpc_pb_1.HealthAPIClient(config.serverUrl, channelCreds);
            this._ping = () => {
                this.healthAPIClient.health(new health_pb_1.HealthCheckInput(), (error, response) => {
                    if (response !== undefined) {
                        logger_1.Log.debug("health: " + response.getResponse());
                    }
                });
            };
            if (config.enablePing) {
                // make a ping to server at configured interval
                let pingIntervalMs = config.pingIntervalMs;
                if (pingIntervalMs === undefined) {
                    // 5min
                    pingIntervalMs = 300000;
                }
                this.pingId = setInterval(this._ping, pingIntervalMs);
                // stop ping on shutdown
                process.on("exit", () => {
                    this.close();
                });
            }
        }
        this._metadataStorage = (0, globals_1.getDecoratorMetaStorage)();
        logger_1.Log.info(`Using Tigris at: ${config.serverUrl}`);
    }
    getDatabase() {
        return new db_1.DB(this._config.projectName, this.grpcClient, this._config);
    }
    /**
     * Creates the cache for this project, if the cache doesn't already exist
     * @param name - cache identifier
     */
    createCacheIfNotExists(name) {
        return new Promise((resolve, reject) => {
            this.cacheClient.createCache(new cache_pb_1.CreateCacheRequest().setProject(this._config.projectName).setName(name), 
            // eslint-disable-next-line @typescript-eslint/no-unused-vars
            (error, response) => {
                if (error && error.code != grpc_js_1.status.ALREADY_EXISTS) {
                    reject(error);
                }
                else {
                    resolve(new cache_1.Cache(this._config.projectName, name, this.cacheClient, this._config));
                }
            });
        });
    }
    /**
     * Deletes the entire cache from this project.
     * @param name - cache identifier
     */
    deleteCache(name) {
        return new Promise((resolve, reject) => {
            this.cacheClient.deleteCache(new cache_pb_1.DeleteCacheRequest().setProject(this._config.projectName).setName(name), (error, response) => {
                if (error) {
                    reject(error);
                }
                else {
                    resolve(new types_1.DeleteCacheResponse(response.getMessage()));
                }
            });
        });
    }
    /**
     * Lists all the caches for this project
     */
    listCaches() {
        return new Promise((resolve, reject) => {
            this.cacheClient.listCaches(new cache_pb_1.ListCachesRequest().setProject(this._config.projectName), (error, response) => {
                if (error) {
                    reject(error);
                }
                else {
                    const cachesMetadata = new Array();
                    for (const value of response.getCachesList())
                        cachesMetadata.push(new types_1.CacheMetadata(value.getName()));
                    resolve(new types_1.ListCachesResponse(cachesMetadata));
                }
            });
        });
    }
    getCache(cacheName) {
        return new cache_1.Cache(this._config.projectName, cacheName, this.cacheClient, this._config);
    }
    getSearch() {
        return new search_1.Search(this.searchClient, this._config);
    }
    getServerMetadata() {
        return new Promise((resolve, reject) => {
            this.observabilityClient.getInfo(new observability_pb_1.GetInfoRequest(), (error, response) => {
                if (error) {
                    reject(error);
                }
                else {
                    resolve(new types_1.ServerMetadata(response.getServerVersion()));
                }
            });
        });
    }
    /**
     * Automatically create Project and create or update Collections.
     * Collection classes decorated with {@link TigrisCollection} decorator will be
     * created if not already existing. If Collection already exists, schema changes
     * will be applied, if any.
     *
     * @param collections - Array of Collection classes
     *
     * @example
     * ```
     * @TigrisCollection("todoItems")
     * class TodoItem {
     *   @PrimaryKey(TigrisDataTypes.INT32, { order: 1 })
     *   id: number;
     *
     *   @Field()
     *   text: string;
     * }
     *
     * await db.registerSchemas([TodoItem]);
     * ```
     */
    registerSchemas(collections) {
        return __awaiter(this, void 0, void 0, function* () {
            const tigrisDb = this.getDatabase();
            for (const coll of collections) {
                const found = this._metadataStorage.getCollectionByTarget(coll);
                if (!found) {
                    logger_1.Log.error(`No such collection defined: '${coll.toString()}'`);
                }
                else {
                    yield tigrisDb.createOrUpdateCollection(found.target.prototype.constructor);
                }
            }
        });
    }
    /**
     * Shutdown, if ping is being used in order to keep connection alive.
     */
    close() {
        if (this.pingId !== undefined) {
            clearInterval(this.pingId);
        }
    }
}
exports.Tigris = Tigris;
