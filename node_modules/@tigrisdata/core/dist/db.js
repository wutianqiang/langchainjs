"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DB = void 0;
const types_1 = require("./types");
const api_pb_1 = require("./proto/server/v1/api_pb");
const collection_1 = require("./collection");
const session_1 = require("./session");
const utility_1 = require("./utility");
const grpc_js_1 = require("@grpc/grpc-js");
const decorated_schema_processor_1 = require("./schema/decorated-schema-processor");
const logger_1 = require("./utils/logger");
const globals_1 = require("./globals");
const error_1 = require("./error");
const constants_1 = require("@grpc/grpc-js/build/src/constants");
const SetCookie = "Set-Cookie";
const Cookie = "Cookie";
const BeginTransactionMethodName = "/tigrisdata.v1.Tigris/BeginTransaction";
const DefaultBranch = "main";
/**
 * Tigris Database class to manage database branches, collections and execute
 * transactions.
 */
class DB {
    /**
     * Create an instance of Tigris Database class.
     *
     * @example Recommended way to create instance using {@link TigrisClient.getDatabase}
     * ```
     * const client = new TigrisClient();
     * const db = client.getDatabase();
     * ```
     */
    constructor(db, grpcClient, config) {
        this._name = db;
        this.grpcClient = grpcClient;
        this.config = config;
        this.schemaProcessor = decorated_schema_processor_1.DecoratedSchemaProcessor.Instance;
        this._metadataStorage = (0, globals_1.getDecoratorMetaStorage)();
        this._branch = utility_1.Utility.branchNameFromEnv(config.branch);
        if (!this._branch) {
            throw new error_1.BranchNameRequiredError();
        }
    }
    createOrUpdateCollection(nameOrClass, schema) {
        let collectionName;
        if (typeof nameOrClass === "string") {
            collectionName = nameOrClass;
        }
        else {
            const generatedColl = this.schemaProcessor.processCollection(nameOrClass);
            collectionName = generatedColl.name;
            schema = generatedColl.schema;
        }
        return this.createOrUpdate(collectionName, schema, () => new collection_1.Collection(collectionName, this._name, this.branch, this.grpcClient, this.config));
    }
    createOrUpdate(name, schema, resolver) {
        return new Promise((resolve, reject) => {
            const rawJSONSchema = utility_1.Utility._collectionSchematoJSON(name, schema);
            const createOrUpdateCollectionRequest = new api_pb_1.CreateOrUpdateCollectionRequest()
                .setProject(this._name)
                .setBranch(this.branch)
                .setCollection(name)
                .setOnlyCreate(false)
                .setSchema(utility_1.Utility.stringToUint8Array(rawJSONSchema));
            logger_1.Log.event(`Creating collection: '${name}' in project: '${this._name}'`);
            this.grpcClient.createOrUpdateCollection(createOrUpdateCollectionRequest, 
            // eslint-disable-next-line @typescript-eslint/no-unused-vars
            (error, _response) => {
                if (error) {
                    reject(error);
                    return;
                }
                resolve(resolver());
            });
        });
    }
    listCollections(options) {
        return new Promise((resolve, reject) => {
            const request = new api_pb_1.ListCollectionsRequest()
                .setProject(this.name)
                .setBranch(this.branch);
            if (typeof options !== "undefined") {
                return request.setOptions(new api_pb_1.CollectionOptions());
            }
            this.grpcClient.listCollections(request, (error, response) => {
                if (error) {
                    reject(error);
                }
                else {
                    const result = response
                        .getCollectionsList()
                        .map((collectionInfo) => new types_1.CollectionInfo(collectionInfo.getCollection(), new types_1.CollectionMetadata()));
                    resolve(result);
                }
            });
        });
    }
    dropCollection(nameOrClass) {
        const collectionName = this.resolveNameFromCollectionClass(nameOrClass);
        return new Promise((resolve, reject) => {
            this.grpcClient.dropCollection(new api_pb_1.DropCollectionRequest()
                .setProject(this.name)
                .setBranch(this.branch)
                .setCollection(collectionName), (error, response) => {
                if (error) {
                    reject(error);
                }
                else {
                    resolve(new types_1.DropCollectionResponse(response.getMessage()));
                }
            });
        });
    }
    dropAllCollections() {
        return __awaiter(this, void 0, void 0, function* () {
            const collections = yield this.listCollections();
            const dropPromises = collections.map((coll) => {
                return this.dropCollection(coll.name);
            });
            return Promise.allSettled(dropPromises);
        });
    }
    describe() {
        return new Promise((resolve, reject) => {
            this.grpcClient.describeDatabase(new api_pb_1.DescribeDatabaseRequest().setProject(this.name).setBranch(this.branch), (error, response) => {
                if (error) {
                    reject(error);
                }
                else {
                    const collectionsDescription = [];
                    for (let i = 0; i < response.getCollectionsList().length; i++) {
                        collectionsDescription.push(new types_1.CollectionDescription(response.getCollectionsList()[i].getCollection(), new types_1.CollectionMetadata(), response.getCollectionsList()[i].getSchema_asB64()));
                    }
                    resolve(new types_1.DatabaseDescription(new types_1.DatabaseMetadata(), collectionsDescription, response.getBranchesList()));
                }
            });
        });
    }
    getCollection(nameOrClass) {
        const collectionName = this.resolveNameFromCollectionClass(nameOrClass);
        return new collection_1.Collection(collectionName, this.name, this.branch, this.grpcClient, this.config);
    }
    resolveNameFromCollectionClass(nameOrClass) {
        let collectionName;
        if (typeof nameOrClass === "string") {
            collectionName = nameOrClass;
        }
        else {
            const coll = this._metadataStorage.getCollectionByTarget(nameOrClass);
            if (!coll) {
                throw new error_1.CollectionNotFoundError(nameOrClass.toString());
            }
            collectionName = coll.collectionName;
        }
        return collectionName;
    }
    transact(fn) {
        return new Promise((resolve, reject) => {
            this.beginTransaction()
                .then((session) => __awaiter(this, void 0, void 0, function* () {
                // tx started
                try {
                    // invoke user code
                    yield fn(session);
                    // user code successful
                    const commitResponse = yield session.commit();
                    if (commitResponse) {
                        resolve(new types_1.TransactionResponse());
                    }
                }
                catch (error) {
                    // failed to run user code
                    yield session.rollback();
                    // pass error to user
                    reject(error);
                }
            }))
                .catch((error) => reject(error));
        });
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    beginTransaction(_options) {
        return new Promise((resolve, reject) => {
            const beginTxRequest = new api_pb_1.BeginTransactionRequest()
                .setProject(this._name)
                .setBranch(this.branch);
            const cookie = new grpc_js_1.Metadata();
            const call = this.grpcClient.makeUnaryRequest(BeginTransactionMethodName, (value) => Buffer.from(value.serializeBinary()), (value) => api_pb_1.BeginTransactionResponse.deserializeBinary(value), beginTxRequest, (error, response) => {
                if (error) {
                    reject(error);
                }
                else {
                    // on metadata is expected to have invoked at this point since response
                    // is served
                    resolve(new session_1.Session(response.getTxCtx().getId(), response.getTxCtx().getOrigin(), this.grpcClient, this.name, this.branch, cookie));
                }
            });
            call.on("metadata", (metadata) => {
                if (metadata.get(SetCookie)) {
                    for (const inboundCookie of metadata.get(SetCookie))
                        cookie.add(Cookie, inboundCookie);
                }
            });
        });
    }
    createBranch(name) {
        return new Promise((resolve, reject) => {
            const req = new api_pb_1.CreateBranchRequest().setProject(this.name).setBranch(name);
            this.grpcClient.createBranch(req, (error, response) => {
                if (error) {
                    reject(error);
                    return;
                }
                resolve(types_1.CreateBranchResponse.from(response));
            });
        });
    }
    deleteBranch(name) {
        return new Promise((resolve, reject) => {
            const req = new api_pb_1.DeleteBranchRequest().setProject(this.name).setBranch(name);
            this.grpcClient.deleteBranch(req, (error, response) => {
                if (error) {
                    reject(error);
                    return;
                }
                resolve(types_1.DeleteBranchResponse.from(response));
            });
        });
    }
    /**
     * Creates a database branch, if not existing already.
     *
     * @example
     * ```
     * const client = new TigrisClient();
     * const db = client.getDatabase();
     * await db.initializeBranch();
     * ```
     *
     * @throws {@link Promise.reject} - Error if branch cannot be created
     */
    initializeBranch() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.usingDefaultBranch) {
                try {
                    yield this.createBranch(this.branch);
                    logger_1.Log.event(`Created database branch: '${this.branch}'`);
                }
                catch (error) {
                    if (error.code === constants_1.Status.ALREADY_EXISTS) {
                        logger_1.Log.event(`'${this.branch}' branch already exists`);
                    }
                    else {
                        throw error;
                    }
                }
            }
            logger_1.Log.info(`Using database branch: '${this.branch}'`);
        });
    }
    get name() {
        return this._name;
    }
    get branch() {
        return this._branch;
    }
    get usingDefaultBranch() {
        return this.branch === DefaultBranch;
    }
}
exports.DB = DB;
