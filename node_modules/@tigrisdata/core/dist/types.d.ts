import { CreateBranchResponse as ProtoCreateBranchResponse, DeleteBranchResponse as ProtoDeleteBranchResponse } from "./proto/server/v1/api_pb";
import { Status } from "./constants";
import { Collation } from "./search/query";
import { SearchFieldOptions } from "./search";
export declare class DatabaseInfo {
    private readonly _name;
    private readonly _metadata;
    constructor(name: string, metadata: DatabaseMetadata);
    get name(): string;
    get metadata(): DatabaseMetadata;
}
export declare class CollectionInfo {
    private readonly _name;
    private readonly _metadata;
    constructor(name: string, metadata: CollectionMetadata);
    get name(): string;
    get metadata(): CollectionMetadata;
}
export declare class DatabaseMetadata {
}
export declare class CollectionMetadata {
}
export declare class DatabaseOptions {
}
export declare class CollectionOptions {
}
export interface TigrisResponse {
    status: Status;
    message?: string;
}
export declare class CreateBranchResponse implements TigrisResponse {
    status: Status;
    private readonly _message;
    constructor(message: string);
    get message(): string;
    static from(response: ProtoCreateBranchResponse): CreateBranchResponse;
}
export declare class DeleteBranchResponse implements TigrisResponse {
    status: Status;
    private readonly _message;
    constructor(message: string);
    get message(): string;
    static from(response: ProtoDeleteBranchResponse): DeleteBranchResponse;
}
export declare class DropCollectionResponse implements TigrisResponse {
    status: Status;
    private readonly _message;
    constructor(message: string);
    get message(): string;
}
export declare class DatabaseDescription {
    private readonly _metadata;
    private readonly _collectionsDescription;
    private readonly _branches;
    constructor(metadata: DatabaseMetadata, collectionsDescription: Array<CollectionDescription>, branches: Array<string>);
    get metadata(): DatabaseMetadata;
    get collectionsDescription(): ReadonlyArray<CollectionDescription>;
    get branches(): ReadonlyArray<string>;
}
declare type IndexState = "INDEX WRITE MODE" | "INDEX ACTIVE";
export declare type IndexField = {
    name: string;
};
export declare type IndexDescription = {
    name: string;
    state: IndexState;
    fields?: IndexField[];
};
export declare class CollectionDescription {
    private readonly _collection;
    private readonly _metadata;
    private readonly _schema;
    private readonly _indexDescriptions?;
    constructor(collection: string, metadata: CollectionMetadata, schema: string, indexDescriptions?: IndexDescription[]);
    get collection(): string;
    get metadata(): CollectionMetadata;
    get schema(): string;
    get indexDescriptions(): IndexDescription[];
}
export declare class DMLMetadata {
    private readonly _createdAt;
    private readonly _updatedAt;
    constructor(createdAt: Date, updatedAt: Date);
    get createdAt(): Date;
    get updatedAt(): Date;
}
export interface DMLResponse {
    metadata: DMLMetadata;
}
export declare class DeleteResponse implements TigrisResponse, DMLResponse {
    status: Status;
    private readonly _metadata;
    constructor(metadata: DMLMetadata);
    get metadata(): DMLMetadata;
}
export declare class UpdateResponse implements TigrisResponse, DMLResponse {
    status: Status;
    private readonly _metadata;
    private readonly _modifiedCount;
    constructor(modifiedCount: number, metadata: DMLMetadata);
    get modifiedCount(): number;
    get metadata(): DMLMetadata;
}
export declare class WriteOptions {
}
export declare class DeleteQueryOptions {
    private _collation;
    private _limit;
    constructor(limit: number, collation?: Collation);
    get limit(): number;
    set limit(value: number);
    get collation(): Collation;
    set collation(value: Collation);
}
export declare class UpdateQueryOptions {
    private _collation;
    private _limit;
    constructor(limit: number, collation?: Collation);
    get limit(): number;
    set limit(value: number);
    get collation(): Collation;
    set collation(value: Collation);
}
export declare class FindQueryOptions {
    static DEFAULT_LIMIT: number;
    static DEFAULT_SKIP: number;
    private _limit;
    private _skip;
    private _offset;
    private _collation;
    constructor(limit?: number);
    constructor(limit: number, skip: number);
    constructor(limit?: number, skip?: number, offset?: string);
    get limit(): number;
    set limit(value: number);
    get skip(): number;
    set skip(value: number);
    get offset(): string;
    set offset(value: string);
    get collation(): Collation;
    set collation(value: Collation);
}
export declare class TransactionOptions {
}
export declare class CommitTransactionResponse implements TigrisResponse {
    status: Status;
    private readonly _message;
    constructor(message: string);
    get message(): string;
}
export declare class RollbackTransactionResponse implements TigrisResponse {
    status: Status;
    private readonly _message;
    constructor(message: string);
    get message(): string;
}
export declare class TransactionResponse implements TigrisResponse {
    status: Status;
}
export declare class CacheMetadata {
    private readonly _name;
    constructor(name: string);
    get name(): string;
}
export declare class ListCachesResponse {
    private readonly _caches;
    constructor(caches: CacheMetadata[]);
    get caches(): CacheMetadata[];
}
export declare class DeleteCacheResponse implements TigrisResponse {
    status: Status;
    private readonly _message;
    constructor(message: string);
    get message(): string;
}
export declare class CacheSetResponse implements TigrisResponse {
    status: Status;
    private readonly _message;
    constructor(message: string);
    get message(): string;
}
export declare class CacheGetSetResponse extends CacheSetResponse {
    private readonly _old_value;
    constructor(message: string, old_value?: object);
    get old_value(): object;
}
export declare class CacheDelResponse implements TigrisResponse {
    status: Status;
    private readonly _message;
    constructor(status: string, message: string);
    get message(): string;
}
export interface CacheSetOptions {
    ex?: number;
    px?: number;
    nx?: boolean;
    xx?: boolean;
}
export declare class CacheGetResponse {
    private readonly _value;
    constructor(value: object);
    get value(): object;
}
export declare class ServerMetadata {
    private readonly _serverVersion;
    constructor(serverVersion: string);
    get serverVersion(): string;
}
export interface TigrisCollectionType {
}
export declare type NumericType = number | bigint;
export declare type FieldTypes = string | boolean | NumericType | BigInteger | Date | object;
export declare type ReadFields<T> = {
    include?: Array<DocumentPaths<T>>;
    exclude?: Array<DocumentPaths<T>>;
};
declare type DocumentFields<T, V> = Partial<{
    [K in Paths<T>]: V;
}>;
export declare type UpdateFields<T> = {
    $set?: DocumentFields<T, FieldTypes | undefined>;
    $unset?: Partial<Paths<T>>[];
    $increment?: DocumentFields<T, NumericType>;
    $decrement?: DocumentFields<T, NumericType>;
    $multiply?: DocumentFields<T, NumericType>;
    $divide?: DocumentFields<T, NumericType>;
    $push?: DocumentFields<T, FieldTypes | undefined>;
} | DocumentFields<T, FieldTypes | undefined>;
/**
 * List of fields and their corresponding sort order to order the search results.
 */
export declare type SortOrder<T> = SortField<T> | Array<SortField<T>>;
/**
 * Collection field name and sort order
 */
export declare type SortField<T> = {
    field: DocumentPaths<T>;
    order: "$asc" | "$desc";
};
/**
 * Group by fields
 */
export declare type GroupByField = {
    fields: Array<string>;
};
/**
 * Query builder for reading documents from a collection
 * @public
 */
export interface FindQuery<T> {
    /**
     * Filter to match the documents. Query will match all documents without a filter.
     */
    filter?: Filter<T>;
    /**
     * Field projection to allow returning only specific document fields. By default
     * all document fields are returned.
     */
    readFields?: ReadFields<T>;
    /**
     * Sort the query results as per indicated order
     */
    sort?: SortOrder<T>;
    /**
     * Optional params
     */
    options?: FindQueryOptions;
}
/**
 * Query builder for deleting documents from a collection
 * @public
 */
export interface DeleteQuery<T> {
    /**
     * Filter to match the documents
     */
    filter: Filter<T>;
    /**
     * Optional params
     */
    options?: DeleteQueryOptions;
}
/**
 * Query builder for updating documents in a collection
 * @public
 */
export interface UpdateQuery<T> {
    /**
     * Filter to match the documents
     */
    filter: Filter<T>;
    /**
     * Document fields to update and the update operation
     */
    fields: UpdateFields<T>;
    /**
     * Optional params
     */
    options?: UpdateQueryOptions;
}
export declare type ReadType = "primary index" | "secondary index";
/**
 * Explain Response
 *  @public
 */
export interface ExplainResponse {
    /**
     * Filter used to match the documents
     */
    filter: string;
    /**
     * Sets whether the query read from the primary index or a secondary index
     */
    readType: ReadType;
    /**
     * The field used to read from the secondary index
     */
    field?: string;
    /**
     * The key range used to query the secondary index
     */
    keyRange?: string[];
    /**
     * Sort field
     */
    sort?: string;
}
export declare enum TigrisDataTypes {
    STRING = "string",
    BOOLEAN = "boolean",
    INT32 = "int32",
    /**
     * Due to Javascript's limitation if you want to use int64 with values greater than 53bits
     * then use bigint or string in your model (data container interface) schema will still say
     * INT64. If you are using default serializer/deserializer
     * in your application use it as `string`. server will still keep it as `int64`.
     *
     * If you have no serde else where in the app or all the serde are handling bigint properly
     * then use bigint.
     */
    INT64 = "int64",
    NUMBER = "number",
    NUMBER_BIGINT = "bigint",
    DATE_TIME = "date-time",
    BYTE_STRING = "byte-string",
    UUID = "uuid",
    ARRAY = "array",
    OBJECT = "object"
}
/**
 * DB generated values for the schema fields
 */
export declare enum GeneratedField {
    NOW = "now()",
    CUID = "cuid()",
    UUID = "uuid()"
}
export declare type AutoTimestamp = "createdAt" | "updatedAt";
export declare type CollectionFieldOptions = {
    /**
     * Max length for "string" type of fields
     */
    maxLength?: number;
    /**
     * Default value for the schema field
     */
    default?: GeneratedField | FieldTypes | Array<unknown> | Record<string, unknown>;
    /**
     * Let DB generate values for `Date` type of fields
     */
    timestamp?: AutoTimestamp;
    /**
     * Dimensions for a vector field
     */
    dimensions?: number;
    /**
     * Create a secondary index on the field
     */
    index?: boolean;
};
export declare type TigrisSchema<T extends TigrisCollectionType> = {
    [K in keyof T]: {
        type: TigrisDataTypes | TigrisSchema<unknown>;
        primary_key?: PrimaryKeyOptions;
        items?: TigrisArrayItem;
    } & CollectionFieldOptions & SearchFieldOptions;
};
export declare type TigrisArrayItem = {
    type: TigrisDataTypes | TigrisSchema<unknown>;
    items?: TigrisArrayItem | TigrisDataTypes;
};
export declare type PrimaryKeyOptions = {
    order?: number;
    autoGenerate?: boolean;
};
/**
 * Generates all possible paths for type parameter T. By recursively iterating over its keys. While
 * iterating the keys it makes the keys available in string form and in non string form both. For
 * @example
 * ```
 * interface IUser {
 * 		name: string;
 * 		id: number;
 * 		address: Address;
 * }
 *
 * interface Address {
 * 		city: string
 *		state: string
 * }
 * ```
 * and Paths<IUser> will make these keys available name, id, address (object type) and also in the
 * string form "name", "id", "address.city", "address.state"
 */
declare type Paths<T, P extends string = ""> = {
    [K in keyof T]: T[K] extends object ? T[K] extends unknown[] ? `${P}${K & string}` : Paths<T[K], `${P}${K & string}.`> extends infer O ? `${O & string}` | `${P}${K & string}` : never : `${P}${K & string}`;
}[keyof T];
/**
 * This type helps to infer the type of the path that Paths (above) has generated.
 */
declare type PathType<T, P extends string> = P extends keyof T ? T[P] : P extends `${infer L}.${infer R}` ? L extends keyof T ? PathType<T[L], R> : never : never;
export declare type Selector<T> = Partial<{
    [K in string]: unknown;
}>;
/**
 * Compute all possible property combinations
 */
declare type normalTypes = PropertyKey | BigInt | Date | boolean | Array<unknown>;
export declare type DocumentPaths<T, Cache extends string = ""> = T extends normalTypes ? Cache : {
    [P in keyof T]: P extends string ? Cache extends "" ? DocumentPaths<T[P], `${P}`> : Cache | DocumentPaths<T[P], `${Cache}.${P}`> : `${Cache}${P & string}`;
}[keyof T];
export declare type SelectorOperator = "$eq" | "$gt" | "$gte" | "$lt" | "$lte" | "$not" | "$regex" | "$contains" | "$none";
export declare type LogicalOperator = "$or" | "$and";
export declare type SelectorFilter<T> = {
    [K in DocumentPaths<T>]?: PathType<T, K> | {
        [P in SelectorOperator]?: PathType<T, K>;
    } | FieldTypes | {
        [P in SelectorOperator]?: FieldTypes;
    };
};
export declare type LogicalFilter<T> = {
    [P in LogicalOperator]?: Array<Filter<T>>;
};
export declare type Filter<T> = SelectorFilter<T> | LogicalFilter<T>;
export {};
