"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Search = void 0;
const types_1 = require("./types");
const search_index_1 = require("./search-index");
const utility_1 = require("../utility");
const search_pb_1 = require("../proto/server/v1/search_pb");
const decorated_schema_processor_1 = require("../schema/decorated-schema-processor");
class Search {
    constructor(client, config) {
        this.client = client;
        this.config = config;
        this.schemaProcessor = decorated_schema_processor_1.DecoratedSchemaProcessor.Instance;
    }
    createOrUpdateIndex(nameOrClass, schemaOrClass) {
        let indexName;
        let mayBeClass;
        let schema;
        if (typeof nameOrClass === "string") {
            indexName = nameOrClass;
            if (typeof schemaOrClass === "function") {
                mayBeClass = schemaOrClass;
            }
            else {
                schema = schemaOrClass;
            }
        }
        else {
            // only single class argument is passed
            mayBeClass = nameOrClass;
        }
        if (mayBeClass && !schema) {
            const generatedIndex = this.schemaProcessor.processIndex(mayBeClass);
            if (!generatedIndex) {
                return new Promise((resolve, reject) => {
                    reject(new Error(`An attempt was made to retrieve an index with the name ${indexName} but there is no index defined with that name.` +
                        +"Please make sure an index has been defined using the 'TigrisSearchIndex' decorator."));
                });
            }
            schema = generatedIndex.schema;
            // if indexName is not provided, use the one from model class
            indexName = indexName !== null && indexName !== void 0 ? indexName : generatedIndex.name;
        }
        const rawJSONSchema = utility_1.Utility._indexSchematoJSON(indexName, schema);
        const createOrUpdateIndexRequest = new search_pb_1.CreateOrUpdateIndexRequest()
            .setProject(this.projectName)
            .setName(indexName)
            .setSchema(utility_1.Utility.stringToUint8Array(rawJSONSchema));
        return new Promise((resolve, reject) => {
            this.client.createOrUpdateIndex(createOrUpdateIndexRequest, (error, response) => {
                if (error) {
                    reject(error);
                    return;
                }
                console.log(`Created index: ${response.getMessage()}`);
                resolve(new search_index_1.SearchIndex(this.client, indexName, this.config));
            });
        });
    }
    listIndexes() {
        // TODO: Set filter on request
        const listIndexRequest = new search_pb_1.ListIndexesRequest().setProject(this.projectName);
        return new Promise((resolve, reject) => {
            this.client.listIndexes(listIndexRequest, (error, response) => {
                if (error) {
                    reject(error);
                    return;
                }
                resolve(response.getIndexesList().map((i) => types_1.IndexInfo.from(i)));
            });
        });
    }
    // TODO: this doesn't have to be promise but would be a breaking change for existing users
    getIndex(name) {
        return Promise.resolve(new search_index_1.SearchIndex(this.client, name, this.config));
    }
    deleteIndex(name) {
        const deleteIndexRequest = new search_pb_1.DeleteIndexRequest()
            .setProject(this.projectName)
            .setName(name);
        return new Promise((resolve, reject) => {
            this.client.deleteIndex(deleteIndexRequest, (error, response) => {
                if (error) {
                    reject(error);
                    return;
                }
                resolve(types_1.DeleteIndexResponse.from(response));
            });
        });
    }
    get projectName() {
        return this.config.projectName;
    }
}
exports.Search = Search;
