"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SearchIndex = void 0;
const types_1 = require("./types");
const search_pb_1 = require("../proto/server/v1/search_pb");
const utility_1 = require("../utility");
const search_iterator_1 = require("../consumables/search-iterator");
const result_1 = require("./result");
class SearchIndex {
    constructor(client, name, config) {
        this.grpcClient = client;
        this.name = name;
        this.config = config;
    }
    createMany(docs) {
        return new Promise((resolve, reject) => {
            const createRequest = new search_pb_1.CreateDocumentRequest()
                .setProject(this.config.projectName)
                .setIndex(this.name);
            for (const doc of docs) {
                const encodedDoc = this.encodedDoc(doc);
                createRequest.addDocuments(encodedDoc);
            }
            this.grpcClient.create(createRequest, (error, response) => {
                if (error) {
                    reject(error);
                    return;
                }
                const status = response.getStatusList().map((d) => types_1.DocStatus.from(d));
                resolve(status);
            });
        });
    }
    createOne(doc) {
        return new Promise((resolve, reject) => {
            this.createMany([doc])
                .then((docStatuses) => resolve(docStatuses[0]))
                .catch((error) => reject(error));
        });
    }
    deleteMany(ids) {
        return new Promise((resolve, reject) => {
            const delRequest = new search_pb_1.DeleteDocumentRequest()
                .setProject(this.config.projectName)
                .setIndex(this.name)
                .setIdsList(ids);
            this.grpcClient.delete(delRequest, (error, response) => {
                if (error) {
                    reject(error);
                    return;
                }
                resolve(response.getStatusList().map((d) => types_1.DocStatus.from(d)));
            });
        });
    }
    deleteByQuery(filter) {
        return new Promise((resolve, reject) => {
            const delRequest = new search_pb_1.DeleteByQueryRequest()
                .setProject(this.config.projectName)
                .setIndex(this.name)
                .setFilter(utility_1.Utility.stringToUint8Array(utility_1.Utility.filterToString(filter)));
            this.grpcClient.deleteByQuery(delRequest, (error, response) => {
                if (error) {
                    reject(error);
                    return;
                }
                resolve(response.getCount());
            });
        });
    }
    deleteOne(id) {
        return new Promise((resolve, reject) => {
            this.deleteMany([id])
                .then((docStatuses) => resolve(docStatuses[0]))
                .catch((error) => reject(error));
        });
    }
    createOrReplaceMany(docs) {
        return new Promise((resolve, reject) => {
            const replaceRequest = new search_pb_1.CreateOrReplaceDocumentRequest()
                .setProject(this.config.projectName)
                .setIndex(this.name);
            for (const doc of docs)
                replaceRequest.addDocuments(this.encodedDoc(doc));
            this.grpcClient.createOrReplace(replaceRequest, (error, response) => {
                if (error) {
                    reject(error);
                    return;
                }
                resolve(response.getStatusList().map((d) => types_1.DocStatus.from(d)));
            });
        });
    }
    createOrReplaceOne(doc) {
        return new Promise((resolve, reject) => {
            this.createOrReplaceMany([doc])
                .then((docStatuses) => resolve(docStatuses[0]))
                .catch((error) => reject(error));
        });
    }
    getMany(ids) {
        return new Promise((resolve, reject) => {
            const getRequest = new search_pb_1.GetDocumentRequest()
                .setProject(this.config.projectName)
                .setIndex(this.name)
                .setIdsList(ids);
            this.grpcClient.get(getRequest, (error, response) => {
                if (error) {
                    reject(error);
                    return;
                }
                const docs = response.getDocumentsList().map((d) => {
                    return result_1.IndexedDoc.from(d, this.config);
                });
                resolve(docs);
            });
        });
    }
    getOne(id) {
        return new Promise((resolve, reject) => {
            this.getMany([id])
                .then((docs) => resolve(docs[0]))
                .catch((error) => reject(error));
        });
    }
    updateMany(docs) {
        return new Promise((resolve, reject) => {
            const updateRequest = new search_pb_1.UpdateDocumentRequest()
                .setProject(this.config.projectName)
                .setIndex(this.name);
            for (const doc of docs)
                updateRequest.addDocuments(this.encodedDoc(doc));
            this.grpcClient.update(updateRequest, (error, response) => {
                if (error) {
                    reject(error);
                }
                resolve(response.getStatusList().map((d) => types_1.DocStatus.from(d)));
            });
        });
    }
    updateOne(doc) {
        return new Promise((resolve, reject) => {
            this.updateMany([doc])
                .then((docStatuses) => resolve(docStatuses[0]))
                .catch((error) => reject(error));
        });
    }
    search(query, page) {
        const searchRequest = new search_pb_1.SearchIndexRequest()
            .setProject(this.config.projectName)
            .setIndex(this.name);
        utility_1.Utility.protoSearchRequestFromQuery(query, searchRequest, page);
        // return a iterator if no explicit page number is specified
        if (typeof page === "undefined") {
            const initializer = new search_iterator_1.SearchIndexIteratorInitializer(this.grpcClient, searchRequest);
            return new search_iterator_1.SearchIterator(initializer, this.config);
        }
        else {
            return new Promise((resolve, reject) => {
                const stream = this.grpcClient.search(searchRequest);
                stream.on("data", (searchResponse) => {
                    const searchResult = result_1.SearchResult.from(searchResponse, this.config);
                    resolve(searchResult);
                });
                stream.on("error", (error) => reject(error));
                stream.on("end", () => resolve(result_1.SearchResult.empty));
            });
        }
    }
    encodedDoc(doc) {
        return utility_1.Utility.stringToUint8Array(utility_1.Utility.objToJsonString(doc));
    }
}
exports.SearchIndex = SearchIndex;
