// package: tigrisdata.observability.v1
// file: server/v1/observability.proto

/* tslint:disable */
/* eslint-disable */

import * as jspb from "google-protobuf";
import * as openapiv3_annotations_pb from "../../openapiv3/annotations_pb";

export class RetryInfo extends jspb.Message { 
    getDelay(): number;
    setDelay(value: number): RetryInfo;

    serializeBinary(): Uint8Array;
    toObject(includeInstance?: boolean): RetryInfo.AsObject;
    static toObject(includeInstance: boolean, msg: RetryInfo): RetryInfo.AsObject;
    static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
    static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
    static serializeBinaryToWriter(message: RetryInfo, writer: jspb.BinaryWriter): void;
    static deserializeBinary(bytes: Uint8Array): RetryInfo;
    static deserializeBinaryFromReader(message: RetryInfo, reader: jspb.BinaryReader): RetryInfo;
}

export namespace RetryInfo {
    export type AsObject = {
        delay: number,
    }
}

export class ErrorDetails extends jspb.Message { 
    getCode(): string;
    setCode(value: string): ErrorDetails;
    getMessage(): string;
    setMessage(value: string): ErrorDetails;

    hasRetry(): boolean;
    clearRetry(): void;
    getRetry(): RetryInfo | undefined;
    setRetry(value?: RetryInfo): ErrorDetails;

    serializeBinary(): Uint8Array;
    toObject(includeInstance?: boolean): ErrorDetails.AsObject;
    static toObject(includeInstance: boolean, msg: ErrorDetails): ErrorDetails.AsObject;
    static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
    static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
    static serializeBinaryToWriter(message: ErrorDetails, writer: jspb.BinaryWriter): void;
    static deserializeBinary(bytes: Uint8Array): ErrorDetails;
    static deserializeBinaryFromReader(message: ErrorDetails, reader: jspb.BinaryReader): ErrorDetails;
}

export namespace ErrorDetails {
    export type AsObject = {
        code: string,
        message: string,
        retry?: RetryInfo.AsObject,
    }
}

export class Error extends jspb.Message { 
    getCode(): Code;
    setCode(value: Code): Error;
    getMessage(): string;
    setMessage(value: string): Error;

    serializeBinary(): Uint8Array;
    toObject(includeInstance?: boolean): Error.AsObject;
    static toObject(includeInstance: boolean, msg: Error): Error.AsObject;
    static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
    static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
    static serializeBinaryToWriter(message: Error, writer: jspb.BinaryWriter): void;
    static deserializeBinary(bytes: Uint8Array): Error;
    static deserializeBinaryFromReader(message: Error, reader: jspb.BinaryReader): Error;
}

export namespace Error {
    export type AsObject = {
        code: Code,
        message: string,
    }
}

export class QueryTimeSeriesMetricsRequest extends jspb.Message { 
    getDb(): string;
    setDb(value: string): QueryTimeSeriesMetricsRequest;
    getBranch(): string;
    setBranch(value: string): QueryTimeSeriesMetricsRequest;
    getCollection(): string;
    setCollection(value: string): QueryTimeSeriesMetricsRequest;
    getFrom(): number;
    setFrom(value: number): QueryTimeSeriesMetricsRequest;
    getTo(): number;
    setTo(value: number): QueryTimeSeriesMetricsRequest;
    getMetricName(): string;
    setMetricName(value: string): QueryTimeSeriesMetricsRequest;
    getTigrisOperation(): TigrisOperation;
    setTigrisOperation(value: TigrisOperation): QueryTimeSeriesMetricsRequest;
    getSpaceAggregation(): MetricQuerySpaceAggregation;
    setSpaceAggregation(value: MetricQuerySpaceAggregation): QueryTimeSeriesMetricsRequest;
    clearSpaceAggregatedByList(): void;
    getSpaceAggregatedByList(): Array<string>;
    setSpaceAggregatedByList(value: Array<string>): QueryTimeSeriesMetricsRequest;
    addSpaceAggregatedBy(value: string, index?: number): string;
    getFunction(): MetricQueryFunction;
    setFunction(value: MetricQueryFunction): QueryTimeSeriesMetricsRequest;
    getQuantile(): number;
    setQuantile(value: number): QueryTimeSeriesMetricsRequest;
    clearAdditionalfunctionsList(): void;
    getAdditionalfunctionsList(): Array<AdditionalFunction>;
    setAdditionalfunctionsList(value: Array<AdditionalFunction>): QueryTimeSeriesMetricsRequest;
    addAdditionalfunctions(value?: AdditionalFunction, index?: number): AdditionalFunction;

    serializeBinary(): Uint8Array;
    toObject(includeInstance?: boolean): QueryTimeSeriesMetricsRequest.AsObject;
    static toObject(includeInstance: boolean, msg: QueryTimeSeriesMetricsRequest): QueryTimeSeriesMetricsRequest.AsObject;
    static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
    static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
    static serializeBinaryToWriter(message: QueryTimeSeriesMetricsRequest, writer: jspb.BinaryWriter): void;
    static deserializeBinary(bytes: Uint8Array): QueryTimeSeriesMetricsRequest;
    static deserializeBinaryFromReader(message: QueryTimeSeriesMetricsRequest, reader: jspb.BinaryReader): QueryTimeSeriesMetricsRequest;
}

export namespace QueryTimeSeriesMetricsRequest {
    export type AsObject = {
        db: string,
        branch: string,
        collection: string,
        from: number,
        to: number,
        metricName: string,
        tigrisOperation: TigrisOperation,
        spaceAggregation: MetricQuerySpaceAggregation,
        spaceAggregatedByList: Array<string>,
        pb_function: MetricQueryFunction,
        quantile: number,
        additionalfunctionsList: Array<AdditionalFunction.AsObject>,
    }
}

export class AdditionalFunction extends jspb.Message { 

    hasRollup(): boolean;
    clearRollup(): void;
    getRollup(): RollupFunction | undefined;
    setRollup(value?: RollupFunction): AdditionalFunction;

    serializeBinary(): Uint8Array;
    toObject(includeInstance?: boolean): AdditionalFunction.AsObject;
    static toObject(includeInstance: boolean, msg: AdditionalFunction): AdditionalFunction.AsObject;
    static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
    static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
    static serializeBinaryToWriter(message: AdditionalFunction, writer: jspb.BinaryWriter): void;
    static deserializeBinary(bytes: Uint8Array): AdditionalFunction;
    static deserializeBinaryFromReader(message: AdditionalFunction, reader: jspb.BinaryReader): AdditionalFunction;
}

export namespace AdditionalFunction {
    export type AsObject = {
        rollup?: RollupFunction.AsObject,
    }
}

export class RollupFunction extends jspb.Message { 
    getAggregator(): RollupAggregator;
    setAggregator(value: RollupAggregator): RollupFunction;
    getInterval(): number;
    setInterval(value: number): RollupFunction;

    serializeBinary(): Uint8Array;
    toObject(includeInstance?: boolean): RollupFunction.AsObject;
    static toObject(includeInstance: boolean, msg: RollupFunction): RollupFunction.AsObject;
    static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
    static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
    static serializeBinaryToWriter(message: RollupFunction, writer: jspb.BinaryWriter): void;
    static deserializeBinary(bytes: Uint8Array): RollupFunction;
    static deserializeBinaryFromReader(message: RollupFunction, reader: jspb.BinaryReader): RollupFunction;
}

export namespace RollupFunction {
    export type AsObject = {
        aggregator: RollupAggregator,
        interval: number,
    }
}

export class QueryTimeSeriesMetricsResponse extends jspb.Message { 
    getFrom(): number;
    setFrom(value: number): QueryTimeSeriesMetricsResponse;
    getTo(): number;
    setTo(value: number): QueryTimeSeriesMetricsResponse;
    getQuery(): string;
    setQuery(value: string): QueryTimeSeriesMetricsResponse;
    clearSeriesList(): void;
    getSeriesList(): Array<MetricSeries>;
    setSeriesList(value: Array<MetricSeries>): QueryTimeSeriesMetricsResponse;
    addSeries(value?: MetricSeries, index?: number): MetricSeries;

    serializeBinary(): Uint8Array;
    toObject(includeInstance?: boolean): QueryTimeSeriesMetricsResponse.AsObject;
    static toObject(includeInstance: boolean, msg: QueryTimeSeriesMetricsResponse): QueryTimeSeriesMetricsResponse.AsObject;
    static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
    static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
    static serializeBinaryToWriter(message: QueryTimeSeriesMetricsResponse, writer: jspb.BinaryWriter): void;
    static deserializeBinary(bytes: Uint8Array): QueryTimeSeriesMetricsResponse;
    static deserializeBinaryFromReader(message: QueryTimeSeriesMetricsResponse, reader: jspb.BinaryReader): QueryTimeSeriesMetricsResponse;
}

export namespace QueryTimeSeriesMetricsResponse {
    export type AsObject = {
        from: number,
        to: number,
        query: string,
        seriesList: Array<MetricSeries.AsObject>,
    }
}

export class MetricSeries extends jspb.Message { 
    getFrom(): number;
    setFrom(value: number): MetricSeries;
    getTo(): number;
    setTo(value: number): MetricSeries;
    getMetric(): string;
    setMetric(value: string): MetricSeries;
    getScope(): string;
    setScope(value: string): MetricSeries;
    clearDatapointsList(): void;
    getDatapointsList(): Array<DataPoint>;
    setDatapointsList(value: Array<DataPoint>): MetricSeries;
    addDatapoints(value?: DataPoint, index?: number): DataPoint;

    serializeBinary(): Uint8Array;
    toObject(includeInstance?: boolean): MetricSeries.AsObject;
    static toObject(includeInstance: boolean, msg: MetricSeries): MetricSeries.AsObject;
    static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
    static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
    static serializeBinaryToWriter(message: MetricSeries, writer: jspb.BinaryWriter): void;
    static deserializeBinary(bytes: Uint8Array): MetricSeries;
    static deserializeBinaryFromReader(message: MetricSeries, reader: jspb.BinaryReader): MetricSeries;
}

export namespace MetricSeries {
    export type AsObject = {
        from: number,
        to: number,
        metric: string,
        scope: string,
        datapointsList: Array<DataPoint.AsObject>,
    }
}

export class DataPoint extends jspb.Message { 
    getTimestamp(): number;
    setTimestamp(value: number): DataPoint;
    getValue(): number;
    setValue(value: number): DataPoint;

    serializeBinary(): Uint8Array;
    toObject(includeInstance?: boolean): DataPoint.AsObject;
    static toObject(includeInstance: boolean, msg: DataPoint): DataPoint.AsObject;
    static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
    static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
    static serializeBinaryToWriter(message: DataPoint, writer: jspb.BinaryWriter): void;
    static deserializeBinary(bytes: Uint8Array): DataPoint;
    static deserializeBinaryFromReader(message: DataPoint, reader: jspb.BinaryReader): DataPoint;
}

export namespace DataPoint {
    export type AsObject = {
        timestamp: number,
        value: number,
    }
}

export class QuotaLimitsRequest extends jspb.Message { 

    serializeBinary(): Uint8Array;
    toObject(includeInstance?: boolean): QuotaLimitsRequest.AsObject;
    static toObject(includeInstance: boolean, msg: QuotaLimitsRequest): QuotaLimitsRequest.AsObject;
    static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
    static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
    static serializeBinaryToWriter(message: QuotaLimitsRequest, writer: jspb.BinaryWriter): void;
    static deserializeBinary(bytes: Uint8Array): QuotaLimitsRequest;
    static deserializeBinaryFromReader(message: QuotaLimitsRequest, reader: jspb.BinaryReader): QuotaLimitsRequest;
}

export namespace QuotaLimitsRequest {
    export type AsObject = {
    }
}

export class QuotaLimitsResponse extends jspb.Message { 
    getReadunits(): number;
    setReadunits(value: number): QuotaLimitsResponse;
    getWriteunits(): number;
    setWriteunits(value: number): QuotaLimitsResponse;
    getStoragesize(): number;
    setStoragesize(value: number): QuotaLimitsResponse;

    serializeBinary(): Uint8Array;
    toObject(includeInstance?: boolean): QuotaLimitsResponse.AsObject;
    static toObject(includeInstance: boolean, msg: QuotaLimitsResponse): QuotaLimitsResponse.AsObject;
    static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
    static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
    static serializeBinaryToWriter(message: QuotaLimitsResponse, writer: jspb.BinaryWriter): void;
    static deserializeBinary(bytes: Uint8Array): QuotaLimitsResponse;
    static deserializeBinaryFromReader(message: QuotaLimitsResponse, reader: jspb.BinaryReader): QuotaLimitsResponse;
}

export namespace QuotaLimitsResponse {
    export type AsObject = {
        readunits: number,
        writeunits: number,
        storagesize: number,
    }
}

export class QuotaUsageRequest extends jspb.Message { 

    serializeBinary(): Uint8Array;
    toObject(includeInstance?: boolean): QuotaUsageRequest.AsObject;
    static toObject(includeInstance: boolean, msg: QuotaUsageRequest): QuotaUsageRequest.AsObject;
    static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
    static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
    static serializeBinaryToWriter(message: QuotaUsageRequest, writer: jspb.BinaryWriter): void;
    static deserializeBinary(bytes: Uint8Array): QuotaUsageRequest;
    static deserializeBinaryFromReader(message: QuotaUsageRequest, reader: jspb.BinaryReader): QuotaUsageRequest;
}

export namespace QuotaUsageRequest {
    export type AsObject = {
    }
}

export class QuotaUsageResponse extends jspb.Message { 
    getReadunits(): number;
    setReadunits(value: number): QuotaUsageResponse;
    getWriteunits(): number;
    setWriteunits(value: number): QuotaUsageResponse;
    getStoragesize(): number;
    setStoragesize(value: number): QuotaUsageResponse;
    getReadunitsthrottled(): number;
    setReadunitsthrottled(value: number): QuotaUsageResponse;
    getWriteunitsthrottled(): number;
    setWriteunitsthrottled(value: number): QuotaUsageResponse;
    getStoragesizethrottled(): number;
    setStoragesizethrottled(value: number): QuotaUsageResponse;

    serializeBinary(): Uint8Array;
    toObject(includeInstance?: boolean): QuotaUsageResponse.AsObject;
    static toObject(includeInstance: boolean, msg: QuotaUsageResponse): QuotaUsageResponse.AsObject;
    static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
    static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
    static serializeBinaryToWriter(message: QuotaUsageResponse, writer: jspb.BinaryWriter): void;
    static deserializeBinary(bytes: Uint8Array): QuotaUsageResponse;
    static deserializeBinaryFromReader(message: QuotaUsageResponse, reader: jspb.BinaryReader): QuotaUsageResponse;
}

export namespace QuotaUsageResponse {
    export type AsObject = {
        readunits: number,
        writeunits: number,
        storagesize: number,
        readunitsthrottled: number,
        writeunitsthrottled: number,
        storagesizethrottled: number,
    }
}

export class GetInfoRequest extends jspb.Message { 

    serializeBinary(): Uint8Array;
    toObject(includeInstance?: boolean): GetInfoRequest.AsObject;
    static toObject(includeInstance: boolean, msg: GetInfoRequest): GetInfoRequest.AsObject;
    static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
    static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
    static serializeBinaryToWriter(message: GetInfoRequest, writer: jspb.BinaryWriter): void;
    static deserializeBinary(bytes: Uint8Array): GetInfoRequest;
    static deserializeBinaryFromReader(message: GetInfoRequest, reader: jspb.BinaryReader): GetInfoRequest;
}

export namespace GetInfoRequest {
    export type AsObject = {
    }
}

export class GetInfoResponse extends jspb.Message { 
    getServerVersion(): string;
    setServerVersion(value: string): GetInfoResponse;

    hasError(): boolean;
    clearError(): void;
    getError(): Error | undefined;
    setError(value?: Error): GetInfoResponse;

    serializeBinary(): Uint8Array;
    toObject(includeInstance?: boolean): GetInfoResponse.AsObject;
    static toObject(includeInstance: boolean, msg: GetInfoResponse): GetInfoResponse.AsObject;
    static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
    static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
    static serializeBinaryToWriter(message: GetInfoResponse, writer: jspb.BinaryWriter): void;
    static deserializeBinary(bytes: Uint8Array): GetInfoResponse;
    static deserializeBinaryFromReader(message: GetInfoResponse, reader: jspb.BinaryReader): GetInfoResponse;
}

export namespace GetInfoResponse {
    export type AsObject = {
        serverVersion: string,
        error?: Error.AsObject,
    }
}

export enum Code {
    OK = 0,
    CANCELLED = 1,
    UNKNOWN = 2,
    INVALID_ARGUMENT = 3,
    DEADLINE_EXCEEDED = 4,
    NOT_FOUND = 5,
    ALREADY_EXISTS = 6,
    PERMISSION_DENIED = 7,
    RESOURCE_EXHAUSTED = 8,
    FAILED_PRECONDITION = 9,
    ABORTED = 10,
    OUT_OF_RANGE = 11,
    UNIMPLEMENTED = 12,
    INTERNAL = 13,
    UNAVAILABLE = 14,
    DATA_LOSS = 15,
    UNAUTHENTICATED = 16,
    CONFLICT = 17,
    BAD_GATEWAY = 18,
    METHOD_NOT_ALLOWED = 19,
    CONTENT_TOO_LARGE = 20,
}

export enum TigrisOperation {
    ALL = 0,
    READ = 1,
    WRITE = 2,
    METADATA = 3,
}

export enum MetricQueryFunction {
    RATE = 0,
    COUNT = 1,
    NONE = 2,
}

export enum RollupAggregator {
    ROLLUP_AGGREGATOR_SUM = 0,
    ROLLUP_AGGREGATOR_COUNT = 1,
    ROLLUP_AGGREGATOR_MIN = 2,
    ROLLUP_AGGREGATOR_MAX = 3,
    ROLLUP_AGGREGATOR_AVG = 4,
}

export enum MetricQuerySpaceAggregation {
    AVG = 0,
    MIN = 1,
    MAX = 2,
    SUM = 3,
}
