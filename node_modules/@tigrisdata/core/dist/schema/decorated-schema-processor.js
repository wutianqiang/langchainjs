"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DecoratedSchemaProcessor = void 0;
const globals_1 = require("../globals");
const types_1 = require("../types");
const error_1 = require("../error");
/** @internal */
class DecoratedSchemaProcessor {
    constructor() {
        this.storage = (0, globals_1.getDecoratorMetaStorage)();
    }
    static get Instance() {
        if (!DecoratedSchemaProcessor._instance) {
            DecoratedSchemaProcessor._instance = new DecoratedSchemaProcessor();
        }
        return DecoratedSchemaProcessor._instance;
    }
    processIndex(cls) {
        const index = this.storage.getIndexByTarget(cls);
        if (!index) {
            return;
        }
        const schema = this.buildTigrisSchema(index.target, false);
        return {
            name: index.indexName,
            schema: schema,
        };
    }
    processCollection(cls) {
        const collection = this.storage.getCollectionByTarget(cls);
        const schema = this.buildTigrisSchema(collection.target, true);
        this.addPrimaryKeys(schema, collection.target);
        return {
            name: collection.collectionName,
            schema: schema,
        };
    }
    buildTigrisSchema(from, forCollection, parentFieldType) {
        const schema = {};
        // get all top level fields matching this target
        const fields = this.getSchemaFields(from, forCollection);
        // process each field
        for (const field of fields) {
            const key = field.name;
            if (!(key in schema)) {
                schema[key] = { type: field.type };
            }
            let arrayItems, arrayDepth;
            switch (field.type) {
                case types_1.TigrisDataTypes.ARRAY:
                    arrayItems =
                        typeof field.embedType === "function"
                            ? {
                                type: this.buildTigrisSchema(field.embedType, forCollection, parentFieldType !== null && parentFieldType !== void 0 ? parentFieldType : field.type),
                            }
                            : { type: field.embedType };
                    arrayDepth = field.arrayDepth && field.arrayDepth > 1 ? field.arrayDepth : 1;
                    schema[key] = this.buildNestedArray(arrayItems, arrayDepth);
                    break;
                case types_1.TigrisDataTypes.OBJECT:
                    if (typeof field.embedType === "function") {
                        const embedSchema = this.buildTigrisSchema(field.embedType, forCollection, parentFieldType !== null && parentFieldType !== void 0 ? parentFieldType : field.type);
                        // generate embedded schema as its a class
                        if (Object.keys(embedSchema).length > 0) {
                            schema[key] = {
                                type: this.buildTigrisSchema(field.embedType, forCollection, parentFieldType !== null && parentFieldType !== void 0 ? parentFieldType : field.type),
                            };
                        }
                    }
                    break;
                case types_1.TigrisDataTypes.STRING:
                    if (field.schemaFieldOptions && "maxLength" in field.schemaFieldOptions) {
                        schema[key].maxLength = field.schemaFieldOptions.maxLength;
                    }
                    break;
            }
            // process any field optionals
            if (field.schemaFieldOptions) {
                // set value for field,  if any
                for (const opKey of schemaOptions) {
                    if (schemaOptionSupported(field.schemaFieldOptions, field.type, parentFieldType, opKey)) {
                        schema[key][opKey.attrName] = field.schemaFieldOptions[opKey.attrName];
                    }
                }
            }
        }
        return forCollection
            ? schema
            : schema;
    }
    buildNestedArray(items, depth) {
        let head, prev, next;
        while (depth > 0) {
            if (!head) {
                next = {};
                head = next;
            }
            next["type"] = types_1.TigrisDataTypes.ARRAY;
            next["items"] = {};
            prev = next;
            next = next["items"];
            depth -= 1;
        }
        prev["items"] = items;
        return head;
    }
    addPrimaryKeys(targetSchema, collectionClass) {
        var _a, _b, _c;
        const primaryKeysMetadata = this.storage.getPKsByTarget(collectionClass);
        this.validatePrimaryKeysOrder(primaryKeysMetadata, collectionClass);
        for (const pk of primaryKeysMetadata) {
            if (!(pk.name in targetSchema)) {
                targetSchema[pk.name] = {
                    type: pk.type,
                };
            }
            targetSchema[pk.name]["primary_key"] = {
                order: (_b = (_a = pk.options) === null || _a === void 0 ? void 0 : _a.order) !== null && _b !== void 0 ? _b : 1,
                autoGenerate: ((_c = pk.options) === null || _c === void 0 ? void 0 : _c.autoGenerate) === true,
            };
        }
    }
    validatePrimaryKeysOrder(primaryKeys, collectionClass) {
        var _a;
        if (primaryKeys.length > 1) {
            for (const pk of primaryKeys) {
                if (!((_a = pk === null || pk === void 0 ? void 0 : pk.options) === null || _a === void 0 ? void 0 : _a.order)) {
                    throw new error_1.IncompletePrimaryKeyOrderError(pk.name, collectionClass.name);
                }
            }
        }
    }
    getSchemaFields(from, forCollection) {
        const searchFields = this.storage.getSearchFieldsByTarget(from);
        if (!forCollection) {
            return searchFields;
        }
        const fields = [];
        // create a lookup for search fields
        const searchFieldsLookup = [];
        for (const field of searchFields) {
            searchFieldsLookup[field.name] = field;
        }
        // process the collection fields
        const visitedFields = new Set();
        const collectionFields = this.storage.getCollectionFieldsByTarget(from);
        for (const cf of collectionFields) {
            let fieldOption = cf.schemaFieldOptions;
            // if a search field is defined for this field, merge its options
            const searchField = searchFieldsLookup[cf.name];
            if (searchField) {
                fieldOption = Object.assign(Object.assign({}, cf.schemaFieldOptions), searchField.schemaFieldOptions);
            }
            fields.push(Object.assign(Object.assign({}, cf), { schemaFieldOptions: fieldOption }));
            visitedFields.add(cf.name);
        }
        // process the additional fields that are tagged as search fields
        for (const sf of searchFields) {
            if (!visitedFields.has(sf.name)) {
                fields.push(sf);
            }
        }
        return fields;
    }
}
exports.DecoratedSchemaProcessor = DecoratedSchemaProcessor;
const schemaOptions = [
    {
        attrName: "default",
        doesNotApplyTo: new Set(),
        doesNotApplyToParent: new Set(),
    },
    {
        attrName: "timestamp",
        doesNotApplyTo: new Set([types_1.TigrisDataTypes.OBJECT]),
        doesNotApplyToParent: new Set(),
    },
    {
        attrName: "searchIndex",
        doesNotApplyTo: new Set([types_1.TigrisDataTypes.OBJECT]),
        doesNotApplyToParent: new Set([types_1.TigrisDataTypes.ARRAY]),
    },
    {
        attrName: "sort",
        doesNotApplyTo: new Set([types_1.TigrisDataTypes.OBJECT]),
        doesNotApplyToParent: new Set([types_1.TigrisDataTypes.ARRAY]),
    },
    {
        attrName: "facet",
        doesNotApplyTo: new Set([types_1.TigrisDataTypes.OBJECT]),
        doesNotApplyToParent: new Set([types_1.TigrisDataTypes.ARRAY]),
    },
    {
        attrName: "dimensions",
        doesNotApplyTo: new Set([types_1.TigrisDataTypes.OBJECT, types_1.TigrisDataTypes.NUMBER]),
        doesNotApplyToParent: new Set([types_1.TigrisDataTypes.ARRAY]),
    },
    {
        attrName: "id",
        doesNotApplyTo: new Set([
            types_1.TigrisDataTypes.OBJECT,
            types_1.TigrisDataTypes.ARRAY,
            types_1.TigrisDataTypes.NUMBER,
            types_1.TigrisDataTypes.BOOLEAN,
            types_1.TigrisDataTypes.NUMBER_BIGINT,
            types_1.TigrisDataTypes.INT64,
            types_1.TigrisDataTypes.INT32,
            types_1.TigrisDataTypes.DATE_TIME,
        ]),
        doesNotApplyToParent: new Set([types_1.TigrisDataTypes.ARRAY]),
    },
    {
        attrName: "index",
        doesNotApplyTo: new Set([types_1.TigrisDataTypes.OBJECT, types_1.TigrisDataTypes.ARRAY]),
        doesNotApplyToParent: new Set([types_1.TigrisDataTypes.ARRAY, types_1.TigrisDataTypes.OBJECT]),
    },
];
// searchIndex, sort and facet tags cannot be defined on top level object
// and can only be defined on the fields of the object
// { "field1": { "type": "object", "properties": { "name": { "type": "string" } }, "searchIndex": true } - not supported
// { "field1": { "type": "object", "properties": { "name": { "type": "string", "searchIndex": true } } } - supported
// searchIndex, sort and facet tags cannot be defined within a nested array
// { "field1": { "type": "array", "items": { "type": "object", "properties": { "name": { "type": "string", "searchIndex": true } } } } - not supported
// { "field1": { "type": "array", "items": { "type": "object", "properties": { "name": { "type": "string" } } }, "searchIndex": true } - supported
function schemaOptionSupported(fieldOptions, fieldType, fieldParentType, attr) {
    if (attr.attrName in fieldOptions &&
        !attr.doesNotApplyTo.has(fieldType) &&
        (!fieldParentType || !attr.doesNotApplyToParent.has(fieldParentType))) {
        return true;
    }
    return false;
}
