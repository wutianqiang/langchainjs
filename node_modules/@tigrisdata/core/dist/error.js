"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BranchNameRequiredError = exports.CollectionNotFoundError = exports.IncompletePrimaryKeyOrderError = exports.DuplicatePrimaryKeyOrderError = exports.MissingPrimaryKeyOrderInSchemaDefinitionError = exports.IncorrectVectorDefError = exports.IncompleteArrayTypeDefError = exports.CannotInferFieldTypeError = exports.MissingArgumentError = exports.ReflectionNotEnabled = exports.CursorInUseError = exports.TigrisError = void 0;
/**
 * Generic TigrisError
 */
class TigrisError extends Error {
    constructor(message) {
        super(message);
        this.errMsg = this.name + ": " + this.message;
    }
    get name() {
        return "TigrisError";
    }
}
exports.TigrisError = TigrisError;
/**
 * An error thrown when the user attempts to consume a cursor that has already been
 * used
 *
 * @public
 */
class CursorInUseError extends TigrisError {
    constructor(message = "Cursor is already in use or used. Please reset()") {
        super(message);
    }
}
exports.CursorInUseError = CursorInUseError;
class ReflectionNotEnabled extends TigrisError {
    constructor(object, propertyName) {
        super(`Cannot infer property "type" for ${object.constructor.name}#${propertyName} using Reflection.
			Ensure that "experimentalDecorators" and "emitDecoratorMetadata" options are set to true in
			"tsconfig.json" and "reflect-metadata" npm package is added to dependencies in "package.json".
			Alternatively, specify the property's "field type" manually.`);
    }
    get name() {
        return "ReflectionNotEnabled";
    }
}
exports.ReflectionNotEnabled = ReflectionNotEnabled;
class MissingArgumentError extends TigrisError {
    constructor(propertyName) {
        super(`'${propertyName}' is required and cannot be 'undefined'`);
    }
    get name() {
        return "MissingArgumentError";
    }
}
exports.MissingArgumentError = MissingArgumentError;
class CannotInferFieldTypeError extends TigrisError {
    constructor(object, propertyName) {
        super(`Field type for '${object.constructor.name}#${propertyName}' cannot be determined`);
    }
    get name() {
        return "CannotInferFieldTypeError";
    }
}
exports.CannotInferFieldTypeError = CannotInferFieldTypeError;
class IncompleteArrayTypeDefError extends TigrisError {
    constructor(object, propertyName) {
        super(`Missing "EmbeddedFieldOptions". Array's item type for '${object.constructor.name}#${propertyName}' cannot be determined`);
    }
    get name() {
        return "IncompleteArrayTypeDefError";
    }
}
exports.IncompleteArrayTypeDefError = IncompleteArrayTypeDefError;
class IncorrectVectorDefError extends TigrisError {
    constructor(object, propertyName) {
        super(`'${propertyName}' in '${object.constructor.name}' defines "dimensions" field option identifying it as a Vector data type.
		The primitive data type for Vector can only be a 'number[]'`);
    }
    get name() {
        return "IncorrectVectorDefError";
    }
}
exports.IncorrectVectorDefError = IncorrectVectorDefError;
class MissingPrimaryKeyOrderInSchemaDefinitionError extends TigrisError {
    constructor(propertyName) {
        super(`Missing 'order' value for '${propertyName}' primary key`);
    }
    get name() {
        return "MissingPrimaryKeyOrderInSchemaDefinitionError";
    }
}
exports.MissingPrimaryKeyOrderInSchemaDefinitionError = MissingPrimaryKeyOrderInSchemaDefinitionError;
class DuplicatePrimaryKeyOrderError extends TigrisError {
    constructor(order, propertyName) {
        super(`Primary Key order '${order}' already exists for '${propertyName}'`);
    }
    get name() {
        return "DuplicatePrimaryKeyOrderError";
    }
}
exports.DuplicatePrimaryKeyOrderError = DuplicatePrimaryKeyOrderError;
class IncompletePrimaryKeyOrderError extends TigrisError {
    constructor(name, collectionName) {
        super(`Missing 'order' value in "PrimaryKeyOptions" for variable '${name}' in ${collectionName} collection`);
    }
    get name() {
        return "IncompletePrimaryKeyOrderError";
    }
}
exports.IncompletePrimaryKeyOrderError = IncompletePrimaryKeyOrderError;
class CollectionNotFoundError extends TigrisError {
    constructor(name) {
        super(`Collection not found : '${name}'`);
    }
    get name() {
        return "CollectionNotFoundError";
    }
}
exports.CollectionNotFoundError = CollectionNotFoundError;
class BranchNameRequiredError extends TigrisError {
    constructor() {
        super(`Database branch name is required. Include a branch name in client config or specify one in
		environment file as 'TIGRIS_DB_BRANCH=your_branch_name'`);
    }
    get name() {
        return "BranchNameRequiredError";
    }
}
exports.BranchNameRequiredError = BranchNameRequiredError;
