/// <reference types="node" />
import * as proto from "google-protobuf";
import { ClientReadableStream } from "@grpc/grpc-js";
import { Readable } from "stream";
/** @internal */
export interface Initializer<TResp extends proto.Message> {
    init(): ClientReadableStream<TResp>;
}
/** @internal */
declare const tStream: unique symbol;
/** @internal */
declare const tReady: unique symbol;
/** @internal */
declare const tClosed: unique symbol;
export declare abstract class IterableStream<T, TResp extends proto.Message> {
    /** @internal */
    [tStream]: ClientReadableStream<TResp>;
    /** @internal */
    [tReady]: boolean;
    /** @internal */
    [tClosed]: boolean;
    /** @internal */
    private _initializer;
    /** @internal */
    protected constructor(initializer: Initializer<TResp>);
    /** @internal */
    private _assertNotInUse;
    /** @internal */
    private next;
    /**
     * Returns a {@link Readable} stream of documents to iterate on
     *
     * @example
     * ```
     * const cursor = myCollection.find();
     * for await (const doc of cursor.stream()) {
     *     console.log(doc);
     * }
     *```
     *
     * @throws {@link TigrisCursorInUseError} - if cursor is being consumed or has been consumed.
     * @see {@link reset} to re-use a cursor.
     */
    stream(): Readable;
    /**
     * Returns an async iterator to iterate on documents
     *
     * @example
     * ```
     * const cursor = myCollection.find();
     * for await (const doc of cursor) {
     *     console.log(doc);
     * }
     *```
     *
     * @throws {@link TigrisCursorInUseError} - if cursor is being consumed or has been consumed.
     * @see {@link reset} to re-use a cursor.
     */
    [Symbol.asyncIterator](): AsyncIterableIterator<T>;
    /**
     * Returns an array of documents. The caller is responsible for making sure that there
     * is enough memory to store the results.
     *
     * @throws {@link TigrisCursorInUseError} - if cursor is being consumed or has been consumed.
     * @see {@link reset} to re-use a cursor.
     */
    toArray(): Promise<Array<T>>;
    /** Converts a message from stream to user consumable object */
    protected abstract _transform(message: TResp): T;
    /** @internal */
    private _initialize;
    /**
     * This essentially sends a new query to server and allows the cursor to be re-used. A new
     * query to server is sent even if this cursor is not yet consumed.
     *
     * <b>Note:</b> A cursor may yield different results after `reset()`
     */
    reset(): void;
}
export {};
