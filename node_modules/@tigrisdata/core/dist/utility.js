"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Utility = void 0;
const grpc_js_1 = require("@grpc/grpc-js");
const json_bigint_1 = __importDefault(require("json-bigint"));
const types_1 = require("./types");
const api_pb_1 = require("./proto/server/v1/api_pb");
const search_1 = require("./search");
const error_1 = require("./error");
exports.Utility = {
    stringToUint8Array(input) {
        return new TextEncoder().encode(input);
    },
    uint8ArrayToString(input) {
        return new TextDecoder().decode(input);
    },
    /** @see tests for usage */
    branchNameFromEnv(given) {
        const maybeBranchName = typeof given !== "undefined" ? given : process.env.TIGRIS_DB_BRANCH;
        if (typeof maybeBranchName === "undefined") {
            return undefined;
        }
        const isTemplate = exports.Utility.getTemplatedVar(maybeBranchName);
        if (isTemplate) {
            return isTemplate.extracted in process.env
                ? maybeBranchName.replace(isTemplate.matched, this.nerfGitBranchName(process.env[isTemplate.extracted]))
                : undefined;
        }
        else {
            return this.nerfGitBranchName(maybeBranchName);
        }
    },
    /** @see {@link branchNameFromEnv} tests for usage */
    getTemplatedVar(input) {
        const output = input.match(/\${(.*?)}/);
        return output ? { matched: output[0], extracted: output[1] } : undefined;
    },
    /** @see tests for usage */
    nerfGitBranchName(original) {
        // only replace '/', '#', ' ' to avoid malformed urls
        return original.replace(/[ #/]/g, "_");
    },
    filterToString(filter) {
        for (const key of Object.keys(filter)) {
            if (filter[key].constructor.name === "Date") {
                filter[key] = filter[key].toJSON();
            }
        }
        return exports.Utility.objToJsonString(filter);
    },
    _getRandomInt(upperBound) {
        return Math.floor(Math.random() * upperBound);
    },
    readFieldString(readFields) {
        var _a, _b;
        const include = (_a = readFields.include) === null || _a === void 0 ? void 0 : _a.reduce((acc, field) => (Object.assign(Object.assign({}, acc), { [field]: true })), {});
        const exclude = (_b = readFields.exclude) === null || _b === void 0 ? void 0 : _b.reduce((acc, field) => (Object.assign(Object.assign({}, acc), { [field]: false })), {});
        return this.objToJsonString(Object.assign(Object.assign({}, include), exclude));
    },
    updateFieldsString(updateFields) {
        // UpdateFields
        const updateBuilder = {};
        for (const [key, value] of Object.entries(updateFields)) {
            switch (key) {
                case "$set":
                case "$unset":
                case "$divide":
                case "$increment":
                case "$decrement":
                case "$multiply":
                case "$push":
                    updateBuilder[key] = value;
                    break;
                default:
                    // by default everything else is a "$set" update
                    if (!("$set" in updateBuilder)) {
                        updateBuilder["$set"] = {};
                    }
                    updateBuilder["$set"][key] = value;
            }
        }
        return this.objToJsonString(updateBuilder);
    },
    // eslint-disable-next-line @typescript-eslint/ban-types
    objToJsonString(obj) {
        const JSONbigNative = (0, json_bigint_1.default)({ useNativeBigInt: true });
        return JSONbigNative.stringify(obj);
    },
    /**
     * Tigris uses custom deserialization to support `bigint`. By default the `bigint` from JSON
     * string will be converted back to model object as a `string` field. If user wants to
     * convert it back to `bigint`, the client config has to have `supportBigInt` set to `true`.
     *
     * Javascript's native way of ser/de (JSON.stringify(), JSON.parse()) doesn't support bigint
     * yet. If the model object used in other parts of the application that depends on native
     * JSON serde mechanism - you might want to continue using it as `string`.
     *
     *
     * @param json - string representation of JSON object
     * @param config - Tigris client config instance
     */
    jsonStringToObj(json, config) {
        const JSONbigNative = (0, json_bigint_1.default)({ useNativeBigInt: true });
        return JSONbigNative.parse(json, (k, v) => {
            // convert bigint to string based on configuration
            if (typeof v === "bigint" && (config.supportBigInt === undefined || !config.supportBigInt)) {
                return v.toString();
            }
            else if (typeof v === "string" && this._isISODateRegex(v)) {
                return new Date(v);
            }
            return v;
        });
    },
    _isISODateRegex(value) {
        const isoDateRegex = /(\d{4}-[01]\d-[0-3]\dT[0-2](?:\d:[0-5]){2}\d\.\d+([+-][0-2]\d:[0-5]\d|Z))|(\d{4}-[01]\d-[0-3]\dT[0-2](?:\d:[0-5]){2}\d([+-][0-2]\d:[0-5]\d|Z))|(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d([+-][0-2]\d:[0-5]\d|Z))/;
        return isoDateRegex.test(value);
    },
    txToMetadata(tx) {
        const metadata = new grpc_js_1.Metadata();
        if (tx !== undefined && tx !== null) {
            metadata.set("Tigris-Tx-Id", tx.id);
            metadata.set("Tigris-Tx-Origin", tx.origin);
            metadata.merge(tx.additionalMetadata);
        }
        return metadata;
    },
    /*
    This method converts nested json object to single level object.
     for example
     {
         "name": "Alice",
         "balance" : 123.123,
         "address": {
            "city": "San Francisco",
            "state": "California"
         }
     }
     gets converted to
     {
         "name": "Alice",
         "balance" : 123.123,
         "address.city": "San Francisco",
         "address.state": "California"
     }

     This is used for filter JSON serialization internally.
    */
    _flattenObj(ob) {
        const toReturn = {};
        for (const key in ob) {
            // eslint-disable-next-line no-prototype-builtins
            if (!ob.hasOwnProperty(key))
                continue;
            if (typeof ob[key] == "object" && ob[key] !== null) {
                const value = ob[key];
                if (value.constructor.name === "Date") {
                    toReturn[key] = value.toJSON();
                }
                else {
                    const flatObject = exports.Utility._flattenObj(value);
                    for (const x in flatObject) {
                        // eslint-disable-next-line no-prototype-builtins
                        if (!flatObject.hasOwnProperty(x))
                            continue;
                        toReturn[key + "." + x] = flatObject[x];
                    }
                }
            }
            else {
                toReturn[key] = ob[key];
            }
        }
        return toReturn;
    },
    _indexSchematoJSON(indexName, schema) {
        const root = { title: indexName, type: "object" };
        root["properties"] = this._getSchemaProperties(schema, {}, {});
        return exports.Utility.objToJsonString(root);
    },
    _collectionSchematoJSON(collectionName, schema) {
        const root = {};
        const pkeyMap = {};
        const keyMap = {};
        root["title"] = collectionName;
        root["additionalProperties"] = false;
        root["type"] = "object";
        root["properties"] = this._getSchemaProperties(schema, pkeyMap, keyMap);
        exports.Utility._postProcessDocumentSchema(root, pkeyMap);
        return exports.Utility.objToJsonString(root);
    },
    /*
    TODO:
      - validate the user defined schema (for example look for primary keys with duplicate
      order)
     - this can be extended for other schema massaging
     */
    _postProcessDocumentSchema(result, pkeyMap) {
        if (Object.keys(pkeyMap).length === 0) {
            return result;
        }
        result["primary_key"] = [];
        // add primary_key in order
        for (let i = 1; i <= Object.keys(pkeyMap).length; i++) {
            result["primary_key"].push(pkeyMap[i.toString()]);
        }
        return result;
    },
    _getSchemaProperties(schema, pkeyMap, keyMap) {
        const properties = {};
        for (const property of Object.keys(schema)) {
            let thisProperty = {};
            // single flat property? OR the property referring to another type (nested collection)
            if (typeof schema[property].type === "object" ||
                !(schema[property]["items"] || schema[property]["type"])) {
                thisProperty["type"] = "object";
                thisProperty["properties"] = this._getSchemaProperties(schema[property]["type"], pkeyMap, keyMap);
            }
            else if (schema[property].type === types_1.TigrisDataTypes.OBJECT) {
                thisProperty["type"] = "object";
                thisProperty["properties"] = {};
            }
            else if (schema[property].type != types_1.TigrisDataTypes.ARRAY.valueOf() &&
                typeof schema[property].type != "object") {
                thisProperty["type"] = this._getType(schema[property].type);
                const format = this._getFormat(schema[property].type);
                if (format) {
                    thisProperty["format"] = format;
                }
                // flat property could be a primary key
                if (schema[property].primary_key) {
                    if (!schema[property].primary_key["order"]) {
                        /**
                         * if the order doesn't exists then default to 1.
                         * Check if order 1 already exists, if true then throw MissingPrimaryKeyOrderInSchemaDefinitionError
                         */
                        if (pkeyMap["1"]) {
                            throw new error_1.MissingPrimaryKeyOrderInSchemaDefinitionError(property.toString());
                        }
                        pkeyMap["1"] = property;
                    }
                    else {
                        // validate duplicate order for primary key
                        if (pkeyMap[schema[property].primary_key["order"]]) {
                            throw new error_1.DuplicatePrimaryKeyOrderError(schema[property].primary_key["order"], pkeyMap[schema[property].primary_key["order"]]);
                        }
                        pkeyMap[schema[property].primary_key["order"]] = property;
                    }
                    //  autogenerate?
                    if (schema[property].primary_key["autoGenerate"]) {
                        thisProperty["autoGenerate"] = true;
                    }
                }
                // TODO: Add default_sort_by field
                // flat property could be a partition key
                if (schema[property].key) {
                    keyMap[schema[property].key["order"]] = property;
                }
                // property is string and has "maxLength" optional attribute
                if (thisProperty["type"] == types_1.TigrisDataTypes.STRING.valueOf() &&
                    thisProperty["format"] === undefined &&
                    schema[property].maxLength) {
                    thisProperty["maxLength"] = schema[property].maxLength;
                }
                // array type?
            }
            else if (schema[property].type === types_1.TigrisDataTypes.ARRAY.valueOf()) {
                thisProperty = this._getArrayBlock(schema[property], pkeyMap, keyMap);
            }
            properties[property] = thisProperty;
            // 'default' values for schema fields, if any
            if ("default" in schema[property]) {
                switch (schema[property].default) {
                    case undefined:
                        // eslint-disable-next-line unicorn/no-null
                        thisProperty["default"] = null;
                        break;
                    default:
                        thisProperty["default"] = schema[property].default;
                }
            }
            // whether secondary index is enabled for this field
            if ("index" in schema[property]) {
                thisProperty["index"] = schema[property]["index"];
            }
            // indexing optionals
            if ("searchIndex" in schema[property]) {
                thisProperty["searchIndex"] = schema[property]["searchIndex"];
            }
            if ("sort" in schema[property]) {
                thisProperty["sort"] = schema[property]["sort"];
            }
            if ("facet" in schema[property]) {
                thisProperty["facet"] = schema[property]["facet"];
            }
            if ("id" in schema[property]) {
                thisProperty["id"] = schema[property]["id"];
            }
            // 'timestamp' values for schema fields
            if ("timestamp" in schema[property]) {
                thisProperty[schema[property].timestamp] = true;
            }
        }
        return properties;
    },
    _readRequestOptionsToProtoReadRequestOptions(input) {
        const result = new api_pb_1.ReadRequestOptions();
        if (input !== undefined) {
            if (input.skip !== undefined) {
                result.setSkip(input.skip);
            }
            if (input.limit !== undefined) {
                result.setLimit(input.limit);
            }
            if (input.collation !== undefined) {
                result.setCollation(new api_pb_1.Collation().setCase(input.collation.case));
            }
            if (input.offset !== undefined) {
                result.setOffset(exports.Utility.stringToUint8Array(input.offset));
            }
        }
        return result;
    },
    _deleteRequestOptionsToProtoDeleteRequestOptions(input) {
        const result = new api_pb_1.DeleteRequestOptions();
        if (input !== undefined) {
            if (input.collation !== undefined) {
                result.setCollation(new api_pb_1.Collation().setCase(input.collation.case));
            }
            if (input.limit !== undefined) {
                result.setLimit(input.limit);
            }
        }
        return result;
    },
    _updateRequestOptionsToProtoUpdateRequestOptions(input) {
        const result = new api_pb_1.UpdateRequestOptions();
        if (input !== undefined) {
            if (input.collation !== undefined) {
                result.setCollation(new api_pb_1.Collation().setCase(input.collation.case));
            }
            if (input.limit !== undefined) {
                result.setLimit(input.limit);
            }
        }
        return result;
    },
    _getArrayBlock(arraySchema, pkeyMap, keyMap) {
        const arrayBlock = {};
        arrayBlock["type"] = "array";
        if (typeof arraySchema === "object" && "dimensions" in arraySchema) {
            arrayBlock["dimensions"] = arraySchema["dimensions"];
            arrayBlock["format"] = "vector";
        }
        else {
            arrayBlock["items"] = {};
            arrayBlock["items"] = this._getSchemaProperties({ _$arrayItemPlaceholder: arraySchema["items"] }, pkeyMap, keyMap)["_$arrayItemPlaceholder"];
        }
        return arrayBlock;
    },
    _getType(fieldType) {
        switch (fieldType.valueOf()) {
            case types_1.TigrisDataTypes.BOOLEAN:
                return "boolean";
            case types_1.TigrisDataTypes.INT32:
            case types_1.TigrisDataTypes.INT64:
            case types_1.TigrisDataTypes.NUMBER_BIGINT:
                return "integer";
            case types_1.TigrisDataTypes.NUMBER:
                return "number";
            case types_1.TigrisDataTypes.STRING:
            case types_1.TigrisDataTypes.UUID:
            case types_1.TigrisDataTypes.DATE_TIME:
            case types_1.TigrisDataTypes.BYTE_STRING:
                return "string";
            case types_1.TigrisDataTypes.OBJECT:
                return "object";
        }
        return undefined;
    },
    _getFormat(fieldType) {
        switch (fieldType.valueOf()) {
            case types_1.TigrisDataTypes.INT32:
                return "int32";
            case types_1.TigrisDataTypes.INT64:
                return "int64";
            case types_1.TigrisDataTypes.UUID:
                return "uuid";
            case types_1.TigrisDataTypes.DATE_TIME:
                return "date-time";
            case types_1.TigrisDataTypes.BYTE_STRING:
                return "byte";
        }
        return undefined;
    },
    _base64Encode(input) {
        return Buffer.from(input, "utf8").toString("base64");
    },
    _base64Decode(b64String) {
        return Buffer.from(b64String, "base64").toString("utf8");
    },
    _base64DecodeToObject(b64String, config) {
        return this.jsonStringToObj(Buffer.from(b64String, "base64").toString("utf8"), config);
    },
    defaultFacetingOptions(options) {
        const defaults = { size: 10, type: "value" };
        return Object.assign(Object.assign({}, defaults), options);
    },
    facetQueryToString(facets) {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const optionsMap = {};
        if (Array.isArray(facets)) {
            for (const f of facets) {
                optionsMap[f] = this.defaultFacetingOptions();
            }
        }
        else if (typeof facets === "object") {
            for (const f in facets) {
                optionsMap[f] = this.defaultFacetingOptions(facets[f]);
            }
        }
        return this.objToJsonString(optionsMap);
    },
    _vectorQueryToString(q) {
        if (typeof q === "undefined") {
            return "";
        }
        return this.objToJsonString(q);
    },
    _sortOrderingToString(ordering) {
        if (typeof ordering === "undefined") {
            return "[]";
        }
        const sortOrders = [];
        if (!Array.isArray(ordering)) {
            ordering = [ordering];
        }
        for (const o of ordering) {
            sortOrders.push({ [o.field]: o.order });
        }
        return this.objToJsonString(sortOrders);
    },
    _groupByToString(fields) {
        const groupBy = {
            fields: [],
        };
        if (typeof fields === "undefined") {
            return this.objToJsonString(groupBy);
        }
        groupBy.fields = [...fields];
        return this.objToJsonString(groupBy);
    },
    protoSearchRequestFromQuery(query, searchRequest, page) {
        var _a, _b;
        searchRequest.setQ((_a = query.q) !== null && _a !== void 0 ? _a : search_1.MATCH_ALL_QUERY_STRING);
        if (query.searchFields !== undefined) {
            searchRequest.setSearchFieldsList(query.searchFields);
        }
        if (query.filter !== undefined) {
            searchRequest.setFilter(exports.Utility.stringToUint8Array(exports.Utility.filterToString(query.filter)));
        }
        if (query.facets !== undefined) {
            searchRequest.setFacet(exports.Utility.stringToUint8Array(exports.Utility.facetQueryToString(query.facets)));
        }
        if (query.vectorQuery !== undefined) {
            searchRequest.setVector(exports.Utility.stringToUint8Array(exports.Utility._vectorQueryToString(query.vectorQuery)));
        }
        if (query.sort !== undefined) {
            searchRequest.setSort(exports.Utility.stringToUint8Array(exports.Utility._sortOrderingToString(query.sort)));
        }
        if (query.groupBy !== undefined) {
            searchRequest.setGroupBy(exports.Utility.stringToUint8Array(exports.Utility._groupByToString(query.groupBy)));
        }
        if (query.includeFields !== undefined) {
            searchRequest.setIncludeFieldsList(query.includeFields);
        }
        if (query.excludeFields !== undefined) {
            searchRequest.setExcludeFieldsList(query.excludeFields);
        }
        if (query.hitsPerPage !== undefined) {
            searchRequest.setPageSize(query.hitsPerPage);
        }
        if (((_b = query.options) === null || _b === void 0 ? void 0 : _b.collation) !== undefined) {
            searchRequest.setCollation(new api_pb_1.Collation().setCase(query.options.collation.case));
        }
        if (page !== undefined) {
            searchRequest.setPage(page);
        }
    },
};
