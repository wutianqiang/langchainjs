"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Collection = void 0;
const api_pb_1 = require("./proto/server/v1/api_pb");
const session_1 = require("./session");
const types_1 = require("./types");
const utility_1 = require("./utility");
const error_1 = require("./error");
const cursor_1 = require("./consumables/cursor");
const search_iterator_1 = require("./consumables/search-iterator");
const search_1 = require("./search");
const globals_1 = require("./globals");
/**
 * The **Collection** class represents Tigris collection allowing insert/find/update/delete/search
 * operations.
 * @public
 */
class Collection {
    constructor(collectionName, db, branch, grpcClient, config) {
        this.collectionName = collectionName;
        this.db = db;
        this.branch = branch;
        this.grpcClient = grpcClient;
        this._metadataStorage = (0, globals_1.getDecoratorMetaStorage)();
        this.config = config;
        this._collectionCreatedAtFieldNames = (() => {
            var _a;
            const collectionTarget = (_a = this._metadataStorage.collections.get(this.collectionName)) === null || _a === void 0 ? void 0 : _a.target;
            const collectionFields = this._metadataStorage.getCollectionFieldsByTarget(collectionTarget);
            return collectionFields
                .filter((field) => {
                var _a;
                return ((_a = field === null || field === void 0 ? void 0 : field.schemaFieldOptions) === null || _a === void 0 ? void 0 : _a.timestamp) === "createdAt";
            })
                .map((f) => f.name);
        })();
    }
    describe() {
        return new Promise((resolve, reject) => {
            const req = new api_pb_1.DescribeCollectionRequest()
                .setProject(this.db)
                .setBranch(this.branch)
                .setCollection(this.collectionName);
            this.grpcClient.describeCollection(req, (error, resp) => {
                if (error) {
                    return reject(error);
                }
                const schema = Buffer.from(resp.getSchema_asB64(), "base64").toString();
                const desc = new types_1.CollectionDescription(this.collectionName, resp.getMetadata(), schema, resp.toObject().indexesList);
                resolve(desc);
            });
        });
    }
    /**
     * Inserts multiple documents in Tigris collection.
     *
     * @param docs - Array of documents to insert
     * @param tx - Session information for transaction context
     */
    insertMany(docs, tx) {
        const encoder = new TextEncoder();
        return new Promise((resolve, reject) => {
            const docsArray = docs.map((doc) => encoder.encode(utility_1.Utility.objToJsonString(doc)));
            const protoRequest = new api_pb_1.InsertRequest()
                .setProject(this.db)
                .setBranch(this.branch)
                .setCollection(this.collectionName)
                .setDocumentsList(docsArray);
            this.grpcClient.insert(protoRequest, utility_1.Utility.txToMetadata(tx), (error, response) => {
                var _a, _b;
                if (error) {
                    reject(error);
                }
                else {
                    let clonedDocs;
                    clonedDocs = this.setDocsMetadata(docs, response.getKeysList_asU8());
                    if (response.getMetadata().hasCreatedAt()) {
                        const createdAt = new Date(((_b = (_a = response.getMetadata()) === null || _a === void 0 ? void 0 : _a.getCreatedAt()) === null || _b === void 0 ? void 0 : _b.getSeconds()) * 1000);
                        clonedDocs = this.setCreatedAtForDocsIfNotExists(clonedDocs, createdAt, this._collectionCreatedAtFieldNames);
                    }
                    resolve(clonedDocs);
                }
            });
        });
    }
    /**
     * Inserts a single document in Tigris collection.
     *
     * @param doc - Document to insert
     * @param tx - Session information for transaction context
     */
    insertOne(doc, tx) {
        return new Promise((resolve, reject) => {
            const docArr = [doc];
            this.insertMany(docArr, tx)
                .then((docs) => {
                resolve(docs[0]);
            })
                .catch((error) => {
                reject(error);
            });
        });
    }
    /**
     * Insert new or replace existing documents in collection.
     *
     * @param docs - Array of documents to insert or replace
     * @param tx - Session information for transaction context
     */
    insertOrReplaceMany(docs, tx) {
        return new Promise((resolve, reject) => {
            const docsArray = docs.map((doc) => new TextEncoder().encode(utility_1.Utility.objToJsonString(doc)));
            const protoRequest = new api_pb_1.ReplaceRequest()
                .setProject(this.db)
                .setBranch(this.branch)
                .setCollection(this.collectionName)
                .setDocumentsList(docsArray);
            this.grpcClient.replace(protoRequest, utility_1.Utility.txToMetadata(tx), (error, response) => {
                if (error) {
                    reject(error);
                }
                else {
                    const clonedDocs = this.setDocsMetadata(docs, response.getKeysList_asU8());
                    resolve(clonedDocs);
                }
            });
        });
    }
    /**
     * Insert new or replace an existing document in collection.
     *
     * @param doc - Document to insert or replace
     * @param tx - Session information for transaction context
     */
    insertOrReplaceOne(doc, tx) {
        return __awaiter(this, void 0, void 0, function* () {
            const docs = yield this.insertOrReplaceMany([doc], tx);
            return docs[0];
        });
    }
    updateMany(query, tx) {
        return new Promise((resolve, reject) => {
            const updateRequest = new api_pb_1.UpdateRequest()
                .setProject(this.db)
                .setBranch(this.branch)
                .setCollection(this.collectionName)
                .setFilter(utility_1.Utility.stringToUint8Array(utility_1.Utility.filterToString(query.filter)))
                .setFields(utility_1.Utility.stringToUint8Array(utility_1.Utility.updateFieldsString(query.fields)));
            if (query.options !== undefined) {
                updateRequest.setOptions(utility_1.Utility._updateRequestOptionsToProtoUpdateRequestOptions(query.options));
            }
            this.grpcClient.update(updateRequest, utility_1.Utility.txToMetadata(tx), (error, response) => {
                if (error) {
                    reject(error);
                }
                else {
                    const metadata = new types_1.DMLMetadata(response.getMetadata().getCreatedAt(), response.getMetadata().getUpdatedAt());
                    resolve(new types_1.UpdateResponse(response.getModifiedCount(), metadata));
                }
            });
        });
    }
    updateOne(query, tx) {
        if (query.options === undefined) {
            query.options = new types_1.UpdateQueryOptions(1);
        }
        else {
            query.options.limit = 1;
        }
        return this.updateMany(query, tx);
    }
    deleteMany(query, tx) {
        return new Promise((resolve, reject) => {
            if (typeof (query === null || query === void 0 ? void 0 : query.filter) === "undefined") {
                reject(new error_1.MissingArgumentError("filter"));
            }
            const deleteRequest = new api_pb_1.DeleteRequest()
                .setProject(this.db)
                .setBranch(this.branch)
                .setCollection(this.collectionName)
                .setFilter(utility_1.Utility.stringToUint8Array(utility_1.Utility.filterToString(query.filter)));
            if (query.options) {
                deleteRequest.setOptions(utility_1.Utility._deleteRequestOptionsToProtoDeleteRequestOptions(query.options));
            }
            this.grpcClient.delete(deleteRequest, utility_1.Utility.txToMetadata(tx), (error, response) => {
                if (error) {
                    reject(error);
                }
                else {
                    const metadata = new types_1.DMLMetadata(response.getMetadata().getCreatedAt(), response.getMetadata().getUpdatedAt());
                    resolve(new types_1.DeleteResponse(metadata));
                }
            });
        });
    }
    deleteOne(query, tx) {
        if (query.options === undefined) {
            query.options = new types_1.DeleteQueryOptions(1);
        }
        else {
            query.options.limit = 1;
        }
        return this.deleteMany(query, tx);
    }
    findMany(txOrQuery, tx) {
        let query;
        if (typeof txOrQuery !== "undefined") {
            if (this.isTxSession(txOrQuery)) {
                tx = txOrQuery;
            }
            else {
                query = txOrQuery;
            }
        }
        const findAll = {};
        if (!query) {
            query = { filter: findAll };
        }
        else if (!query.filter) {
            query.filter = findAll;
        }
        const readRequest = new api_pb_1.ReadRequest()
            .setProject(this.db)
            .setBranch(this.branch)
            .setCollection(this.collectionName)
            .setFilter(utility_1.Utility.stringToUint8Array(utility_1.Utility.filterToString(query.filter)));
        if (query.readFields) {
            readRequest.setFields(utility_1.Utility.stringToUint8Array(utility_1.Utility.readFieldString(query.readFields)));
        }
        if (query.sort) {
            readRequest.setSort(utility_1.Utility.stringToUint8Array(utility_1.Utility._sortOrderingToString(query.sort)));
        }
        if (query.options) {
            readRequest.setOptions(utility_1.Utility._readRequestOptionsToProtoReadRequestOptions(query.options));
        }
        const initializer = new cursor_1.ReadCursorInitializer(this.grpcClient, readRequest, tx);
        return new cursor_1.Cursor(initializer, this.config);
    }
    /**
     * Returns a explain response on how Tigris would process a query
     *
     * @returns - The explain response
     *
     * @example
     * ```
     * 	const explain = await db.getCollection<Book>(Book).explain({"author": "Brandon Sanderson"});
     *	console.log(`Read Type: ${explain.readType}, Key Ranges: ${explain.KeyRange}, field: ${explain.field}`)
     *
     * ```
     */
    explain(query) {
        const readRequest = new api_pb_1.ReadRequest()
            .setProject(this.db)
            .setBranch(this.branch)
            .setCollection(this.collectionName)
            .setFilter(utility_1.Utility.stringToUint8Array(utility_1.Utility.filterToString(query.filter)));
        return new Promise((resolve, reject) => {
            this.grpcClient.explain(readRequest, (err, resp) => {
                if (err) {
                    return reject(err);
                }
                const explainResp = resp.toObject();
                explainResp.readType =
                    resp.getReadType() === "secondary index"
                        ? "secondary index"
                        : "primary index";
                resolve(explainResp);
            });
        });
    }
    /**
     * Count the number of documents in a collection
     * @returns - the number of documents in a collection
     *
     * @example
     * ```
     * const countPromise = db.getCollection<Book>(Book).count();
     *
     * countPromise
     * 		.then(count: number) => console.log(count);
     * 		.catch( // catch the error)
     * 		.finally( // finally do something)
     * ```
     */
    count(filter) {
        if (!filter) {
            filter = {};
        }
        const countRequest = new api_pb_1.CountRequest()
            .setProject(this.db)
            .setCollection(this.collectionName)
            .setBranch(this.branch)
            .setFilter(utility_1.Utility.stringToUint8Array(utility_1.Utility.filterToString(filter)));
        return new Promise((resolve, reject) => {
            this.grpcClient.count(countRequest, (err, response) => {
                if (err) {
                    return reject(err);
                }
                resolve(response.getCount());
            });
        });
    }
    findOne(txOrQuery, tx) {
        return __awaiter(this, void 0, void 0, function* () {
            let query;
            if (typeof txOrQuery !== "undefined") {
                if (this.isTxSession(txOrQuery)) {
                    tx = txOrQuery;
                }
                else {
                    query = txOrQuery;
                }
            }
            const findOnlyOne = new types_1.FindQueryOptions(1);
            if (!query) {
                query = { options: findOnlyOne };
            }
            else if (!query.options) {
                query.options = findOnlyOne;
            }
            else {
                query.options.limit = findOnlyOne.limit;
            }
            const cursor = this.findMany(query, tx);
            const iteratorResult = yield cursor[Symbol.asyncIterator]().next();
            return iteratorResult === null || iteratorResult === void 0 ? void 0 : iteratorResult.value;
        });
    }
    search(query, page) {
        const searchRequest = new api_pb_1.SearchRequest()
            .setProject(this.db)
            .setBranch(this.branch)
            .setCollection(this.collectionName);
        utility_1.Utility.protoSearchRequestFromQuery(query, searchRequest, page);
        // return a iterator if no explicit page number is specified
        if (typeof page === "undefined") {
            const initializer = new search_iterator_1.SearchIteratorInitializer(this.grpcClient, searchRequest);
            return new search_iterator_1.SearchIterator(initializer, this.config);
        }
        else {
            return new Promise((resolve, reject) => {
                const stream = this.grpcClient.search(searchRequest);
                stream.on("data", (searchResponse) => {
                    const searchResult = search_1.SearchResult.from(searchResponse, this.config);
                    resolve(searchResult);
                });
                stream.on("error", (error) => reject(error));
                stream.on("end", () => resolve(search_1.SearchResult.empty));
            });
        }
    }
    isTxSession(txOrQuery) {
        const mayBeTx = txOrQuery;
        return "id" in mayBeTx && mayBeTx instanceof session_1.Session;
    }
    setDocsMetadata(docs, keys) {
        let docIndex = 0;
        const clonedDocs = Object.assign([], docs);
        for (const value of keys) {
            const keyValueJsonObj = utility_1.Utility.jsonStringToObj(utility_1.Utility.uint8ArrayToString(value), this.config);
            for (const fieldName of Object.keys(keyValueJsonObj)) {
                Reflect.set(clonedDocs[docIndex], fieldName, keyValueJsonObj[fieldName]);
            }
            docIndex++;
        }
        return clonedDocs;
    }
    setCreatedAtForDocsIfNotExists(docs, createdAt, collectionCreatedAtFieldNames) {
        const clonedDocs = Object.assign([], docs);
        let docIndex = 0;
        for (const doc of docs) {
            collectionCreatedAtFieldNames.map((fieldName) => {
                if (!Reflect.has(doc, fieldName)) {
                    Reflect.set(clonedDocs[docIndex], fieldName, createdAt);
                }
            });
            docIndex++;
        }
        return clonedDocs;
    }
}
exports.Collection = Collection;
