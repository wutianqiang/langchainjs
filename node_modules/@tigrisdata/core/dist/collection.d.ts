import { TigrisClient } from "./proto/server/v1/api_grpc_pb";
import { Session } from "./session";
import { CollectionDescription, DeleteQuery, DeleteResponse, ExplainResponse, Filter, FindQuery, TigrisCollectionType, UpdateQuery, UpdateResponse } from "./types";
import { TigrisClientConfig } from "./tigris";
import { Cursor } from "./consumables/cursor";
import { SearchIterator } from "./consumables/search-iterator";
import { SearchQuery } from "./search";
import { SearchResult } from "./search";
interface ICollection {
    readonly collectionName: string;
    readonly db: string;
}
/**
 * The **Collection** class represents Tigris collection allowing insert/find/update/delete/search
 * operations.
 * @public
 */
export declare class Collection<T extends TigrisCollectionType> implements ICollection {
    readonly collectionName: string;
    readonly db: string;
    readonly branch: string;
    readonly grpcClient: TigrisClient;
    readonly config: TigrisClientConfig;
    private readonly _metadataStorage;
    private readonly _collectionCreatedAtFieldNames;
    constructor(collectionName: string, db: string, branch: string, grpcClient: TigrisClient, config: TigrisClientConfig);
    describe(): Promise<CollectionDescription>;
    /**
     * Inserts multiple documents in Tigris collection.
     *
     * @param docs - Array of documents to insert
     * @param tx - Session information for transaction context
     */
    insertMany(docs: Array<T>, tx?: Session): Promise<Array<T>>;
    /**
     * Inserts a single document in Tigris collection.
     *
     * @param doc - Document to insert
     * @param tx - Session information for transaction context
     */
    insertOne(doc: T, tx?: Session): Promise<T>;
    /**
     * Insert new or replace existing documents in collection.
     *
     * @param docs - Array of documents to insert or replace
     * @param tx - Session information for transaction context
     */
    insertOrReplaceMany(docs: Array<T>, tx?: Session): Promise<Array<T>>;
    /**
     * Insert new or replace an existing document in collection.
     *
     * @param doc - Document to insert or replace
     * @param tx - Session information for transaction context
     */
    insertOrReplaceOne(doc: T, tx?: Session): Promise<T>;
    /**
     * Update multiple documents in a collection
     *
     * @param query - Filter to match documents and the update operations. Update
     * 								will be applied to matching documents only.
     * @returns {@link UpdateResponse}
     *
     * @example To update **language** of all books published by "Marcel Proust"
     * ```
     * const updatePromise = db.getCollection<Book>(Book).updateMany({
     *   filter: { author: "Marcel Proust" },
     *   fields: { language: "French" }
     * });
     *
     * updatePromise
     * 		.then((resp: UpdateResponse) => console.log(resp));
     * 		.catch( // catch the error)
     * 		.finally( // finally do something);
     * ```
     */
    updateMany(query: UpdateQuery<T>): Promise<UpdateResponse>;
    /**
     * Update multiple documents in a collection in transactional context
     *
     * @param query - Filter to match documents and the update operations. Update
     * 								will be applied to matching documents only.
     * @param tx - Session information for transaction context
     * @returns {@link UpdateResponse}
     *
     * @example To update **language** of all books published by "Marcel Proust"
     * ```
     * const updatePromise = db.getCollection<Book>(Book).updateMany({
     *   filter: { author: "Marcel Proust" },
     *   fields: { language: "French" }
     * }, tx);
     *
     * updatePromise
     * 		.then((resp: UpdateResponse) => console.log(resp));
     * 		.catch( // catch the error)
     * 		.finally( // finally do something);
     * ```
     */
    updateMany(query: UpdateQuery<T>, tx: Session): Promise<UpdateResponse>;
    /**
     * Update a single document in collection
     *
     * @param query - Filter to match the document and the update operations. Update
     * 								will be applied to matching documents only.
     * @returns {@link UpdateResponse}
     *
     * @example To update **language** of a book published by "Marcel Proust"
     * ```
     * const updatePromise = db.getCollection<Book>(Book).updateOne({
     *   filter: { author: "Marcel Proust" },
     *   fields: { language: "French" }
     * });
     *
     * updatePromise
     * 		.then((resp: UpdateResponse) => console.log(resp));
     * 		.catch( // catch the error)
     * 		.finally( // finally do something);
     * ```
     */
    updateOne(query: UpdateQuery<T>): Promise<UpdateResponse>;
    /**
     * Update a single document in a collection in transactional context
     *
     * @param query - Filter to match the document and update operations. Update
     * 								will be applied to a single matching document only.
     * @param tx - Session information for transaction context
     * @returns {@link UpdateResponse}
     *
     * @example To update **language** of a book published by "Marcel Proust"
     * ```
     * const updatePromise = db.getCollection<Book>(Book).updateOne({
     *   filter: { author: "Marcel Proust" },
     *   fields: { language: "French" }
     * }, tx);
     *
     * updatePromise
     * 		.then((resp: UpdateResponse) => console.log(resp));
     * 		.catch( // catch the error)
     * 		.finally( // finally do something);
     * ```
     */
    updateOne(query: UpdateQuery<T>, tx: Session): Promise<UpdateResponse>;
    /**
     * Delete documents from collection matching the query
     *
     * @param query - Filter to match documents and other deletion options
     * @returns {@link DeleteResponse}
     *
     * @example
     *
     * ```
     * const deletionPromise = db.getCollection<Book>(Book).deleteMany({
     * 		filter: { author: "Marcel Proust" }
     * });
     *
     * deletionPromise
     * 		.then((resp: DeleteResponse) => console.log(resp));
     * 		.catch( // catch the error)
     * 		.finally( // finally do something);
     * ```
     */
    deleteMany(query: DeleteQuery<T>): Promise<DeleteResponse>;
    /**
     * Delete documents from collection in transactional context
     *
     * @param query - Filter to match documents and other deletion options
     * @param tx - Session information for transaction context
     * @returns {@link DeleteResponse}
     *
     * @example
     *
     * ```
     * const deletionPromise = db.getCollection<Book>(Book).deleteMany({
     * 		filter: { author: "Marcel Proust" }
     * }, tx);
     *
     * deletionPromise
     * 		.then((resp: DeleteResponse) => console.log(resp));
     * 		.catch( // catch the error)
     * 		.finally( // finally do something);
     * ```
     */
    deleteMany(query: DeleteQuery<T>, tx: Session): Promise<DeleteResponse>;
    /**
     * Delete a single document from collection matching the query
     *
     * @param query - Filter to match documents and other deletion options
     * @returns {@link DeleteResponse}
     *
     * @example
     *
     * ```
     * const deletionPromise = db.getCollection<Book>(Book).deleteOne({
     * 		filter: { author: "Marcel Proust" }
     * });
     *
     * deletionPromise
     * 		.then((resp: DeleteResponse) => console.log(resp));
     * 		.catch( // catch the error)
     * 		.finally( // finally do something);
     * ```
     */
    deleteOne(query: DeleteQuery<T>): Promise<DeleteResponse>;
    /**
     * Delete a single document from collection in transactional context
     *
     * @param query - Filter to match documents and other deletion options
     * @param tx - Session information for transaction context
     * @returns {@link DeleteResponse}
     *
     * @example
     *
     * ```
     * const deletionPromise = db.getCollection<Book>(Book).deleteOne({
     * 		filter: { author: "Marcel Proust" }
     * }, tx);
     *
     * deletionPromise
     * 		.then((resp: DeleteResponse) => console.log(resp));
     * 		.catch( // catch the error)
     * 		.finally( // finally do something);
     * ```
     */
    deleteOne(query: DeleteQuery<T>, tx: Session): Promise<DeleteResponse>;
    /**
     * Read all the documents from a collection.
     *
     * @returns - {@link Cursor} to iterate over documents
     *
     * @example
     * ```
     * const cursor = db.getCollection<Book>(Book).findMany();
     *
     * for await (const document of cursor) {
     *   console.log(document);
     * }
     * ```
     */
    findMany(): Cursor<T>;
    /**
     * Reads all the documents from a collection in transactional context.
     *
     * @param tx - Session information for Transaction
     * @returns - {@link Cursor} to iterate over documents
     *
     * @example
     * ```
     * const cursor = db.getCollection<Book>(Book).findMany(tx);
     *
     * for await (const document of cursor) {
     *   console.log(document);
     * }
     * ```
     */
    findMany(tx: Session): Cursor<T>;
    /**
     * Performs a read query on collection and returns a cursor that can be used to iterate over
     * query results.
     *
     * @param query - Filter, field projection and other parameters
     * @returns - {@link Cursor} to iterate over documents
     *
     * @example
     * ```
     * const cursor = db.getCollection<Book>(Book).findMany({
     * 		filter: { author: "Marcel Proust" },
     * 		readFields: { include: ["id", "title"] }
     * });
     *
     * for await (const document of cursor) {
     *   console.log(document);
     * }
     * ```
     */
    findMany(query: FindQuery<T>): Cursor<T>;
    /**
     * Performs a read query on collection in transactional context and returns a
     * cursor that can be used to iterate over query results.
     *
     * @param query - Filter, field projection and other parameters
     * @param tx - Session information for Transaction
     * @returns - {@link Cursor} to iterate over documents
     *
     * @example
     * ```
     * const cursor = db.getCollection<Book>(Book).findMany({
     * 		filter: { author: "Marcel Proust" },
     * 		readFields: { include: ["id", "title"] }
     * }, tx);
     *
     * for await (const document of cursor) {
     *   console.log(document);
     * }
     * ```
     */
    findMany(query: FindQuery<T>, tx: Session): Cursor<T>;
    /**
     * Returns a explain response on how Tigris would process a query
     *
     * @returns - The explain response
     *
     * @example
     * ```
     * 	const explain = await db.getCollection<Book>(Book).explain({"author": "Brandon Sanderson"});
     *	console.log(`Read Type: ${explain.readType}, Key Ranges: ${explain.KeyRange}, field: ${explain.field}`)
     *
     * ```
     */
    explain(query: FindQuery<T>): Promise<ExplainResponse>;
    /**
     * Count the number of documents in a collection
     * @returns - the number of documents in a collection
     *
     * @example
     * ```
     * const countPromise = db.getCollection<Book>(Book).count();
     *
     * countPromise
     * 		.then(count: number) => console.log(count);
     * 		.catch( // catch the error)
     * 		.finally( // finally do something)
     * ```
     */
    count(filter?: Filter<T>): Promise<number>;
    /**
     * Read a single document from collection.
     *
     * @returns - The document if found else **undefined**
     *
     * @example
     * ```
     * const documentPromise = db.getCollection<Book>(Book).findOne();
     *
     * documentPromise
     * 		.then((doc: Book | undefined) => console.log(doc));
     * 		.catch( // catch the error)
     * 		.finally( // finally do something);
     * ```
     */
    findOne(): Promise<T | undefined>;
    /**
     * Read a single document from collection in transactional context
     *
     * @param tx - Session information for Transaction
     * @returns - The document if found else **undefined**
     *
     * @example
     * ```
     * const documentPromise = db.getCollection<Book>(Book).findOne(tx);
     *
     * documentPromise
     * 		.then((doc: Book | undefined) => console.log(doc));
     * 		.catch( // catch the error)
     * 		.finally( // finally do something);
     * ```
     */
    findOne(tx: Session): Promise<T | undefined>;
    /**
     * Performs a read query on the collection and returns a single document matching
     * the query.
     *
     * @param query - Filter, field projection and other parameters
     * @returns - The document if found else **undefined**
     *
     * @example
     * ```
     * const documentPromise = db.getCollection<Book>(Book).findOne({
     * 		filter: { author: "Marcel Proust" },
     * 		readFields: { include: ["id", "title"] }
     * });
     *
     * documentPromise
     * 		.then((doc: Book | undefined) => console.log(doc));
     * 		.catch( // catch the error)
     * 		.finally( // finally do something);
     * ```
     */
    findOne(query: FindQuery<T>): Promise<T | undefined>;
    /**
     * Performs a read query on the collection in transactional context and returns
     * a single document matching the query.
     *
     * @param query - Filter, field projection and other parameters
     * @param tx - Session information for Transaction
     * @returns - The document if found else **undefined**
     *
     * @example
     * ```
     * const documentPromise = db.getCollection<Book>(Book).findOne({
     * 		filter: { author: "Marcel Proust" },
     * 		readFields: { include: ["id", "title"] }
     * }, tx);
     *
     * documentPromise
     * 		.then((doc: Book | undefined) => console.log(doc));
     * 		.catch( // catch the error)
     * 		.finally( // finally do something);
     * ```
     */
    findOne(query: FindQuery<T>, tx: Session): Promise<T | undefined>;
    /**
     * Search for documents in a collection. Easily perform sophisticated queries and refine
     * results using filters with advanced features like faceting and ordering.
     *
     * @param query - Search query to execute
     * @returns {@link SearchIterator} - To iterate over pages of {@link SearchResult}
     *
     * @example
     * ```
     * const iterator = db.getCollection<Book>(Book).search(query);
     *
     * for await (const resultPage of iterator) {
     *   console.log(resultPage.hits);
     *   console.log(resultPage.facets);
     * }
     * ```
     */
    search(query: SearchQuery<T>): SearchIterator<T>;
    /**
     * Search for documents in a collection. Easily perform sophisticated queries and refine
     * results using filters with advanced features like faceting and ordering.
     *
     * @param query - Search query to execute
     * @param page - Page number to retrieve. Page number `1` fetches the first page of search results.
     * @returns - Single page of results wrapped in a Promise
     *
     * @example To retrieve page number 5 of matched documents
     * ```
     * const resultPromise = db.getCollection<Book>(Book).search(query, 5);
     *
     * resultPromise
     * 		.then((res: SearchResult<Book>) => console.log(res.hits))
     * 		.catch( // catch the error)
     * 		.finally( // finally do something);
     *
     * ```
     */
    search(query: SearchQuery<T>, page: number): Promise<SearchResult<T>>;
    private isTxSession;
    private setDocsMetadata;
    private setCreatedAtForDocsIfNotExists;
}
export {};
