"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Cache = void 0;
const types_1 = require("./types");
const cache_pb_1 = require("./proto/server/v1/cache_pb");
const utility_1 = require("./utility");
const cursor_1 = require("./consumables/cursor");
class Cache {
    constructor(projectName, cacheName, cacheClient, config) {
        this._projectName = projectName;
        this._cacheName = cacheName;
        this._cacheClient = cacheClient;
        this._config = config;
    }
    /**
     * returns cache name
     */
    getCacheName() {
        return this._cacheName;
    }
    /**
     * Sets the key with value. It will override the value if already exists
     * @param key - key to set
     * @param value - value for the key
     * @param options - optionally set params.
     * @example
     * ```
     * const c1 = tigris.GetCache("c1);
     * const setResp = await c1.set("k1", "v1");
     * console.log(setResp.status);
     * ```
     */
    set(key, value, options) {
        return new Promise((resolve, reject) => {
            const req = new cache_pb_1.SetRequest()
                .setProject(this._projectName)
                .setName(this._cacheName)
                .setKey(key)
                .setValue(new TextEncoder().encode(utility_1.Utility.objToJsonString(value)));
            if (options !== undefined && options.ex !== undefined) {
                req.setEx(options.ex);
            }
            if (options !== undefined && options.px !== undefined) {
                req.setPx(options.px);
            }
            if (options !== undefined && options.nx !== undefined) {
                req.setNx(options.nx);
            }
            if (options !== undefined && options.xx !== undefined) {
                req.setXx(options.xx);
            }
            this._cacheClient.set(req, (error, response) => {
                if (error) {
                    reject(error);
                }
                else {
                    resolve(new types_1.CacheSetResponse(response.getMessage()));
                }
            });
        });
    }
    /**
     * Sets the key with value. And returns the old value (if exists)
     *
     * @param key - key to set
     * @param value - value for the key
     * @example
     * ```
     * const c1 = tigris.GetCache("c1);
     * const getSetResp = await c1.getSet("k1", "v1");
     * console.log(getSetResp.old_value);
     * ```
     */
    getSet(key, value) {
        return new Promise((resolve, reject) => {
            const req = new cache_pb_1.GetSetRequest()
                .setProject(this._projectName)
                .setName(this._cacheName)
                .setKey(key)
                .setValue(new TextEncoder().encode(utility_1.Utility.objToJsonString(value)));
            this._cacheClient.getSet(req, (error, response) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.getOldValue() !== undefined && response.getOldValue_asU8().length > 0) {
                        resolve(new types_1.CacheGetSetResponse(response.getMessage(), utility_1.Utility._base64DecodeToObject(response.getOldValue_asB64(), this._config)));
                    }
                    else {
                        resolve(new types_1.CacheGetSetResponse(response.getMessage()));
                    }
                }
            });
        });
    }
    /**
     * Get the value for the key, errors if the key doesn't exist or expired
     *
     * @param key - key to retrieve value for
     * @example
     * ```
     * const c1 = tigris.GetCache("c1);
     * const getResp = await c1.get("k1");
     * console.log(getResp.value);
     * ```
     */
    get(key) {
        return new Promise((resolve, reject) => {
            this._cacheClient.get(new cache_pb_1.GetRequest().setProject(this._projectName).setName(this._cacheName).setKey(key), (error, response) => {
                if (error) {
                    reject(error);
                }
                else {
                    resolve(new types_1.CacheGetResponse(utility_1.Utility._base64DecodeToObject(response.getValue_asB64(), this._config)));
                }
            });
        });
    }
    /**
     * Deletes a key from cache
     *
     * @param key - key to delete
     * @example
     * ```
     * const c1 = tigris.GetCache("c1);
     * const delResp = await c1.del("k1");
     * console.log(delResp.status);
     * ```
     */
    del(key) {
        return new Promise((resolve, reject) => {
            this._cacheClient.del(new cache_pb_1.DelRequest().setProject(this._projectName).setName(this._cacheName).setKey(key), (error, response) => {
                if (error) {
                    reject(error);
                }
                else {
                    resolve(new types_1.CacheDelResponse(response.getStatus(), response.getMessage()));
                }
            });
        });
    }
    /**
     * returns an array of keys, complying the pattern
     * @param pattern - optional argument to filter keys
     * @example
     * ```
     * const c1 = tigris.GetCache("c1);
     * const keysCursor = await c1.keys();
     * for await (const keys of keysCursor) {
     *	console.log(keys);
     * }
     * ```
     */
    keys(pattern) {
        const req = new cache_pb_1.KeysRequest().setProject(this._projectName).setName(this._cacheName);
        if (pattern !== undefined) {
            req.setPattern(pattern);
        }
        this._cacheClient.keys(req);
        const initializer = new cursor_1.CacheKeysCursorInitializer(this._cacheClient, req);
        return new cursor_1.CacheKeysCursor(initializer);
    }
}
exports.Cache = Cache;
