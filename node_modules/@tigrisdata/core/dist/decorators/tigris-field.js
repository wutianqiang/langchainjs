"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Field = void 0;
require("reflect-metadata");
const types_1 = require("../types");
const error_1 = require("../error");
const globals_1 = require("../globals");
const logger_1 = require("../utils/logger");
const utils_1 = require("./utils");
/**
 * Field decorator is used to mark a class property as Collection field. Only properties
 * decorated with `@Field` will be used in Schema.
 */
function Field(typeOrOptions, options) {
    return function (target, propertyName) {
        propertyName = propertyName.toString();
        let propertyType;
        let fieldOptions;
        let embedOptions;
        if (typeof typeOrOptions === "string") {
            propertyType = typeOrOptions;
        }
        else if (typeof typeOrOptions === "object") {
            if ((0, utils_1.isEmbeddedOption)(typeOrOptions)) {
                embedOptions = typeOrOptions;
            }
            fieldOptions = typeOrOptions;
        }
        if (typeof options === "object") {
            if ((0, utils_1.isEmbeddedOption)(options)) {
                embedOptions = options;
            }
            fieldOptions = options;
        }
        // if type or options are not specified, infer using reflection
        if (!propertyType) {
            logger_1.Log.info(`Using reflection to infer type of ${target.constructor.name}#${propertyName}`);
            let reflectedType;
            try {
                reflectedType =
                    Reflect && Reflect.getMetadata
                        ? Reflect.getMetadata("design:type", target, propertyName)
                        : undefined;
                propertyType = (0, utils_1.getTigrisTypeFromReflectedType)(reflectedType.name);
            }
            catch (_a) {
                throw new error_1.ReflectionNotEnabled(target, propertyName);
            }
            // if propertyType is Array, type of contents is required unless its a vector
            if (propertyType === types_1.TigrisDataTypes.ARRAY) {
                if ((fieldOptions === null || fieldOptions === void 0 ? void 0 : fieldOptions.dimensions) !== undefined) {
                    if ((embedOptions === null || embedOptions === void 0 ? void 0 : embedOptions.elements) && (embedOptions === null || embedOptions === void 0 ? void 0 : embedOptions.elements) !== types_1.TigrisDataTypes.NUMBER) {
                        throw new error_1.IncorrectVectorDefError(target, propertyName);
                    }
                    embedOptions = { elements: types_1.TigrisDataTypes.NUMBER };
                }
                else if ((embedOptions === null || embedOptions === void 0 ? void 0 : embedOptions.elements) === undefined) {
                    throw new error_1.IncompleteArrayTypeDefError(target, propertyName);
                }
            }
            // if propertyType is still undefined, it probably is a typed object
            if (propertyType === undefined) {
                propertyType = types_1.TigrisDataTypes.OBJECT;
                embedOptions = { elements: reflectedType };
            }
        }
        if (!propertyType) {
            throw new error_1.CannotInferFieldTypeError(target, propertyName);
        }
        // if propertyType is Array, subtype is required
        if (propertyType === types_1.TigrisDataTypes.ARRAY && (embedOptions === null || embedOptions === void 0 ? void 0 : embedOptions.elements) === undefined) {
            throw new error_1.IncompleteArrayTypeDefError(target, propertyName);
        }
        (0, globals_1.getDecoratorMetaStorage)().collectionFields.push({
            name: propertyName,
            type: propertyType,
            isArray: propertyType === types_1.TigrisDataTypes.ARRAY,
            target: target.constructor,
            embedType: embedOptions === null || embedOptions === void 0 ? void 0 : embedOptions.elements,
            arrayDepth: embedOptions === null || embedOptions === void 0 ? void 0 : embedOptions.depth,
            schemaFieldOptions: fieldOptions,
        });
    };
}
exports.Field = Field;
